<?xml version="1.0" encoding="UTF-8"?><rss version="2.0" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Integrate Life</title><description>My story of discovery</description><link>https://blog.mslxl.com/</link><item><title>“证明” 9 宫格</title><link>https://blog.mslxl.com/posts/fun/proof-9cell/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/fun/proof-9cell/</guid><description>有人托梦给我了 trival table</description><pubDate>Sat, 12 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import { Typst } from &apos;astro-typst/src/components&apos;&lt;/p&gt;
&lt;p&gt;&amp;lt;div width=&quot;100%&quot;&amp;gt;
&amp;lt;Typst width=&quot;100%&quot; height=&quot;auto&quot; src=&quot;src/content/posts/fun/proof-9cell/content.typ&quot; /&amp;gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
</content:encoded><category>Typst</category><author>Mslxl</author></item><item><title>MarvelOVD</title><link>https://blog.mslxl.com/posts/thesis/marvelovd/marvelovd/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/thesis/marvelovd/marvelovd/</guid><description>MarvelOVD: Marrying Object Recognition and Vision-Language Models for Robust Open-Vocabulary Object Detection</description><pubDate>Tue, 08 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;论文原标题：&lt;em&gt;MarvelOVD: Marrying Object Recognition and Vision-Language Models for Robust Open-Vocabulary Object Detection&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;该文章为个人阅读笔记。由于我对人工智能几乎是零基础，其内容可能缺乏细节，亦有可能存在错误。&lt;/p&gt;
&lt;p&gt;实际上，我的人工智能学习是从这篇文章开始 DFS。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250331212608581.png&quot; alt=&quot;Sticker:我是人工智能的对立面&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;摘要&lt;/h3&gt;
&lt;p&gt;从 VLMs 生成的 pseudo-labels 中进行学习是一种十分可行的辅助 open vocabulary detection（OVD）[^1]的解决方法。&lt;/p&gt;
&lt;p&gt;然而由于 VLM 和视觉检测任务之间的 domain gap，VLMs 产生的 pseudo-labels 可能存在噪声，同时 detector 的训练设计进一步放大了偏差。&lt;/p&gt;
&lt;p&gt;该文章调查了 VLMs 在 OVD 的上下文下产生偏差的原因，并提出了一个简单高效的范式: MarvelOVD，可以生成更好的训练目标，并通过在融合 detector 和 VLM 的方式，以在线方式[^2]优化学习过程。文章核心观点：&lt;strong&gt;detector 本身就可以作为强大的辅助指导，用来适应 VLM 无法理解图像的 &quot;背景&quot; 和目的的上下文。&lt;/strong&gt; 基于该观点，文章作者进行了以下行为来减少了 pseudo 的噪音：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;通过 Online Mining 和 Adaptive Reweighting 有效的抑制了没有和目标对象对齐的存在 bias 的训练框。&lt;/li&gt;
&lt;li&gt;找到了一个被忽略的 &quot;base-novel-conflict&quot; 问题，并引入 stratified label assignments 来解决此问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个方法在 COCO 和 LVIS 数据集上的实验展示出了比其他 SOTA 更加显著的优势。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250331195018281.png&quot; alt=&quot;效果展示&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;Intro 部分开头首先简要介绍了 OVD[^5]。接着指出为了增强 OVD detector 的泛用性，人们开始将 VLMs 与 OVD detector 结合使用用来改善现有的 OVD pipeline，这种方式被证实具有极佳的 zero-shot 识别能力。&lt;/p&gt;
&lt;p&gt;识别已知新概念(known novel concepts)[^3]的 OVD 任务常见做法是使用 VLM(例如 CLIP) 以离线的方式生成 pseudo-label[^4]。这种方式主要有两个问题: 错误分类(mis-class) 和噪音(noisy)。虽说如此，基于 VLM 的方式产生的错误分类概率非常低，但是噪音却相当多(error rate 76.6%)。&lt;/p&gt;
&lt;p&gt;作者认为 VLMs 难以识别噪音的原因有两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;缺少对裁剪后图片的上下文信息：比如将人的胳膊单独裁剪成一张图片，模型就可能将其误判成“领带”而不是连接到人身上的一部分。&lt;/li&gt;
&lt;li&gt;无法感知“背景”元素，但即使输入内容与任何目标类别无关，CLIP 模型仍必须提供预测。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但是 detectors 中的 RoI align 技术却可以从局部区域中提供丰富的上下文信息。检测器能够在推理过程中理解“背景”的概念。因此， VLMs 中难以处理的噪声问题可以被 detector 轻易区分为“背景”。进而作者提出了 MarvelOVD，它通过结合目标检测器和VLMs的优点，可以产生高质量的 pseudo-labels，同时拥有出色的性能。&lt;/p&gt;
&lt;p&gt;对于伪标签生成来说，预测类别的置信度是基于 detector 和 VLM 输出的加权和。为了加速训练，作者采用预训练的 VLM 预测所有的候选框，同时在每次迭代时在 detector 的指导下动态挖掘可信的 pseudo-labels。即使是在训练早期，探测器和 VLM 能力的互补显著也能提高了 pseudo-labels 的准确性。此外，在 detector 在训练期间不断改善，新生成的 pseudo-labels 的质量也会随之提高。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;传统的目标检测训练方式平等的将每一个 proposal 与一个训练的目标相匹配，这种设计不适用于从 pseudo-labels 中学习。&lt;/strong&gt; 具体来说，就是生成的 box 可能和真实的物体的边界相差很大，导致训练框与实际上真实的物体存在较大的差异。为了修复这个问题，作者提出 proposal 所产生的训练框不应该对最终的 loss 有相同的贡献，即使是对同一个 pseudo-label 的训练框也不应当相同。为了达成这个目的，作者没有对 pseudo-labels 进行加权[^6]，而是自适应的为每个伪标签匹配的训练框计算个体权重。通过这种方式使位置不准确的训练框受到更小的权重。注意训练框是由 stratified label assignment 策略产生，它可以去除 pseudo-labels 和 base annotations 的冲突，因此可以阻止 pseudo-label噪声的负面影响。&lt;/p&gt;
&lt;h2&gt;Preliminaries&lt;/h2&gt;
&lt;p&gt;OVD 的目的是利用数据集 $D={x_i, y_i}^n_{i=1}$ 和辅助弱监督数据（即图文对, VMLs 等）。这里的 $x_i$ 表示图像而 $y_i$ 则是图像中检测目标的对应的位置和种类信息。不同于传统的检测任务中图像的标注在这里只覆盖了 base categories $C^B$，OVD 任务要求 detector在测试期间额外探测 novel categories $C^N$。这里的 $C^B \cap C^N = \emptyset$，并且 $C^N$ 在训练期间已知。&lt;/p&gt;
&lt;p&gt;为了实现这个任务，detector 中的 classification head 被设计为比较区域内图像 embedding 和文字 embeddings 的相似度（即 传统 OVD 的做法） 。区域 embeddings $R={r_i}^{N_r}&lt;em&gt;{i=1}$ 是通过 RoI 对齐和后续的特征提取中获得的，这里的 $N_r$ 是图片中区域框的数量。文字 embedding 由 $C={c&lt;/em&gt;{bg}}\cup{c_i}^{N_c}&lt;em&gt;{i=1}$ 组合，此处的 $c_i$ 是将分类名通过 prompts 工程，再喂到预训练好的 text encoder 中获得，而 $N_c$ 是分类数量。$c&lt;/em&gt;{bg}$ 被初始化为一个可学习的 embedding。通过图像区域和文本的学习，区域 $r_i$ 被分类为类别$c_j$ 的概率为
$$
p_{i,j} = \frac{\exp(r_i \cdot c_j)}{\exp(r_i \cdot c_{bg}) + \sum^{N_c}_{k=1}\exp(r_i\cdot c_k)}
$$&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;这个长的好像 Softmax，不知道有什么关联&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比较区域与文本嵌入之间的相似性使得检测器能够在无穷的标签空间中识别对象。&lt;/p&gt;
&lt;h2&gt;MarvelOVD&lt;/h2&gt;
&lt;p&gt;为了便于学习与开集类别相关的语义，现有的方法通常是使用预训练的 VLMs 来发现潜在的新对象，并生成 pseudo-labels 以用于后续训练。&lt;/p&gt;
&lt;p&gt;典型的训练过程涉及使用 base annotations 训练一个 proposal generator 用来区分可能包含新物体的局部区域，随后使用 VLM 的推理结果在这些裁剪后的区域中生成 pseudo-labels。然而由于 VLM 是在一整张大图片上进行的预训，在局部区域使用时不免产生噪声 pseudo-labels，从而导致学习新类别的过程中断。为了增强学习新物体概念的能力，作者提出了 MarvelOVD，它动态地将 detector 的能力整合到 pseudo-label 的生成过程中，同时又能优化后续的学习。下图对该框架进行了解释。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&quot;./image-20250410211628482.png&quot; alt=&quot;FRAMEWORK&quot; /&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;上图为方法的框架。该框架通过在训练期间动态的与 detector 配合优化了后续的学习过程，提升了 pseudo-labels 的质量。&amp;lt;br /&amp;gt;作者首先使用 CLIP 和 proposal  generator将候选框指定到图像上，然后通过 CLIP 的打分选择噪声 pseudo-labels调整 detector &lt;strong&gt;图(a),图(b)&lt;/strong&gt;。&amp;lt;br /&amp;gt;在调整之后，detector 拥有了识别新概念物体的能力。基于此，作者动态地评估了每个候选框的“新颖性”，并将其与 CLIP 的预测相结合，以选择精确的 pseudo-labels。作者采用了 stratified label assignment 来生成训练框，此时新训练框的损失权重是基于 detector 的预测独立计算的。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;候选 Pseudo-Label 分配&lt;/h3&gt;
&lt;p&gt;MarvelOVD 在每次迭代训练中，能够在 detector 和预训练好的 VLM 的知道下，动态地生成更好的 pseudo-labels。由于在训练时使用 VLMs 预测裁剪后的区域需要大量时间开销，这里在训练之前交替地为每个图像分配 pseudo-labels，然后在从中选择精确的标签训练检测器。&lt;/p&gt;
&lt;p&gt;作者首先使用 basa annotation 训练一个无类别的 proposal generator，用来给图像生成区域框。接下来根据区域对图像进行裁剪，并将对应区域喂给 CLIP 以获得对应的 regional-visual-embeddings。同时利用 CLIP text-encoder 获得每个新类别的 embedding。在这之后将通过点积计算相似度矩阵(similarity matrix)用来表述图像 embedding 和文字 embedding 之间的相似性。最后，应用 softmax 获得每个区域中新类型的分布。基于此，传统方法中在正式处理之后处理这些框，并选择高置信度的 pseudo-labels 来训练检测器。问题在于 domain gap 很容易让 CLIP 在噪声区域产生高置信度的预测，这极大的限制了已有方法的性能。作为对比，作者记录了 CLIP 的预测，并使用较低的阀值将候选框分配给图像，并在  detector 的指导下从候选框中选择精确的 pseudo-labels。更多细节下面讲&lt;/p&gt;
&lt;h3&gt;在线 Pseudo-label 挖掘&lt;/h3&gt;
&lt;p&gt;候选 pseudo-labels 可分为两类&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ground-truth boxes: 紧密靠近实际对象的 box&lt;/li&gt;
&lt;li&gt;noisy boxes: 不应该被指定为对象的 box&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;任务的主要目标是消除 noisy，同时保留 ground-truth boxes 作为可信的 pseudo-labels 作为训练。Detector 和 CLIP 最关键的区别在他们对局部区域上的上下文和“背景”概念的推断上。由 Detector 引入的 ROI Align 机制在框中提取上下信息的表现非常出色，这种能力是单纯根据坐标裁剪图像时无法比拟的。此外，检测器引入了一个特定的任务类型，称为“背景”，它是 CLIP 在推断局部区域时未能意识到的。不能识别”背景“以及上下文的缺乏是 CLIP 模型生成生成 noisy boxes 的根本原因。不过虽然 CLIP 在处理噪声上存在困难，但是它对 ground-truth boxes 的处理非常准确。利用这一见解，作者提出：&lt;strong&gt;利用 Detector 对候选框进行推理，判断是否包含新物体。随后结合 CLIP 分类的结果，选择高质量的 pseudo-labels&lt;/strong&gt;&lt;/p&gt;
&lt;h4&gt;Burn-in&lt;/h4&gt;
&lt;p&gt;为了推理候选框的新颖性，detector 首先需要学习什么是“新颖”。为了达成这个目标，作者采用了 top-1 CLIP score[^7] 和一个固定的阈值 0.8 来初始化选择 pseudo-labels 来让 detector 在 $\omega$ 步内完成 detector 的 burn-in。在 burn-in 阶段之后，模型将初步获得区分基目标，新目标和背景的能力。&lt;/p&gt;
&lt;h4&gt;Online Object Mining&lt;/h4&gt;
&lt;p&gt;Online Object Mining 在 burn-in 阶段之后正式开始。作者从半监督学习中借鉴了思想，通过生成弱-强图像对，增强 pseudo-labels 的学习能力。&lt;/p&gt;
&lt;p&gt;首先在弱增强特征上使用 detector 预测候选框，为每个候选框计算新颖性得分
$$
z_i = \frac{\sum_{k\in C^N} \exp(r_i\cdot c_k)}{\sum_{j\in C^B\cup C^N\cup{C_{bg}}}\exp(r_i\cdot c_j)}
$$
这里的 $r$ 是由 detector 给出的图像 embedding，$c$ 是文字 embedding。 $C^B$ 和 $C^N$ 是基类和新类的集合。新颖评分 $z_i$ 相对的评估了候选框对于基类和背景的新颖性。然而，它的值在不同收敛程度下变化非常剧烈。为了解决这个问题，作者进一步使用了对新颖性得分使用 max-norm 来获取稳定的结果
$$
s_i^{det}=\frac{z_i}{\max{z_1, z_2,\cdots,z_{N_r}}}
$$
这里的 $N_r$ 表示候选的数量。得益于探测的上下文推理能力和背景的感知，detector所计算的新颖度估计 $s^{det}$ 能够更精准的区分 ground-truth/noise 候选框。结合 CLIP 模型生成的准确分类预测，最终每个候选框的置信度如下：
$$
s_i = \lambda s_i^{\text{CLIP}}+(1-\lambda)s_i^\text{det}
$$
在上述的等试中， $S_i^\text{CLIP}$ 为 top-1 CLIP score, $\lambda \in [0,1]$ 是一个标量，控制两个模型的关系（平衡）。作者利用固定的阈值 $δ$ 选择高质量的 pseudo-labels。训练是基于弱增强和强增强图像进行的。&lt;/p&gt;
&lt;p&gt;检测器的引入显著降低了噪声候选者的置信度，极大提高了所选伪标签的准确性，即使在初始训练阶段也是如此。此外，随着模型在训练中逐渐收敛，新颖性估计$s^\text{det}$将变得更加准确，从而产生更高质量的伪标签，最终提升模型在新类别上的检测性能。&lt;/p&gt;
&lt;h3&gt;训练&lt;/h3&gt;
&lt;p&gt;在该部分作者表述了对 detector 传统训练方式的改进。在这部分中提出的所有方法在 burn-in 阶段和 online-object-mining 阶段都有使用。&lt;/p&gt;
&lt;h4&gt;Stratified Label Assignment&lt;/h4&gt;
&lt;p&gt;学习新的目标不应当影响模型在识别基目标的性能。然而，一个比较容易忽略的现象是当训练新类的 pseudo-labels 时，base categories 的 mAP(means average precise) 将会下降。原因是新的 pseudo-labels 可能会覆盖 base annotation，在基于 IoU 标签分配[^8]上造成 base-novel-conflicts。stratified label assignment 正是为了解决这个问题：它首先通过 IoU-matching 为 proposals 分配 base annotation。被标记为背景的box，稍后将再与 pseudo-labels 进行二次匹配。实验表明，分层标签分配有助于在不妨碍基础类别估计性能的情况下，实现对新颖物体高准确率的检测。&lt;/p&gt;
&lt;h4&gt;Adaptive Proposal Reweighting&lt;/h4&gt;
&lt;p&gt;由于 pseudo-label 的定位质量有限，box的中心可能离 ground-truth 重心很远。结果，训练框可能与错误定位的 pseudo-label 匹配，它与 ground-truth 对象的重叠极度不平衡。然而传统的 detectors 训练方法平等的在这些不平衡的 box 上计算 loss，这阻碍了学习过程。为了解决这个问题，作者提出了 adaptive proposal reweighting 来为每个匹配 pseudo-label 的 training box 独立的分配 loss 权重。&lt;/p&gt;
&lt;p&gt;训练 detector 的带有 adaptive proposal reweighting 的 loss 函数如下
$$
\mathcal{L}=
\frac{1}{N}
(\sum^{n^{base}}&lt;em&gt;{i=1} l (b_i^{base}, \cal G^{base}) + \gamma\sum^{n^{novel}}&lt;/em&gt;{i=1}w_i\cdot l(b_i^{novel}, \cal G^{novel}))
$$
这里的 $N = n^{base} + n^{novel}$($n^{base}$ 包含背景框) 是训练框的总数量， $\gamma$ 是对新概念学习的总权重， $w_i$ 表示每个新训练框独立的权重。结合每个候选框的置信度得分公式，每个独立的权重 $w_i$ 为
$$
w_i = \lambda&apos; s_i + (1-\lambda&apos;)r_i
$$
在上面的公式中， $s_i$ 表示对应 pseudo-label 的置信度， $r_i$ 为每个训练框的可靠性。$r_i$ 的计算在训练过程中十分关键，作者通过实践了解在弱增强图像上预测的背景的分数与物体的分数保持负相关，估定义 $r_i = 1-b_i$，这里的 $b_i$ 是通过根据公式 $p_{i,j} = \frac{\exp(r_i \cdot c_j)}{\exp(r_i \cdot c_{bg}) + \sum^{N_c}_{k=1}\exp(r_i\cdot c_k)}$ （本文公式第一个公式）预测的背景得分。通过自适应重加权，与真实新颖物体重叠度较高的训练框将获得更大的权重。这将消除学习过程中对新概念的偏差，并进一步提高性能。&lt;/p&gt;
&lt;p&gt;[^1]: OVD 是一种目标检测技术。不同于传统的目标检测，OVD检测的对象不一定会出现在训练集中，而是可能在推理时给出。推理可以是 zero-shot。它从 CLIP 基础上发展而来。
[^2]: &lt;a href=&quot;https://zhuanlan.zhihu.com/p/269454065&quot;&gt;机器学习：在线学习和离线学习的区别&lt;/a&gt;：在线学习指一次输入一条数据而不是一个 batch，训练完后直接更新权重，一个一个按顺序处理数据。优点为&lt;strong&gt;不需要一开始就提供完整的训练数据集，随着更多实时数据进入模型，模型会在操作中不断被更新。强调学习具有实时性，避免离线学习需要重新生成模型的问题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;[^3]: 新概念是指&lt;strong&gt;训练阶段没有标注数据&lt;/strong&gt;的类别，已知指新类别的&lt;strong&gt;名称是预先提供&lt;/strong&gt;。例如训练数据为 &lt;code&gt;[牛, 马]&lt;/code&gt;，测试时检测 &lt;code&gt;[火车, 人]&lt;/code&gt;。这里的 &lt;code&gt;[火车, 人]&lt;/code&gt; 就是已知新概念，可用 VLM 生成。
[^4]:  &lt;a href=&quot;https://ac.nowcoder.com/discuss/1021946&quot;&gt;Exploiting Unlabeled Data with Vision and Language Models for Object Detection&lt;/a&gt; ↩其中 生成 pseudo-labels 的流水线：&lt;img src=&quot;./image-20250331201953724.png&quot; alt=&quot;生成 pseudo-labels 的流水线&quot; /&gt;
[^5]: OVD 常见架构&lt;img src=&quot;./image-20250331212118889.png&quot; alt=&quot;OVD 常见架构&quot; /&gt;
[^6]: 加权同样在 &lt;em&gt;Exploiting Unlabeled Data with Vision and Language Models for Object Detection&lt;/em&gt; 中提出。
[^7]: top-1 CLIP score 是指使用 CLIP 的 image-encoder 和 text-encoder 所预测的分布的最高 score。 &lt;s&gt;不过这是什么？&lt;/s&gt;
[^8]: 对比学习 RPNs 的 proposals 模型时，为每个 anchor 分配正负标签。当 IoU 大于某个值时分配正标签，小于某个值时负标签。IoU 指预测框和真实框之间重叠的差距。&lt;/p&gt;
</content:encoded><category>OVD</category><category>目标检测</category><category>AI</category><author>Mslxl</author></item><item><title>Faster R-CNN</title><link>https://blog.mslxl.com/posts/thesis/fasterrcnn/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/thesis/fasterrcnn/</guid><description>Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Network</description><pubDate>Thu, 03 Apr 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;论文原标题: &lt;em&gt;Faster R-CNN: Towards Real-Time Object Detection with Region Proposal Network&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;本人对此方向什么都不会，边读边学，读个大概。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;该论文从 Fast R-CNN[^1]的基础上进一步加速得来。论文提出使用 CNN 实现 Region proposals 的过程，并起名为 Region Proposal Networks(RPNs)。同时它可以与 Fast R-CNN 共享卷积层，避免了对特征的重复提取。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250405161614641.png&quot; alt=&quot;Faster R-CNN&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;RPNs&lt;/h2&gt;
&lt;p&gt;RPNs 将图片作为输出，输出矩形选择框(即 Region proposals)。为了产生 region proposals，作者在卷积层的输出上&lt;strong&gt;滑动&lt;/strong&gt;一个小的网络，它的输入是在特征图上的 $n\times n$ 的空间窗口。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250405162401498.png&quot; alt=&quot;Slide Windows&quot; /&gt;&lt;/p&gt;
&lt;p&gt;该网络将输入映射到一个低维的特征上，并传给两个并行的全连接层，一个用于框回归(box-regression)，另一个用于分类(box-classification)。&lt;/p&gt;
&lt;p&gt;RPN产生的位置不一定精确，所以需要 box-regression 的分支计算包含结果的概率。&lt;/p&gt;
&lt;h2&gt;Anchor&lt;/h2&gt;
&lt;p&gt;即参考框。从区域中产生的候选框不是凭空产生的，所以预先定义了$k$ 个参考框，每个框负责预测与其形状相似候选框。anchor 的最后输出的是每个参考框的偏移量。在每一个位置，作者采用了 3 种尺度（$128^2$, $256^2$, $512^2$），每个尺度3种比例（$1:1$, $1:2$, $2:1$），共9种大小的 Anchor。这 9 个 Anchor 一般足以覆盖常见的预测目标[^2]。&lt;/p&gt;
&lt;p&gt;Anchor 的大小与目标候选框的大小越匹配，最终结果就越好[^3]。像这样使用多个 Anchor 进行滑动的方法又称为多尺度(multi-scale)、平移不变(translation-invariant) 的 Anchor。&lt;/p&gt;
&lt;p&gt;[^1]: 接受一整张图片，通过卷积操作得到一整张图片的特征图。然后通过 Roi 投影获得候选区域的特征图，再通过 Roi 池化层，将特征图转化为特征大小，再利用候选区域特征识别类别和精确坐标。&lt;img src=&quot;./image-20250405160622132.png&quot; alt=&quot;Fast R-CNN&quot; /&gt; Fast R-CNN 实现了&lt;strong&gt;几乎&lt;/strong&gt;实时（忽略了 Region proposals)。实际上 Region proposals 采用 Selective Search 或 EdgeBoxes 操作，该操作相当耗时&lt;/p&gt;
&lt;p&gt;[^2]: 在 COCO 数据集上，由于预测目标较小，作者又额外引入了 $64^2$ 尺度的 Anchor&lt;/p&gt;
&lt;p&gt;[^3]: 值得一提的是，YOLO 系列并不是事先确认的候选框，而是在模型训练前事先统计好所有标注框的大小。然后通过 cluster 计算出最合适的 anchor 大小&lt;/p&gt;
&lt;h2&gt;RPN Loss 函数&lt;/h2&gt;
&lt;p&gt;损失函数一般是用来计算训练过程中目标值和预测值的偏差。Anchor 网络输出的值即预测值。目标值的定义如下：&lt;/p&gt;
&lt;p&gt;所有的 Anchor 与标注框都会有一定的重叠，这个重叠用 Intersection-over-Union(IoU) 表示。&lt;/p&gt;
&lt;p&gt;在训练 RPNs 时，作者对每个 anchor 分配正负标签。对以下两种情况分配正标签（positive label）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;与标注框的 IoU 最大的 anchor，此举保证至少有一个正标签&lt;/li&gt;
&lt;li&gt;与标注框的 IoU 大于 $0.7$ 的 IoU 的 anchor&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于以上分配策略，一个标注框可能分配正标签给多个 Anchor。&lt;/p&gt;
&lt;p&gt;若一个 anchor 对于所有的候选框的 IoU 都低于 $0.3$，分配负标签。&lt;/p&gt;
&lt;p&gt;有了以上定义，作者确认了 RPN 网络的损失函数如下&lt;/p&gt;
&lt;p&gt;$$
L({p_i},{t_i})=\frac{1}{N_{cls}}\sum_i L_{cls}(p_i, p_i^*) \
+\lambda\frac{1}{N{reg}}\sum_i p_i^&lt;em&gt;L_{reg}(t_i,t_i^&lt;/em&gt;)
$$&lt;/p&gt;
&lt;p&gt;该损失函数由两部分构成：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分类损失&lt;/li&gt;
&lt;li&gt;回归损失&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;每次传入的是一个 mini-batch，这里的 $i$ 就是每个 mini-batch 的索引，$p_i$ 表示第 $i$ 个 anchor 是一个候选目标的概率值，$p_i^*$ 表示第 $i$ 个 anchor 上是否为正标签，若是正标签，则为 $1$;若为负标签则为 $0$。&lt;/p&gt;
&lt;p&gt;同理，对于&lt;strong&gt;正标签的&lt;/strong&gt;回归损失同样计算损失函数，如果是负标签则直接为 0。计算结果后通过 $\frac{1}{N_{reg}}$ 进行归一化，通过 $\lambda$ 平衡权重。&lt;/p&gt;
&lt;h2&gt;训练 RPNs&lt;/h2&gt;
&lt;p&gt;使用随机梯度下降法 (SGD)、图片中心采样。对于每个 mini-batch，先挑选单张图片。由于单个图片中包含多个正负样本的 anchor，所以只需要用一张图片就能（随机）采集到 256 个样本用于训练。由于在图片中，大多数是负样本，所以在采样时要保证正负样本的比例为 $1:1$。&lt;/p&gt;
&lt;p&gt;在训练时，有 3 种方式:交替训练、近似联合训练和非近似联合训练&lt;/p&gt;
&lt;h3&gt;交替训练 Alternating training&lt;/h3&gt;
&lt;p&gt;在此方案中，作者首先训练了一个 RPN，然后使用它产生的 proposals 来训练 Fast R-CNN 网络。Fast R-CNN 产生的权重又能拿来训练 RPN。重复迭代此过程完成训练&lt;/p&gt;
&lt;h4&gt;4 步交替训练 4-Step Alternating training&lt;/h4&gt;
&lt;p&gt;此文章采用该方式完成训练。在该中方式中分为四步（粉色代表未固定的网络）:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;首先训练一个 RPN 网络。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flowchart LR

Input@{shape: lin-cyl}--&amp;gt;CNN1[&quot;Deep ConvNet&quot;]--&amp;gt;CNNRPN[&quot;ConvNet(Proposal)&quot;]--&amp;gt;Pro@{shape: dbl-circ, label: &apos;Proposals&apos;}
style CNN1 fill:#f9f
style CNNRPN fill:#f9f
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;由于这个 RPN 能产生候选区域，在接下来使用 RPN 训练 Fast R-CNN 网络。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flowchart LR

Input@{shape: lin-cyl}--&amp;gt;CNN1[&quot;Deep ConvNet&quot;]--&amp;gt;|Features Map|CNNRPN[&quot;ConvNet(Proposal)&quot;]
CNNRPN--&amp;gt;|&quot;Proposals&quot;|CNNCLS
Input--&amp;gt;CNN2[&quot;Deep ConvNet v2&quot;]--&amp;gt;|Features Map|CNNCLS[&quot;ConvNet(Box Classification)&quot;]--&amp;gt;Result@{shape: dbl-circ}
CNNRPN--&amp;gt;|Proposals|CNNREG[&quot;ConvNet(Box Regression)&quot;]--&amp;gt;Result
CNN2--&amp;gt;|Features Map|CNNREG
style CNN2 fill:#f9f
style CNNCLS fill:#f9f
style CNNREG fill:#f9f
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;随后使用 Fast R-CNN 网络来初始化 RPN 训练，在此过程中固定了共享的卷积层，只微调 RPN&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flowchart LR

Input@{shape: lin-cyl}--&amp;gt;CNN1[&quot;Deep ConvNet v2&quot;]--&amp;gt;CNNRPN[&quot;ConvNet(Proposal)&quot;]--&amp;gt;Pro@{shape: dbl-circ, label: &apos;Proposals&apos;}
style CNNRPN fill:#f9f
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;冻结共享的卷积层，只微调 Fast R-CNN&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flowchart LR

Input@{shape: lin-cyl}--&amp;gt;CNN2[&quot;Deep ConvNet&quot;]--&amp;gt;|Features Map|CNNRPN[&quot;ConvNet(Proposal)&quot;]
CNNRPN--&amp;gt;|&quot;Proposals&quot;|CNNCLS
CNN2[&quot;Deep ConvNet v2&quot;]--&amp;gt;|Features Map|CNNCLS[&quot;ConvNet(Box Classification)&quot;]--&amp;gt;Result@{shape: dbl-circ}
CNNRPN--&amp;gt;|Proposals|CNNREG[&quot;ConvNet(Box Regression)&quot;]--&amp;gt;Result
CNN2--&amp;gt;|Features Map|CNNREG
style CNNCLS fill:#f9f
style CNNREG fill:#f9f
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;近似联合训练 Approximate joint training&lt;/h3&gt;
&lt;p&gt;在训练的一开始就是训练整张网络，在训练时会有两个损失，直接反向传播回去。&lt;/p&gt;
&lt;p&gt;作者后来发现近似联合训练能产生相似的结果，同时训练时间减少了 $25-50%$。&lt;/p&gt;
&lt;p&gt;但是这个方式忽略了一个问题：候选框的偏导数。即RPN得到了坐标后传给分类网络使用，获得损失后无法传回。&lt;img src=&quot;./image-20250405190232345.png&quot; alt=&quot;无法传回损失&quot; /&gt;[^4]&lt;/p&gt;
&lt;h3&gt;非近似联合训练 Non-approximate joint training&lt;/h3&gt;
&lt;p&gt;解决了方法2中无法求偏导的问题。添加了 ROI-wrap。&lt;/p&gt;
&lt;h2&gt;VOC 上实验&lt;/h2&gt;
&lt;p&gt;该论文最重要的是使用 RPNs 替换了 Region Proposal。估此处首先判断 RPNs 和传统的 Selective Search/EdgeBoxes 的对比&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250405191020904.png&quot; alt=&quot;RPN vs SS vs EB&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，虽然 proposals 的数量变少了，但是最终精度却边高了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250405192011924.png&quot; alt=&quot;EXP&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在删除 REG 后，精度也有所下降。原因是 anchor 只是大概位置，它并不是很准确。以此证明回归分支也很重要。&lt;/p&gt;
</content:encoded><category>目标检测</category><category>AI</category><author>Mslxl</author></item><item><title>开放词汇目标检测（OVD）</title><link>https://blog.mslxl.com/posts/thesis/ovd/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/thesis/ovd/</guid><pubDate>Fri, 28 Mar 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;在目标检测的发展历程中，存在以下几种方案的目标检测：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Two-Stage: 两阶段的目标检测，向模型喂一张图。首先通过 Region Proposal 生成多个候选区域，接下来再进行筛选、检测获取目标。&lt;/li&gt;
&lt;li&gt;One-Stage：一阶段的目标检测。端到端的形式，将图片输入到 backbone 中，直接输出检测框。最出色的即 YoLo 系列&lt;/li&gt;
&lt;li&gt;Anchor-Based&lt;/li&gt;
&lt;li&gt;Anchor-Free&lt;/li&gt;
&lt;li&gt;Transformer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;不同于上面的方案，OVD 的目标是利用文本的语义信息和图片的语义信息结合起来，它关注图像的偏移，尤其是统计偏移。&lt;/p&gt;
&lt;p&gt;图像的偏移有两种形式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;统计偏移（纵坐标）&lt;/li&gt;
&lt;li&gt;语义偏移（横坐标）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250408144115045.png&quot; alt=&quot;图像偏移&quot; /&gt;&lt;/p&gt;
&lt;p&gt;OVD 可以识别超过预定义的类别，借助弱监督信号（如图文对或 VLMs）。现有的大多数 OVD 方法都是基于 VLM（如 CLIP）。&lt;/p&gt;
&lt;p&gt;不同于传统的分类任务，此处的对比学习将分配任务转换成了匹配任务。&lt;/p&gt;
&lt;p&gt;传统的分配框架往往是先进行特征提取，随后加入 FC 进行分配，分类的结果是一个概率向量。&lt;/p&gt;
&lt;p&gt;匹配任务采用对比学习中不仅提取了图片的特征，还将文本的特征同样提取了出来。随后将图像特征与文本特征进行匹配，概率最高的即为结果。&lt;/p&gt;
&lt;p&gt;对比学习一个经典的例子即为 CLIP。它将 Text Embedding 与 Image Embedding 进行匹配，将符合结果的标记为正样本，其他为负样本。将两个 Encoder 生成的数据在表达相同结果时在同空间中最近。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250408145006867.png&quot; alt=&quot;CLIP 训练阶段&quot; /&gt;&lt;/p&gt;
&lt;p&gt;CLIP 的推理相当简单，而且是 one-shot[^1]的&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250408145304981.png&quot; alt=&quot;推理&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;框架&lt;/h2&gt;
&lt;p&gt;OVD 很类似 Two-Stage，它同样需要 RPN 进行 Region Proposal。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250408150137086.png&quot; alt=&quot;训练阶段&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如上图，在训练阶段给出的数据包含图片、检测框和文本。通过图像编码器和检测头后对 Region 进行检测，然后再从文本中得到相应的类别的 embedding。再通过对比训练，计算分类 loss 和定位 loss。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250408150610157.png&quot; alt=&quot;推理阶段&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;OVD 发展方向&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;区域感知训练(region-aware training): 利用图文对，例如 group VIT&lt;/li&gt;
&lt;li&gt;伪标签方法(pseudo-labeling)：利用图文对，在模型未完成训练时利用模型进行推理，推理的结果再重复训练&lt;/li&gt;
&lt;li&gt;知识蒸馏(knowledge distillation): 大量使用 VLMs-IE&lt;/li&gt;
&lt;li&gt;迁移学习(transfer learning)：大量利用 VLMs-IE&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;区域感知训练&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250408152146803.png&quot; alt=&quot;GroupViT&quot; /&gt;&lt;/p&gt;
&lt;p&gt;此方法并没有用到 VLM，而是利用文本对齐的方法。上图是个语义分割的例子：图像经过一系列的语义提取变为 embedding $z^I$，文本同理获得 $z_T$。最终进行对比&lt;/p&gt;
&lt;p&gt;区域感知其实就是将 CLIP 的思想运用到下游任务中，利用对比学习实现图像文本匹配。但是 CLIP 是整张图片与文本对齐，而区域感知训练则是图片中1个局部区域与N 个单词对齐。&lt;/p&gt;
&lt;h3&gt;伪标签方法&lt;/h3&gt;
&lt;p&gt;该方法在 &lt;em&gt;Open Vocabulary Object Detection with Pseudo Bounding-Box Labels&lt;/em&gt; 中提出，该文职提出能否利用现有的大规模的目标物体自动生成边界标签，利用这些生成的边界框提升 OVD 性能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250408152659477.png&quot; alt=&quot;伪标签与人工方法对比&quot; /&gt;&lt;/p&gt;
&lt;p&gt;上图中左侧为传统的学习方法，其训练成本很高。而右侧为伪标签方法。伪标签方法利用自己生成的标签训练自己。&lt;/p&gt;
&lt;h4&gt;伪标签的生成&lt;/h4&gt;
&lt;p&gt;该工作使用 VLM 生成伪标签。首先通过输入图文对分别提取特征，获得特征向量，然后利用图文交互的 cross-attention 机制获得多模态特征，计算图像区域和文本单词的注意力权重，再利用 Grad-CAM 对注意力权重进行可视化，得到目标的 Activation Map 区域，该局域即为 RPN 网络的目标 ROI。该ROI 构成该目标名称的伪边界框标签。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./image-20250408154837372.png&quot; alt=&quot;伪标签生成&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;检测模型训练&lt;/h3&gt;
&lt;p&gt;通过伪标签数据即可训练 OVD 的检测。将图像数据根据伪标签获得 ROI，然后经过编码器得到特征向量，文本直接经过文本编码器得到向量。之后经过计算跨模态 embedding 的相似度，根据伪标签计算交叉熵。&lt;/p&gt;
&lt;h2&gt;其他详细资料&lt;/h2&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/610639148&quot;&gt;面向开放词汇的目标检测Open-Vocabulary Object Detection（OVD）的介绍&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/595169030&quot;&gt;Open-Vocabulary Object Detection 工作调研&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;[^1]: 指模型的泛化能力。Zero-Shot 指给出一张未出现在训练集中的数据，模型仍能给出结果。除此之外还有 One-Shot 和 Few-Shot。 One-Shot 指只需要一张图片进行 fine-tune（人脸识别就是一个常见场景），而 Few-Shot 只每个类别只有少量样本&lt;/p&gt;
</content:encoded><category>OVD</category><category>目标检测</category><category>AI</category><author>Mslxl</author></item><item><title>周报 0x02: 旧日幻梦</title><link>https://blog.mslxl.com/posts/weekly/03feb25/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/weekly/03feb25/</guid><description>「我们的家族没落了」</description><pubDate>Thu, 20 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;我在写什么？&lt;/h2&gt;
&lt;h3&gt;Maljuna Revo&lt;/h3&gt;
&lt;p&gt;Maljuna Revo 实际上应该是表示过去的白日梦（世界语），最初这个软件只是用来纪念我碌碌无为的算法竞赛生涯，而后来变成了毕业设计。&lt;/p&gt;
&lt;p&gt;Revo 是一个由 Tauri 开发的单文件代码编辑器，主体部分采用 React 开发。&lt;/p&gt;
&lt;p&gt;说实话这个项目从1月就已经开始写了，经过了忙忙碌碌的1月，过了春节后不知从哪里生出一股厌烦，一直停摆到现在。不过本地编辑器已经完成大部分功能了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./prog.png&quot; alt=&quot;Program Screenshot&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;其实工作量还是页面仔&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;在架构设计上，Revo 模仿了 VSCode。将代码分为了四部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;base: 通用的公共方法和组件&lt;/li&gt;
&lt;li&gt;platform: 依赖 Rust 接口，可被依赖注入的服务&lt;/li&gt;
&lt;li&gt;editor: 编辑器&lt;/li&gt;
&lt;li&gt;workbench: 各类拓展功能视图框架&lt;/li&gt;
&lt;li&gt;code: 应用程序入口，组织上述模块&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;flowchart LR
  subgraph Page
    direction TB
    code --&amp;gt; workbench --&amp;gt; platform --&amp;gt; base
    code --&amp;gt; base
    code --&amp;gt; editor --&amp;gt; platform
  end
  subgraph Native
    direction LR
    specta --&amp;gt; db
    specta --&amp;gt; lsp
    specta --&amp;gt; runner
    specta --&amp;gt; term
    specta --&amp;gt; problems
    specta --&amp;gt; config
    specta --&amp;gt; win
    specta --&amp;gt; log
  end
  platform o--&quot;command/channel&quot;--o specta
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;更多有关实现的内容就不在这里提了，反正你们也不关心&lt;/p&gt;
&lt;p&gt;简单贴几张图吧&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./prefs.png&quot; alt=&quot;Preference&quot; /&gt;
&lt;img src=&quot;./runner.png&quot; alt=&quot;Runner&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;我在玩什么&lt;/h2&gt;
&lt;h3&gt;Darkest Dungeon&lt;/h3&gt;
&lt;p&gt;最近在玩这个 &lt;a href=&quot;https://neodb.social/game/6xaHyfmH9tRpNaURiYTLe8&quot;&gt;Darkest Dungeon&lt;/a&gt;。
刚开始玩的时候没有加 mod，真真正正做到了 4 个人下地牢，疯了 5 个。怪我自己抗压能力太弱。&lt;/p&gt;
&lt;p&gt;之前只在 Bilibili 上闻其名，机制流程复杂但是却挺有意思，难度对我而言可能稍微有点高。之后去打了几个
二次元 mod 来感受二次元的强度了。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;./game_kitsune_miko.png&quot; alt=&quot;狐妖巫女&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;./game_fuujin_kitsune.png&quot; alt=&quot;风佑巫女&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;绘师&amp;lt;span lang=&quot;jp&quot;&amp;gt;長門ちゃん&amp;lt;/span&amp;gt;画的这两小只真可爱啊&lt;/p&gt;
&lt;p&gt;&lt;s&gt;然而最终还是被老祖送走两个&lt;/s&gt;&lt;/p&gt;
</content:encoded><category>Weekly</category><category>Tauri</category><category>Competitive Programming</category><author>Mslxl</author></item><item><title>CPS 变换</title><link>https://blog.mslxl.com/posts/fun/cps-trans/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/fun/cps-trans/</guid><pubDate>Sat, 08 Feb 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;大多数语言都是通过编译器实现 CPS 变换。尤其是 FP 语言将 CPS 作为一种中间代码。&lt;/p&gt;
&lt;p&gt;CPS 变换的过程非常简单&lt;/p&gt;
&lt;p&gt;对于一个函数 $f: t1 \to t2$，它的 CPS 版本应该是 $f_cps: t1 \to (t2 \to a) \to a$，
其中 $f_cps\ x\ k \cong k\ (f\ x)$&lt;/p&gt;
&lt;p&gt;其变换过程如下:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对返回值是 $t$ 的函数，添加一个 $t \to a$ 类型的 Continuation 参数，并将返回值将变为 $a$&lt;/li&gt;
&lt;li&gt;在每个函数的 return 处调用 Continuation&lt;/li&gt;
&lt;li&gt;如果有函数的递归调用表达式 $e$，将$e$的结果绑定到新的变量 $rec_ans$ 上&lt;/li&gt;
&lt;li&gt;将原递归部分更改为 $e (rec_ans \to &amp;lt;body&amp;gt;)$，其中 $&amp;lt;body&amp;gt;$ 是原本函数的其他部分&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;以以下 Haskell 代码 map 为例：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; [b]
map f [] = []
map f (x:xs) = f x : map f xs
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先添加 Continuation，并更改类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; ([b] -&amp;gt; c) -&amp;gt; c
map f [] k = k []
map f (x:xs) k = k (f x : map f xs)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里递归部分为 &lt;code&gt;map f xs&lt;/code&gt;，提取这部分，并转化为 &lt;code&gt;map f xs (\ans -&amp;gt; &amp;lt;body&amp;gt;)&lt;/code&gt;，其中 &lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt; 为后续操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map :: (a -&amp;gt; b) -&amp;gt; [a] -&amp;gt; ([b] -&amp;gt; c) -&amp;gt; c
map f [] k = k []
map f (x:xs) k = map f xs (\rec -&amp;gt; k (f x: rec))
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;手动模 &lt;code&gt;map (*2) [1,2] id&lt;/code&gt; 一下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map (*2) [1,2] id
= map (*2) [2] (\rec -&amp;gt; id ((*2) 1 : rec))
= map (*2) [] (\rec&apos; -&amp;gt; (\rec -&amp;gt; id ((*2) 1 : rec)) ((*2) 2 : rec&apos;))
= (\rec&apos; -&amp;gt; (\rec -&amp;gt; id ((*2) 1 : rec)) ((*2) 2 : rec&apos;)) []
= (\rec -&amp;gt; id ((*2) 1 : rec)) ((*2) 2 : [])
= (\rec -&amp;gt; id ((*2) 1 : rec)) (4 : [])
= (\rec -&amp;gt; id ((*2) 1 : rec)) [4]
= id ((*2) 1 : [4])
= id (2 : [4])
= id [2, 4]
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>CPS</category><author>Mslxl</author></item><item><title>周报 0x01: ボクの理想の Python</title><link>https://blog.mslxl.com/posts/weekly/25jan25/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/weekly/25jan25/</guid><pubDate>Sat, 25 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;为了记录我的精神状态，我决定从今天开始写周报了。虽然说是周报，但不一定每周都写，有可能数个月才写一次。&lt;/p&gt;
&lt;p&gt;换句话说，等我精神不稳定的时候才会来写周报。&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;日语&lt;/h2&gt;
&lt;p&gt;再见了，多邻国。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./duolingo.jpg&quot; alt=&quot;Duolingo Strike&quot; /&gt;&lt;/p&gt;
&lt;p&gt;大概是3年前，我开始使用多邻国学习日语和世界语。后来渐渐的将世界语丢掉只学日语了，到现在世界语也只能算个 komencanto。
而日语却一直坚持了下来，到现在连续打卡已经有 627 天了。这1000余天我通过多邻国学到了什么？其实我觉得我什么也没有学到。
在老中的特色汉字 buff 下，我还勉强能看懂简单的句子，但却说不出、写不下简单的单词。在今天，我觉得是时候放下 Duolingo 转向其他正常的学习方式了。&lt;/p&gt;
&lt;p&gt;多邻国有什么问题？首先它其中的题目有一些问题。比如在其中的听力中，有时会同时出现
「&amp;lt;span lang=&quot;jp&quot;&amp;gt;中村さん&amp;lt;/span&amp;gt;」和 「&amp;lt;span lang=&quot;jp&quot;&amp;gt; なかむらさん&amp;lt;/span&amp;gt;」 两个选项，然而只有前者是被认为正确的。
再者，使用中文学习日语时不能完全对等的翻译。例如「&amp;lt;span lang=&quot;jp&quot;&amp;gt;この味噌汁は安いです&amp;lt;/span&amp;gt;」的中文表达是 「这个味增汤很便宜」。
然而中文中的“很”并不表示程度，它只是一种语气词(?)。然而当你尝试翻译回去的时候，也许 「&amp;lt;span lang=&quot;jp&quot;&amp;gt;とても&amp;lt;/span&amp;gt;」 就出现了，你就又错了一题。
同理，还有「はい，元気です」中文特色倒桩句「是，我好的很」。总之，在多邻国学习使用汉语学习其他语言可能并不是一个好选择。&lt;/p&gt;
&lt;p&gt;此外，多邻国最大的问题就是——它不讲语法。所有的问题到要用户自己去悟，而多邻国只会简单的在 Guide 中提一下要出现的句子，此后便是不断的重复。
这很像 SRS（间隔重复）的学习方式，但是它却希望用户通过重复建立起语感。我个人觉得建立语感最重要的是环境，即大量的不同的句子重复出现。
显然多邻国给出的句子太少了，每种表达只有寥寥几句。到最后用户可能什么也没学到。&lt;/p&gt;
&lt;p&gt;总而言之，如果要学习一种语言，多邻国并不是一个很好的选择。但要是作为一个能够复习的游戏来说，倒也勉强合格。它只能拿来复习，至于拿来学习——还是找本书更靠谱些。&lt;/p&gt;
&lt;p&gt;至于我抛开多邻国后去了哪？我将我的学习任务拆分成了单词和句子两部分。
单词现在依靠 Anki 搭配卡组 &lt;a href=&quot;https://github.com/5mdld/anki-jlpt-decks&quot;&gt;5mdld/anki-jlpt-decks&lt;/a&gt;，
而句子则通过《皆の日本語》这本知名教材来完成。&lt;/p&gt;
&lt;p&gt;目前 Anki 的效果如下&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;./card_stability.png&quot; alt=&quot;Low Stability&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;./card_difficulty.png&quot; alt=&quot;High Difficulty&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;看上去并不是很乐观的样子，不过就算是这样虽然负担很大，能背过的单词也比多邻国多多了。
至于最终的成效，等我通过了 N2 后会回来报告的。&lt;/p&gt;
&lt;h2&gt;ボクの理想の Python&lt;/h2&gt;
&lt;p&gt;回到大标题。&lt;/p&gt;
&lt;p&gt;其实当我写下标题的时候，其实首先联想到的就是《ボクの理想の異世界生活》中的某个知名场面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;./isekai.jpg&quot; alt=&quot;SQL Magic&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我为什么要起这个标题呢？因为我现在突然想做一个语言，用来表达我对 Python 的不满。&lt;/p&gt;
&lt;p&gt;Python 是个好语言，它简单易学，拥有丰富的生态，能轻松的完成大部分的自动化或者胶水工作。
但是我觉得相比其他语言仍存在一些不足。这些不足并不是指带语义的缩进，也不是指性能，可能只是一些微不足道，但是我又十分有用的功能。&lt;/p&gt;
&lt;p&gt;当前，下面的内容到现在只是理想中的样子，具体是什么样子还要等实现。
受限于个人对类型系统掌握的能力不足，很多内容更像是一种幻想，一种 TODO List。也许我会在 Python 淘汰之前实现的吧&lt;/p&gt;
&lt;p&gt;&lt;s&gt;现在已经新建工程 Sidewinder了，等写差不多放出来&lt;/s&gt;&lt;/p&gt;
&lt;h3&gt;如何实现&lt;/h3&gt;
&lt;p&gt;Python 现在这个样子已经不是说改就改了，不如像 Kotlin 依赖 JVM 一样，依赖 Python VM 来创建一个新语言。&lt;/p&gt;
&lt;p&gt;我们可以编译到 Python Bytecode 或者是 Pyhton。我们都可以做到很多的事情，同时不丢失 Python 的生态。&lt;/p&gt;
&lt;p&gt;至于性能——我不会。&lt;s&gt;都写 Python 了就别在意那点性能了&lt;/s&gt;&lt;/p&gt;
&lt;h3&gt;单脚本环境&lt;/h3&gt;
&lt;p&gt;现在 Python 的环境隔离依赖的是 Conda、Poetry 或 Venv 等方案，这些方案主要是针对项目提供的解决方法。
而对于单个文件的脚本来说，可能只是一个简单的任务，将依赖安装到全局会污染环境，而新建一个环境的话又会多出比脚本数量还多的文件。&lt;/p&gt;
&lt;p&gt;Ammonite 的 Scala Script 提供了这样的方案：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import $ivy.`com.lihaoyi::scalatags:0.7.0 compat`, scalatags.Text.all._

val rendered = div(&quot;Moo&quot;).render
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 &lt;code&gt;import $ivy&lt;/code&gt; 提供了一种从远程主机导入依赖的方式，那么我们是否也能模仿这种行为？例如加入语法&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import $pip.pandas.&quot;latest&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;可以将依赖放在 &lt;code&gt;$HOME/.pycache/&amp;lt;name&amp;gt;/&amp;lt;version&amp;gt;&lt;/code&gt;， 在启动前将对象的目录放在环境变量中。这并不是一个很难解决的问题。&lt;/p&gt;
&lt;h3&gt;Trait/Typeclass&lt;/h3&gt;
&lt;p&gt;是的，越来越多的语言开始加入这一套机制了。这可能也是对我最大的挑战。
比其继承，通过 trait/typeclass 可以更好的表示数据所能支持的操作。&lt;/p&gt;
&lt;p&gt;比如在 Haskell 中通过 typeclass，可以轻而易举的支持很多操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;newtype Parser a = Parser
  { runParser :: String -&amp;gt; Maybe (String, a)
  }

instance Functor Parser where
  fmap f p = Parser $ \input -&amp;gt; do
    (input&apos;, a) &amp;lt;- runParser p input
    Just (input&apos;, f a)

instance Applicative Parser where
  pure x = Parser $ \input -&amp;gt; Just (input, x)
  (Parser f1) &amp;lt;*&amp;gt; (Parser f2) = Parser $ \input -&amp;gt; do
    (input&apos;, f) &amp;lt;- f1 input
    (input&apos;&apos;, a) &amp;lt;- f2 input&apos;
    Just (input&apos;&apos;, f a)

instance Alternative Parser where
  empty = Parser $ const Nothing
  (Parser f1) &amp;lt;|&amp;gt; (Parser f2) = Parser $ \input -&amp;gt; f1 input &amp;lt;|&amp;gt; f2 input
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过为 Parser 类型实现了函子（Functor）、应用函子（Applicative）和替换函子（Alternative），我们可以组合Parser类型，
进而得到很多其他例如 &lt;code&gt;some&lt;/code&gt;, &lt;code&gt;any&lt;/code&gt;, &lt;code&gt;traverse&lt;/code&gt;, &lt;code&gt;&amp;lt;*&lt;/code&gt; 等操作。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;charP :: Char -&amp;gt; Parser Char
charP c = Parser f
  where
    f [] = Nothing
    f (y : ys)
      | y == c = Just (ys, c)
      | otherwise = Nothing

stringP :: String -&amp;gt; Parser String
stringP = traverse charP
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我觉得这是传统的继承方式无法比拟的。&lt;/p&gt;
&lt;p&gt;Note: Rust 的 nom 库也实现了类似的操作。&lt;/p&gt;
&lt;h3&gt;Tagged Union&lt;/h3&gt;
&lt;p&gt;好像也是个很大的挑战。具体可以见 &lt;a href=&quot;https://en.wikipedia.org/wiki/Tagged_union&quot;&gt;Wiki: Tagged union&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;2024 年，就连 Java 17 都已经支持了这种类型（称为 Sealing）。通过这种方式可以避免很多错误，我觉得大家应该都
品尝过 Rust 中的 &lt;code&gt;Option&lt;/code&gt; 类型了，它就是一种 Tagged Union。&lt;/p&gt;
&lt;p&gt;Python 作为动态类型语言，支持它是个很大的挑战。因为静态分析时类型信息很容易丢失——只需要不写 type hinting。&lt;/p&gt;
&lt;p&gt;然而如果新建一个静态类型的语言，那这个问题自然存在解决方案。&lt;s&gt;不过还是挺难的&lt;/s&gt;&lt;/p&gt;
&lt;h3&gt;更好的 Map, Reduce&lt;/h3&gt;
&lt;p&gt;现在 Python 中的 map-reduce 长这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;from functools import reduce

reduce(lambda a,b: a+b, map(int, input().split()))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的 reduce 竟然需要导包才能实现，听说 Guido van Rossum 称 map, reduce 并不很 Pythonic，
因此拒绝将这些功能添加进 Python。
并且更推荐使用 &lt;code&gt;[int (x) for x in input().split()]&lt;/code&gt; 这种方式。此外，匿名函数是依赖 lambda 表达式实现的，并不支持多行。我觉得这对表达能力是很强的限制。&lt;/p&gt;
&lt;p&gt;这里可能并不设计谁对谁错，只是个人理念不同。但是我还是更喜欢 Kotlin/Rust 这种链式调用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;readlint().split(&quot; &quot;)
  .map{ it.toInt() }
  .reduce { a, b -&amp;gt; a + b}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;亦或是 Elixir 的管道&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;IO.gets(&quot;&quot;)
  |&amp;gt; String.split()
  |&amp;gt; Enum.map(&amp;amp;String.to_integer/1)
  |&amp;gt; Enum.reduce(0, fn x, acc -&amp;gt; x + acc end)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;无论如何，我觉得后两者都比 Python 的括号嵌套清楚多了。&lt;/p&gt;
&lt;p&gt;我觉得这可以和前面的提到的 typeclass 结合，提供一个操作（类型 &lt;code&gt;Functor&lt;/code&gt; 中的 &lt;code&gt;fmap&lt;/code&gt;），即可支持相当多的操作。&lt;/p&gt;
&lt;h3&gt;惰性求值&lt;/h3&gt;
&lt;p&gt;可能是个很难，也没这么有用，也会对性能造成负担的地方。&lt;/p&gt;
&lt;p&gt;它最主要的功能是能够支持无限长的列表，从而实现一些特殊的函数。比如 Haskell 官网的上展示的素数函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;primes = filterPrime [2..] where
  filterPrime (p:xs) =
    p : filterPrime [x | x &amp;lt;- xs, x `mod` p /= 0]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不觉得这很 Cyberpunk 吗？&lt;/p&gt;
&lt;p&gt;这大概可以利用 Python 中的异步机制实现，但要对原代码做很多变换。
实在写不出来的话就要参照虎书考虑携带一个大 Chunk 了。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;我的幻想目前就是这样子。至于工期，我觉得要按年为单位了。毕竟现在开始逐渐没太有时间写 hobby project 了。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;不过怎么越看越有 Lisp 方言 Hy 的样子了&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;Thanks to:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://lemonhx.moe/pldmd&quot;&gt;编程语言设计踩坑实录&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</content:encoded><category>Weekly</category><category>Python</category><category>Compiler</category><category>多邻国</category><author>Mslxl</author></item><item><title>CPS 与 Rust Result</title><link>https://blog.mslxl.com/posts/fun/cps-rust/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/fun/cps-rust/</guid><pubDate>Tue, 21 Jan 2025 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;CPS(&lt;a href=&quot;https://en.wikipedia.org/wiki/Continuation-passing_style&quot;&gt;Continuation-passing style&lt;/a&gt;, 连续传递) 是一种编程风格。
CPS 中的 C 即 Continuation，它是一个作为参数的函数，表示计算后的下一个过程。它的主要作用就是接受函数的结果，
并控制下一步执行。&lt;/p&gt;
&lt;p&gt;我们用一段 Kotlin 代码来表示。这是一个 Direct Style 的代码 mul 函数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun mul(a: Int, b: Int): Int {
  return a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它的 CPS 大概是这样的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun mul&amp;lt;R&amp;gt;(a: Int, b: Int, continuation: (Int)-&amp;gt;R): R{
  return continuation(a+b)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果用它来实现阶乘的话将会是这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun fact(a: Int, k: (Int)-&amp;gt;Int): Int {
  return match(a){
    0 -&amp;gt; k(1)
    n -&amp;gt; fact(n-1) {
      mul(n, it, k)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它和经常见的 fact 函数有什么区别？&lt;s&gt;如果有人给我看这代码我可能会直接丢给 AI&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;我们可以在 continuation（有时写做 k） 中控制征程程序的流程。比如上面的函数中，如果我们想在 x 的阶乘大于 k 时直接返回，
否则执行 taskB，代码会是这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;fun task(){
  fact(x){
    return if(it &amp;gt; k)  it
    else taskB(it)
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在 continuation 中没有调用其他函数，而是直接返回了某个值，那么这个值将会被看作是结果直接返回到顶层。&lt;/p&gt;
&lt;p&gt;那么这东西有什么用呢？除了在 FP 语言中用于中间表示，或者是协程中的应用外，Rust 使用 CPS 来表示 Result 的 &lt;code&gt;?&lt;/code&gt; 运算符。&lt;/p&gt;
&lt;p&gt;比如代码&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
fun taskMayError(
  onSuccess: (()-&amp;gt;Unit)-&amp;gt;Unit,
  onError:(()-&amp;gt;Unit)-&amp;gt;Unit,
  k: ()-&amp;gt;Unit
): Unit {
  // 仅使用 if 表示成功/失败
  if(doSomeOtherTask()){
    return onSuccess(k)
  }else{
    onError{
      return errorCode
    }
  }
}

fun main(){
  val onSuccessDo = { k-&amp;gt;
    return k()
  }
  val onErrorDo = { k-&amp;gt;
    eprintln(&quot;error&quot;)
    return k()
  }

  fact(4){ factResult-&amp;gt;
    return taskMayError(onSuccessDo, onErrorDo){ // 控制流程
      return mul(2, 3) { mulResult -&amp;gt;
        return factResult + mulResult
      }
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;关注函数的实际调用代码，当任务失败时，函数会从 taskMayError 直接返回，而 &lt;code&gt;mul&lt;/code&gt; 及后续过程不会被执行。
这其实就是 Rust 中 &lt;code&gt;?&lt;/code&gt; 的原理。Rust 编译器将函数拆开重组，再进行 inline（此处感谢 C++ 大手推动 LLVM 相关功能），
即实现了 &lt;code&gt;?&lt;/code&gt; 运算符的功能。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;s&gt;我试着在 Python 里搞这一套结果栈溢出了&lt;/s&gt;&lt;/p&gt;
</content:encoded><category>Rust</category><category>CPS</category><author>Mslxl</author></item><item><title>从 Hexo 到 Astro</title><link>https://blog.mslxl.com/posts/others/hexo-migrate-astro/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/hexo-migrate-astro/</guid><description>从 Hexo 到 Astro 的迁移体验</description><pubDate>Wed, 04 Sep 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;import { Typst } from &apos;astro-typst/src/components&apos;&lt;/p&gt;
&lt;p&gt;该页面出于实验性质使用 Typst 书写，其显示效果、界面风格一致性与交互性可能不如预期。&lt;/p&gt;
&lt;p&gt;&amp;lt;div data-orientation=&quot;horizontal&quot; role=&quot;separator&quot; label=&quot;Or&quot; class=&quot;shrink-0 bg-primary relative h-px w-full my-4&quot;&amp;gt;
&amp;lt;span class=&quot;text-xs text-foreground bg-background absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex justify-center items-center h-[1px] py-1 px-2&quot;&amp;gt;
以下内容使用 Typst 生成并通过 SVG 嵌入
&amp;lt;/span&amp;gt;
&amp;lt;/div&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;Typst width=&quot;100%&quot; height=&quot;auto&quot; src=&quot;src/content/posts/others/hexo-migrate-astro/content.typ&quot; /&amp;gt;&lt;/p&gt;
</content:encoded><category>Hexo</category><category>Astro</category><category>Typst</category><author>Mslxl</author></item><item><title>ChectEngine（二）：常见用例——以官方图形游戏为例</title><link>https://blog.mslxl.com/posts/fun/ce-gtutor/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/fun/ce-gtutor/</guid><description>另一个自带的图形游戏，破解方式更自由</description><pubDate>Sun, 30 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;第一关&lt;/h2&gt;
&lt;h3&gt;剩余量&amp;amp;消耗量&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;image20240804075908574.jpeg&quot; alt=&quot;image20240804075908574&quot; /&gt;&lt;/p&gt;
&lt;p&gt;有时候，内存中的数据可能并不是存储的显示的值，而是使用的值。例如第一关中的弹药：&lt;/p&gt;
&lt;p&gt;如果直接搜索弹药的剩余量，什么也发现不了。实际上第一关中内存中记录的是弹药的使用量&lt;/p&gt;
&lt;h2&gt;第二关&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;image-20240814224016569.png&quot; alt=&quot;image-20240814224016569&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;秒杀 &amp;amp; 提高伤害&lt;/h3&gt;
&lt;p&gt;每当玩家射出一发子弹后，每个敌人各会打出一发子弹。很显然我们需要让自己的血量冻结，以获得射出更多子弹的机会。血量可以很容易地使用扫描器找到。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240814224502961.png&quot; alt=&quot;image-20240814224502961&quot; /&gt;&lt;/p&gt;
&lt;p&gt;同理，我们可以找到敌人的血量内存：使用内存扫描器扫描未知的初始值，并反复使用“减少的值”寻找值。由于每个子弹打到玩家身上会造成2点伤害，那么我们可以大胆猜测，玩家的每一个子弹也会对敌人造成 2 点伤害。&lt;s&gt;但是这里并不是&lt;/s&gt;。反复使用“未变化的值”找到内存地址，并使用 “Find out what writes to this address”找到修改该地址的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240814231824463.png&quot; alt=&quot;image-20240814231824463&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到这段代码是 $(RAX+60) \leftarrow (RAX+60) - EDX$。向上寻找代码，没有找到 $edx$ 寄存器的值的来源，估计是函数调用过来的。在此处打个断点，观察其值的来源。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240814232510862.png&quot; alt=&quot;image-20240814232510862&quot; /&gt;&lt;/p&gt;
&lt;p&gt;注意到当敌人打到玩家的时候，这段代码同样被执行到了，此时$RDX=2$，证明存在代码复用。因此不能简单的将 $(RAX+60)$的值修改为 0 ，否则会导致敌人秒杀玩家。&lt;/p&gt;
&lt;p&gt;通过扫描器找到敌人和玩家的血量，然后再通过工具对比内存&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240814233335792.png&quot; alt=&quot;image-20240814233335792&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240814233311735.png&quot; alt=&quot;image-20240814233311735&quot; /&gt;&lt;/p&gt;
&lt;p&gt;发现在血量偏移$0010$的位置有一个疑似 bool 的字段，玩家是 0 ，敌人是 1。通过自动汇编判断该内存，使得当该字段为 1 时将 $(RAX+60)$ 修改为 0 ，否则不做修改。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ENABLE]
// 该选项被启用时执行
alloc(newmem,2048,&quot;gtutorial-x86_64.exe&quot;+400E3)  //申请一块新内存
label(returnhere) // 注册 3 个 label（类似于汇编中的 label）
label(originalcode)
label(exit)

newmem:
cmp [rax+60+10],0
je exit
// 如果 [rax + 60 + 10] 等于 0， 跳转到 exit。否则继续向下执行 originalcode

originalcode:
mov [rax+60],0 // 将疑似血量的值置为 0

exit:
// 返回原位置
ret
add [rax],al
jmp returnhere

&quot;gtutorial-x86_64.exe&quot;+400E3: // 修改该内存区域（原 sub 指令地址）
jmp newmem // 跳转到 newmem 标签
nop
returnhere:

[DISABLE]
// 当该选项被禁用时，释放申请的内存，并将修改的指令回复。
dealloc(newmem)
&quot;gtutorial-x86_64.exe&quot;+400E3:
db 29 50 60 C3 00 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;image-20240814234102998.png&quot; alt=&quot;image-20240814234102998&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;冻结血量 vs 删除扣血代码&lt;/h3&gt;
&lt;p&gt;冻结血量和删除扣血代码的效果其实完全不同。在上文中，我们在扣除敌人血量的过程中顺手删除了玩家扣血的代码。如果我们保留这段代码，仍使用冻结功能的话。当我们杀掉一个敌人后，另一敌人会射出一发足以秒杀玩家的子弹，这时候玩家就会被敌人秒杀。&lt;/p&gt;
&lt;p&gt;我们可以通过通过下述代码进行实验：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ENABLE]
alloc(newmem,2048,&quot;gtutorial-x86_64.exe&quot;+400E3)
label(returnhere)
label(originalcode)
label(exit)

newmem:
sub [rax+60],edx
cmp [rax+60+10],0
je exit

originalcode:
mov [rax+60],0

exit:
ret
add [rax],al
jmp returnhere

&quot;gtutorial-x86_64.exe&quot;+400E3:
jmp newmem
nop
returnhere:

[DISABLE]
dealloc(newmem)
&quot;gtutorial-x86_64.exe&quot;+400E3:
db 29 50 60 C3 00 00
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在该代码中，我们保留了玩家的扣血代码。重新启动游戏并应用自动汇编，冻结玩家血量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240814235409330.png&quot; alt=&quot;image-20240814235409330&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在我们杀掉一个敌人后，玩家仍会被另一发伤害足够高的子弹秒杀。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240814235508758.png&quot; alt=&quot;image-20240814235508758&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因此我们可以得知，所谓的“冻结功能”只是快速的向该内存写入固定的值，并不能实现无敌的效果。当受到足够高的伤害时，玩家仍会判定为死亡。&lt;/p&gt;
&lt;h2&gt;第三关&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815000050219.png&quot; alt=&quot;image-20240815000050219&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;传送敌人&lt;/h3&gt;
&lt;p&gt;使用扫描器，寻找敌人的坐标&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!tip]&lt;/p&gt;
&lt;p&gt;合理利用游戏赠送的暂停功能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过 &lt;code&gt;What writes this memory&lt;/code&gt; 发现有3个指令写了这个地址。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815003756240.png&quot; alt=&quot;image-20240815003756240&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815004217112.png&quot; alt=&quot;image-20240815004217112&quot; /&gt;&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;Find out what addresses this instruction accesses&lt;/code&gt;，查看这个指令访问了哪些地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815004404739.png&quot; alt=&quot;image-20240815004404739&quot; /&gt;&lt;/p&gt;
&lt;p&gt;移动玩家，这里的地址数不会增加。看起来这3个就是3个敌人的值了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!tip]&lt;/p&gt;
&lt;p&gt;找到敌人的一个x坐标后，通过肉眼观测法发现 另外两个敌人的坐标。除此之外还有一个疑似移动方向的值。这个范围内的值肯定都和这个敌人有关。有时候我们可以通过这种方式摸鱼。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815003315629.png&quot; alt=&quot;image-20240815003315629&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同理，对于玩家，我们同样使用扫描器扫描，找到相应的坐标：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815002316125.png&quot; alt=&quot;image-20240815002316125&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!tip]&lt;/p&gt;
&lt;p&gt;一般来说，程序员在声明坐标的时候会将 x 和 y 的声明放在一起。因此我们在找到其中一个值的时候可以浏览内存来快速找到另一个坐标值。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;获得玩家的坐标后，我们可以知道 $x$ 后面的就是 $y$ 坐标。不过我们在传送敌人时不使用玩家的坐标&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815005015198.png&quot; alt=&quot;image-20240815005015198&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在内存浏览器中直接将敌人 y 值修改到地图外&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815005145060.png&quot; alt=&quot;image-20240815005145060&quot; /&gt;&lt;/p&gt;
&lt;p&gt;地图中的敌人就消失了&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815005153373.png&quot; alt=&quot;image-20240815005153373&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;飞行&lt;/h3&gt;
&lt;p&gt;&lt;s&gt;删除敌人后，发现还是有点难跳，让我们试着做一下飞行&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;首先先找到模拟重力的代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815010312741.png&quot; alt=&quot;image-20240815010312741&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在跳跃时，下面的 &lt;code&gt;movss [rax+28],xmm1&lt;/code&gt; 不再被执行。而在平时站立时，上一条代码的执行次数大概就是下一条的两倍。&lt;/p&gt;
&lt;p&gt;为什么在跳跃时下一条代码不执行呢？大胆猜测下一条代码本身的功能是下降。让我们使用 &lt;code&gt;nop&lt;/code&gt; 填充这个指令。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;recording.gif&quot; alt=&quot;recording&quot; /&gt;&lt;/p&gt;
&lt;p&gt;~~我不好说，原来是碰撞检测（后来发现并不简单是的碰撞后的排斥）。~~让我们试着把另一条指令填充 &lt;code&gt;nop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815012032164.png&quot; alt=&quot;image-20240815012032164&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;recording-1723656081144-4.gif&quot; alt=&quot;recording&quot; /&gt;&lt;/p&gt;
&lt;p&gt;确实不下降了，但是也不能跳跃，还有瞬移现象。使用调试工具发现是第二条指令导致瞬移的，&lt;/p&gt;
&lt;p&gt;因此将这两条全部填充为 nop 可以删除重力。有关这两条代码究竟是怎么搭配的，还希望有了解的人讲解一下。因此现在我们有一种飞行思路：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ENABLE]
&quot;gtutorial-x86_64.exe&quot;+410FE:
db 90 90 90 90 90

gtutorial-x86_64.exe+40F39:
db 90 90 90 90 90 90
[DISABLE]
&quot;gtutorial-x86_64.exe&quot;+410FE:
movss [rax+28],xmm1

gtutorial-x86_64.exe+40F39:
movss [rax+28],xmm9
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;直接将这两段代码填充 &lt;code&gt;nop&lt;/code&gt;，并给 y 添加 hotkey&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815013947644.png&quot; alt=&quot;image-20240815013947644&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;recording-1723657217223-6.gif&quot; alt=&quot; &quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240815014156224.png&quot; alt=&quot;image-20240815014156224&quot; /&gt;&lt;/p&gt;
</content:encoded><category>逆向</category><category>Cheat Engine</category><author>Mslxl</author></item><item><title>ChectEngine（一）：基本使用——以官方小游戏为例</title><link>https://blog.mslxl.com/posts/fun/ce-tutor-offical/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/fun/ce-tutor-offical/</guid><description>尝试写了点汇编，大概是只有开发者才能看懂</description><pubDate>Fri, 28 Jun 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;此文又称《只有开发者能看懂的CE教程》&lt;/p&gt;
&lt;p&gt;&lt;s&gt;CheatEngine 想必大家懂的都懂。但 CheatEngine 是怎么回事呢？ CheatEngine 相信大家都很熟悉，但是 CheatEngine 是怎么回事呢，下面就让小编带大家一起了解吧&lt;/s&gt;&lt;/p&gt;
&lt;h2&gt;捆绑软件警告&lt;/h2&gt;
&lt;p&gt;在安装过程中，不要无脑下一步，小心被老外来一个中国式&lt;strong&gt;捆绑软件&lt;/strong&gt;震撼（如下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240731101103030.png&quot; alt=&quot;image-20240731101103030&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果你无脑点了接受，那么恭喜你了兄弟，去控制面板找到 RAV 杀毒并卸载吧。&lt;/p&gt;
&lt;p&gt;Cheat Engine 通过提供安装广告软件的选项来实现这一点，目前（7.5）也只在安装向导里安装广告软件，还算可以接受吧。&lt;/p&gt;
&lt;p&gt;此称为永远不要进行自动安装或盲目安装任何东西的教训。&lt;/p&gt;
&lt;h2&gt;使用 CEShare&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;image-20240731101200942.png&quot; alt=&quot;image-20240731101200942&quot; /&gt;&lt;/p&gt;
&lt;p&gt;CEShare 是一个 CheatEngineTable 分享接口。通过 CEShare，用户可以直接从 CheatEngine 中通过进程名来检索其他用户分享的 CheatEngineTable（如下图）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240731101908326.png&quot; alt=&quot;image-20240731101908326&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不过其实对于大多数游戏来说都找不到。此外如果需要现成的修改器，为什么不使用风灵月隐呢？&lt;/p&gt;
&lt;p&gt;用 CE 还是自己动手的时候比较多。&lt;/p&gt;
&lt;h2&gt;值扫描&lt;/h2&gt;
&lt;p&gt;所有操作均需要从 CE 中打开进程。&lt;/p&gt;
&lt;p&gt;通过点击主界面左上角的图标，即可轻松打开对应进程。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240731102216267.png&quot; alt=&quot;image-20240731102216267&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在右侧面板中，可以通过值扫描对应的变量地址，该过程称为值扫描。&lt;/p&gt;
&lt;p&gt;值扫描可以指定扫描的方式，在第一次扫描时可以是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;确定值&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;``大于x`&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;小于x&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;在两数之间&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;未知初始值&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后的扫描中可以是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;确定值&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;大于x&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;小于x&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;在两数之间&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;增加的数&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;增加x的数&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;减少的数&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;减少x的数&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;未变化的值&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;变化的值&lt;/code&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img src=&quot;image-20240731103127198.png&quot; alt=&quot;image-20240731103127198&quot; /&gt;&lt;/p&gt;
&lt;p&gt;用户可以进行多次扫描以确定变量的地址。在扫描时可以情况不同选择不同的方式进行扫描。例如游戏中有一个血条，玩家并不知道血条的具体数值，此时可以采用后4种方式来进行扫描。比如说先进行 &lt;code&gt;大于0&lt;/code&gt;、&lt;code&gt;小于25565&lt;/code&gt;、&lt;code&gt;未变化的值&lt;/code&gt;，然后想办法让血量下降，并重新扫描 &lt;code&gt;减少 x 的数&lt;/code&gt;（或者减少的数）。多次重复一般即可找到对应地址。&lt;/p&gt;
&lt;p&gt;如果要扫描的值在扫描过程中可能会发生变化，可以勾选 &lt;code&gt;Memory Scan Options&lt;/code&gt; 中的 &lt;code&gt;Pause the game while scanning&lt;/code&gt;。该选项会再扫描时将对应进程挂起。&lt;/p&gt;
&lt;h2&gt;内存模型&lt;/h2&gt;
&lt;p&gt;在 Windows 系统中，内存是被虚拟化的。应用程序不能直接访问内存地址，这使得 windows 可以移动物理内存，或者将内存块与虚拟存储器交换。&lt;/p&gt;
&lt;p&gt;对于应用程序的开发者而言， Windows 提供的是一种平面内存模型。内存地址从 0 开始增长，对于应用程序来说，内存是连续的。应用程序可以选择对自己的内存进行分段。但实际上这些内存在存储器中的分布是离散的，这一点可以通过 &lt;a href=&quot;https://en.wikipedia.org/w/index.php?title=Memory_dump&amp;amp;redirect=no&quot;&gt;Memory dump&lt;/a&gt; 文件来知晓。同时，一个进程不能去访问另一个进程的内存，这会引发 Segment Fault。实际上对于不同的应用程序来说，因为 Windows 虚拟化内存的原因，一个相同的内存地址对于不同的应用程序对应的其实是不同的物理内存地址，双方是不能互相访问的。如果需要相互访问，则需要通过系统提供的其他API进行显式的修改，而不能简单的通过裸指针，这也是为什么 CE 需要打开进程的原因。对于访问其他进程的进程来说，这段空间也并不是连续的。&lt;/p&gt;
&lt;p&gt;更多有关内容可以查看&lt;a href=&quot;https://learn.microsoft.com/en-us/windows/win32/memory/memory-management&quot;&gt;Memory Management&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;官方教程&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803172331274.png&quot; alt=&quot;image-20240803172331274&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;第 2 关：确定值扫描（PW=090453）&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;TIP：你可以通过输入标题中的 PW 来跳转到对应的关卡&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;recording.gif&quot; alt=&quot;recording&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目标：将血量修改到 1000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一切的开始。&lt;/p&gt;
&lt;p&gt;很简单的一关，只需要扫描当前血量，减少血量。重复一轮即可。&lt;/p&gt;
&lt;p&gt;在拿到想要的内存地址后，可以通过双击将该条目加入到下面的列表中，或者之间通过右键修改。&lt;/p&gt;
&lt;h2&gt;第 3 关：未知值扫描（PW=419482）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;recording-1722395577866-2.gif&quot; alt=&quot;recording&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目标：将血量修改到 5000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因为下面有个血条，可以猜测这个值是大于0，且不是很大。&lt;/p&gt;
&lt;p&gt;我们可以上来猜测这个血量在 0-1000 之间（实际上这个血量在 0-500 之间），然后再通过&lt;code&gt;减少了x&lt;/code&gt;来找到血量。&lt;/p&gt;
&lt;h2&gt;第 4 关：浮点数（PW=089124）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;recording-1722395794808-4.gif&quot; alt=&quot;recording&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目标：将血量和弹药修改到 5000&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;同上，甚至因为浮点数位比较长，比上面都好找。&lt;/p&gt;
&lt;p&gt;注意这里的浮点数并不是说小数，而是 IEEE 754 标准浮点数。如果游戏中的浮点数并不是 IEEE 754 标准，那么该扫描并不能找到对应的值。&lt;/p&gt;
&lt;h2&gt;第 5 关：代码查找器（PW=888899）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;recording-1722396606509-6.gif&quot; alt=&quot;recording&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目标：每次点击 Change Value 都会改变值，现需要将其更改为点击 &lt;code&gt;Change Value&lt;/code&gt; 后值不变&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;思路：找到修改值的汇编代码，用空指令填充&lt;/p&gt;
&lt;p&gt;在教程中，可以很容易的利用 CheatEngine 找到修改数值的代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803002535206.png&quot; alt=&quot;image-20240803002535206&quot; /&gt;&lt;/p&gt;
&lt;p&gt;将该指令替换为 &lt;code&gt;nop&lt;/code&gt; 即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803002605767.png&quot; alt=&quot;image-20240803002605767&quot; /&gt;&lt;/p&gt;
&lt;p&gt;替换结束后，&lt;code&gt;rax&lt;/code&gt; 寄存器所指向的内存地址将不再被修改为 &lt;code&gt;edx&lt;/code&gt;中的值。此时点击 Change Value 按钮，数值将不再更新&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803002627982.png&quot; alt=&quot;image-20240803002627982&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!tip]&lt;/p&gt;
&lt;p&gt;此处可以使用&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240731145853760.png&quot; alt=&quot;image-20240731145853760&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在自动汇编器中加入以下代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ENABLE]
//code from here till the end of the code will be used to disable the cheat
&quot;Tutorial-x86_64.exe&quot;+2CB88:
nop
nop

[DISABLE]
&quot;Tutorial-x86_64.exe&quot;+2CB88:
mov [rax],edx
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即在 &lt;code&gt;Enanble&lt;/code&gt; 时将 &lt;code&gt;2CB88&lt;/code&gt; 地址替换为两个 &lt;code&gt;nop&lt;/code&gt;，&lt;code&gt;Disable&lt;/code&gt; 时同理。
修改之后将其添加到 Table 中，即可通过选择框快速修改相应代码&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Enable&lt;/th&gt;
&lt;th&gt;Disable&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;img src=&quot;image-20240731145947831.png&quot; alt=&quot;image-20240731145947831&quot; /&gt;&lt;/td&gt;
&lt;td&gt;&lt;img src=&quot;image-20240731145923835.png&quot; alt=&quot;image-20240731145923835&quot; /&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;/blockquote&gt;
&lt;h2&gt;第 6 关：指针（PW=098712）&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;目标：将值修改为 5000，冻结此值后修改指针，使值不会发生变化。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当点击修改指针后，原本的数值所在的内存位置会发生移动，而对应的指针也会被修改，因此简单的记录这个值所在的内存地址不可行。&lt;/p&gt;
&lt;p&gt;幸好，大多数情况下这种移动都是有迹可寻的。如果一个变量在代码中是静态的，那么它的内存空间是固定不变的。如果这个变量在函数的调用栈中，或者是在运行时被 &lt;code&gt;new&lt;/code&gt; 出来的，那么它的地址则会在程序重启，甚至是运行时发生变化。但是程序总是需要找到这些动态的变量，那么此时就会存在一个指针，可能是二级，也可能更多级的指针，指向这个变量。我们可以通过从一个静态的地址出发，通过访问指针来找到所需的地址。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!tip]&lt;/p&gt;
&lt;p&gt;该过程类似于“间接寻址”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先还是通过扫描器找到值的地址：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803005635229.png&quot; alt=&quot;image-20240803005635229&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，这是一个动态的地址（静态地址在CE中以绿色字体显示）。我们需要找到从静态区域指向它这指针，使用 Cheat Engine 的 Pointer scan 可以偷懒找到这个区域&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803005842272.png&quot; alt=&quot;image-20240803005842272&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803005923349.png&quot; alt=&quot;image-20240803005923349&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803005934630.png&quot; alt=&quot;image-20240803005934630&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在漫长的扫描后，我们可以得到这样的一串指向制定地址的指针：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803010025897.png&quot; alt=&quot;image-20240803010025897&quot; /&gt;&lt;/p&gt;
&lt;p&gt;但是这些指针并不都是正确的，我们还需要多扫描几次来找到真正的正确指针。&lt;/p&gt;
&lt;p&gt;点击 Change pointer 更改指针，然后在现有基础上再重新进行一次扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803010159993.png&quot; alt=&quot;image-20240803010159993&quot; /&gt;&lt;/p&gt;
&lt;p&gt;更改后值为7，我们在重扫描时使用值扫描7而不是地址扫描&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803010313192.png&quot; alt=&quot;image-20240803010313192&quot; /&gt;&lt;/p&gt;
&lt;p&gt;之后我们就拿到了一串更可信的指针&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803010355006.png&quot; alt=&quot;image-20240803010355006&quot; /&gt;&lt;/p&gt;
&lt;p&gt;重复上述过程，有可能还需要重启程序，找到无论进行什么操作都始终正确的指针即可。&lt;/p&gt;
&lt;p&gt;将正确的指针加入 Table 中，修改值为 5000 并进行冻结，即可过关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803010529289.png&quot; alt=&quot;image-20240803010529289&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[!tip]&lt;/p&gt;
&lt;p&gt;上述过程也可通过汇编器手动进行。&lt;/p&gt;
&lt;p&gt;方法为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通过值扫描器找到值地址&lt;/li&gt;
&lt;li&gt;找到谁修改了这个地址&lt;img src=&quot;image-20240803011038286.png&quot; alt=&quot;image-20240803011038286&quot; /&gt;&lt;/li&gt;
&lt;li&gt;分析得知上级地址可能值 &lt;img src=&quot;image-20240803011116129.png&quot; alt=&quot;image-20240803011116129&quot; /&gt;&lt;/li&gt;
&lt;li&gt;使用值扫描器寻找地址&lt;/li&gt;
&lt;li&gt;寻找谁访问了这个地址&lt;/li&gt;
&lt;li&gt;重复过程 4 和 5，直到找到静态地址区域&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt;：过程4中可能有多个地址指向这个目标地址，这些地址不一定都正确&lt;/p&gt;
&lt;p&gt;找到地址后，将基值和偏移值输入 Cheat Engine 即可&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803011420120.png&quot; alt=&quot;image-20240803011420120&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;第 7 关：代码注入（PW=013370）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803011456099.png&quot; alt=&quot;image-20240803011456099&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目标：使每次遭到攻击时，血量+2&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先通过值扫描器找到修改这个地址的指令&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803011619002.png&quot; alt=&quot;image-20240803011619002&quot; /&gt;&lt;/p&gt;
&lt;p&gt;可以看到，使血量减少的代码是 &lt;code&gt;sub dword ptr [rsi+000007E0],01&lt;/code&gt;，即将 32 位的 rsi+7E0 指向的内存区域的值减1。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803011653066.png&quot; alt=&quot;image-20240803011653066&quot; /&gt;&lt;/p&gt;
&lt;p&gt;我们将代码修改为减去-2，或者将减法指令替换为加法指令，均可过关。此处将减法指令修改为加法指令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;add dword ptr [rsi+000007E0],02
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;第 8 关：多级指针（PW=525927）&lt;/h2&gt;
&lt;p&gt;过关方式同第6关，略。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803012401773.png&quot; alt=&quot;image-20240803012401773&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;第 9 关：共享代码（PW=31337157）&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803122323859.png&quot; alt=&quot;image-20240803122323859&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;目标：正常情况下，Player1 和 Player2 会输掉这场比赛。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;recording-1722659320801-1.gif&quot; alt=&quot;recording&quot; /&gt;&lt;/p&gt;
&lt;p&gt;不使用冻结，使 Player 所在的队伍赢得比赛。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;很容易想到，这关最简单的思路还是锁血，即删除扣除玩家血量的代码。&lt;/p&gt;
&lt;p&gt;首先使用第7关的方式找到修改血量的代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803123252106.png&quot; alt=&quot;image-20240803123252106&quot; /&gt;&lt;/p&gt;
&lt;p&gt;首先尝试将 &lt;code&gt;2F&lt;/code&gt; 处的代码替换为 &lt;code&gt;nop&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803123348275.png&quot; alt=&quot;image-20240803123348275&quot; /&gt;&lt;/p&gt;
&lt;p&gt;结果敌人也不扣血，证明敌我双方共用了相同的代码（如下图）&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;recording-1722659726163-3.gif&quot; alt=&quot;recording&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这种情况下，为了区分不同的玩家，一定会有其他字段用于区分不同的血量。结合反汇编器的代码上下存在判断代码，我们大胆猜测它的代码中有以下结构体和函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;struct Player{
    id: i32,
    // 有可能是 is_cpu: bool
    // 甚至有可能是 name: String 或者 name: &amp;amp;str
       health: f32
}
impl Player{
    fn attack(&amp;amp;mut self, atk: f32){
        // unknown code
        self.health -= atk;

        if self.health &amp;lt; 0 {
            self.die();
        }
        // somethings else
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;我们的目标就是在扣血之前判断身份，如果是电脑则正常执行扣血指令，否则什么也不做。也就是说我们需要修改添加一个判断语句。&lt;/p&gt;
&lt;p&gt;首先我们寻找如何判定是玩家。如果像是上图的结构，那么玩家的标识一定就在血量旁边，稍微偏移一点就能找到身份标识。&lt;/p&gt;
&lt;p&gt;我们使用 Memory Viewer 中的 `Dissect data/s&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803125527892.png&quot; alt=&quot;image-20240803125527892&quot; /&gt;&lt;/p&gt;
&lt;p&gt;将血量的地址填入，结果可以在下面发现了一串字符串可以用于判断。另外这里甚至还有一个字符用来表示字符串的长度。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803130333986.png&quot; alt=&quot;image-20240803130333986&quot; /&gt;&lt;/p&gt;
&lt;p&gt;道理上，我们可以通过判断字符串来通过此关（如果不追求重启重开的可复现，甚至可以拿偏移 &lt;code&gt;0004&lt;/code&gt; 地址的数字做判断）。但是比较字符串比较复杂，我们还是往上找一找有没有简单的判断方式。&lt;/p&gt;
&lt;p&gt;向上偏移 128 位看看有没有可以利用的字段&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803131816712.png&quot; alt=&quot;image-20240803131816712&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803132148914.png&quot; alt=&quot;image-20240803132148914&quot; /&gt;&lt;/p&gt;
&lt;p&gt;好吧，没找到。那就只能去判断字符串了，如果只是通过此关的话只需要判断第一个字母的 ascii 码即可，但是对于其他游戏可能需要全部判断一次（可以利用C语言标准库）&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;2F25D&lt;/code&gt; 位置，血量的内存被修改。也就是说 &lt;code&gt;rbx+08&lt;/code&gt; 位置为血量的内存地址，而再偏移11位，即&lt;code&gt;rbx+19&lt;/code&gt; 位置为字符串的首字母。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803164957156.png&quot; alt=&quot;image-20240803164957156&quot; /&gt;&lt;/p&gt;
&lt;p&gt;明确了判断目标，我们需要一块新内存来存放我们的代码。使用 Tools-Allocate Memory 来申请一块新内存来存放我们的代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803165335587.png&quot; alt=&quot;image-20240803165335587&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在新开辟的内存处输入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;cmp [rbx+19], 65766144 # Dave 按位表示为 HEX
je 02E60010
movss [rbx+08], xmm0
jmp 10002F262
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将原 &lt;code&gt;movss [rbx+08], xmm0&lt;/code&gt; 修改为 &lt;code&gt;jmp 02E60000&lt;/code&gt;，形成以下代码&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803170631807.png&quot; alt=&quot;image-20240803170631807&quot; /&gt;&lt;/p&gt;
&lt;p&gt;这样即可过关&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;recording-1722676715677-5.gif&quot; alt=&quot;recording&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;自动汇编&lt;/h3&gt;
&lt;p&gt;一行一行手操汇编太麻烦了？&lt;/p&gt;
&lt;p&gt;其实CheatEngine 提供了自动汇编功能&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803171935530.png&quot; alt=&quot;image-20240803171935530&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;[ENABLE]
//code from here to &apos;[DISABLE]&apos; will be used to enable the cheat
alloc(newmem,2048,&quot;Tutorial-x86_64.exe&quot;+2F25D)
label(returnhere)
label(originalcode)
label(exit)

newmem:
cmp [rbx+19], &apos;Dave&apos;
je exit

originalcode:
movss [rbx+08],xmm0

exit:
jmp returnhere

&quot;Tutorial-x86_64.exe&quot;+2F25D:
jmp newmem
returnhere:

[DISABLE]
//code from here till the end of the code will be used to disable the cheat
dealloc(newmem)
&quot;Tutorial-x86_64.exe&quot;+2F25D:
db F3 0F 11 43 08
//movss [rbx+08],xmm0
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;image-20240803172650541.png&quot; alt=&quot;image-20240803172650541&quot; /&gt;&lt;/p&gt;
&lt;p&gt;将其加入 Table，即可实现快速修改。&lt;/p&gt;
&lt;p&gt;通过自动汇编，可以使用 label 来进行跳转，不需要纠结 nop 对齐，也不需要考虑跳转的内存地址。CheatEngine 会自动处理这些行为。&lt;/p&gt;
</content:encoded><category>逆向</category><category>Cheat Engine</category><author>Mslxl</author></item><item><title>Codeforces Round 946 (Div. 3) (A-G)</title><link>https://blog.mslxl.com/posts/cp/cf1974/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/cf1974/</guid><description>一场比较简单的div3</description><pubDate>Wed, 22 May 2024 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;A. Phone Desktop&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个 $5 \times 3$ 大小的手机上面上摆放 $x$ 个 $1\times 1$ 大小和 $y$ 个 $2 \times 2 $​​ 大小的手机图标。问最小需要多少个屏幕&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;先摆大的，剩下的空间摆小的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int x, y;
  read(x, y);

  int occupy_full = y / 2;
  bool is_remain = y % 2;

  int remain_cell = occupy_full * 7 + is_remain * 11;

  int big = occupy_full + is_remain;
  int small = std::ceil(std::max(x - remain_cell, int(0)) * 1.0 /15);

  std::cout &amp;lt;&amp;lt; occupy_full + (is_remain) + std::ceil(mmax((x - remain_cell), 0) * 1.0 / 15);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Symmetric Encoding&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个字符串 $s$ ，将 $s$ 进行排序去重后得到 $m$。根据映射关系将$s$中每个字符$s_i$找到在 $m$ 中对应的 $c_i$ 并替换为替换为 $c_j$，其中 $i + j = \mid m \mid$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;pre&gt;&lt;code&gt; void solve() {
    int a;
    std::cin &amp;gt;&amp;gt; a;
    std::string x;
    std::cin &amp;gt;&amp;gt; x;
    std::string y = x;
    std::sort(all(y));
    y.erase(std::unique(all(y)), y.end());
    std::map&amp;lt;char, char&amp;gt; mp;
    for(int i = 0, end = y.size()-1; i &amp;lt; y.size(); i++, end--){
        mp[y[i]] = y[end];
    }
    for(auto ch: x){
        std::cout &amp;lt;&amp;lt; mp[ch];
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Beautiful Triple Pairs&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给一个序列 $a(\mid a \mid = n)$，构造三元组 $t_i = (a_i, a_{i+1}, a_{i+2})\space, 1\le i \le n-2$&lt;/p&gt;
&lt;p&gt;求$t_i$​中有多少对三元组中只有一个元素不同&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假设现在只求最后一个元素不同的元组有多少对。&lt;/p&gt;
&lt;p&gt;设对于 $t_i$ ，前两个元素相同的数量减去三个元素相同的数量，即为和$t_i$ 相比最后一个元素不同的数量。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  i32 n;
  read(n);
  std::vector&amp;lt;int&amp;gt; a(n);
  reads(all(a));

  std::map&amp;lt;std::pair&amp;lt;int, int&amp;gt;, int&amp;gt; fst, snd, thi;
  std::map&amp;lt;std::array&amp;lt;int, 3&amp;gt;, int&amp;gt; cnt;
  i64 ans = 0;

  for (int i = 0; i &amp;lt; n - 2; i++) {
    int q = a[i], w = a[i + 1], e = a[i + 2];

    ans += fst[{w, e}] - cnt[{q, w, e}];
    ans += snd[{q, e}] - cnt[{q, w, e}];
    ans += thi[{q, w}] - cnt[{q, w, e}];

    fst[{w, e}]++;
    snd[{q, e}]++;
    thi[{q, w}]++;
    cnt[{q, w, e}]++;
  }

  std::cout &amp;lt;&amp;lt; ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. Ingenuity-2&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;A和B都能向NSEW四个方向移动，现在给出一个操作序列，将序列中每个元素分给A或B，使A和B在同一个点出发时都能到达同一个终点，且A和B都进行了移动。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;ul&gt;
&lt;li&gt;如果有两个相同的操作，可以将两个操作分别发给A和B&lt;/li&gt;
&lt;li&gt;如果有两个相反的操作（比如N和S），可以将其两者发给A或B&lt;/li&gt;
&lt;li&gt;将 NS 发给 A，EW 发给B可确保在可行时 A 和B 都能进行移动&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;思路很乱，写的又臭又长&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
    int len;
    std::cin &amp;gt;&amp;gt; len;
    std::string instr;
    std::cin &amp;gt;&amp;gt; instr;
    std::map&amp;lt;char, int&amp;gt; cnt;
    for(auto ch: instr){
        cnt[ch]++;
    }
    std::map&amp;lt;char, int&amp;gt; tmp = cnt;
    cnt[&apos;N&apos;] %= 2;
    cnt[&apos;S&apos;] %= 2;
    cnt[&apos;E&apos;] %= 2;
    cnt[&apos;W&apos;] %= 2;
    if(cnt[&apos;N&apos;] != cnt[&apos;S&apos;] || cnt[&apos;E&apos;] != cnt[&apos;W&apos;]){
        std::cout &amp;lt;&amp;lt; &quot;NO&quot;;
        return;
    }
    std::map&amp;lt;char, int&amp;gt; p = tmp;
    p[&apos;N&apos;] -= cnt[&apos;N&apos;];
    p[&apos;S&apos;] -= cnt[&apos;S&apos;];
    p[&apos;E&apos;] -= cnt[&apos;E&apos;];
    p[&apos;W&apos;] -= cnt[&apos;W&apos;];

    char flipChar = &apos;N&apos;;
    if(p[&apos;N&apos;] &amp;gt; 0 &amp;amp;&amp;amp; p[&apos;N&apos;] % 2 == 0){
        flipChar = &apos;N&apos;;
    }else if(p[&apos;S&apos;] &amp;gt; 0 &amp;amp;&amp;amp; p[&apos;S&apos;] % 2 == 0){
        flipChar = &apos;S&apos;;
    }else if(p[&apos;E&apos;] &amp;gt; 0 &amp;amp;&amp;amp; p[&apos;E&apos;] % 2 == 0){
        flipChar = &apos;E&apos;;
    }else if(p[&apos;W&apos;] &amp;gt; 0 &amp;amp;&amp;amp; p[&apos;W&apos;] % 2 == 0){
        flipChar = &apos;W&apos;;
    }

    std::string seq;
    int Hcnt = 0, Rcnt =0;

    for(auto ch: instr){
        if(p[ch] != 0) {
            if(p[ch] % 2){
                if(flipChar == ch){
                    seq.push_back(&apos;H&apos;);
                    Hcnt++;
                }else{
                    seq.push_back(&apos;R&apos;);
                    Rcnt++;
                }
            }else{
                if(flipChar == ch){
                    seq.push_back(&apos;R&apos;);
                    Rcnt++;

                }else{
                    seq.push_back(&apos;H&apos;);
                    Hcnt++;
                }
            }
            p[ch]--;
        }else if(ch == &apos;N&apos; || ch == &apos;S&apos;) {
            seq.push_back(&apos;R&apos;);
            Rcnt++;
        }else{
            seq.push_back(&apos;H&apos;);
            Hcnt++;
        }
    }
    if(Rcnt == 0 || Hcnt==0){
        std::cout &amp;lt;&amp;lt; &quot;NO&quot;;
    }else{
        std::cout &amp;lt;&amp;lt; seq;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;E. Money Buys Happiness&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;小 C 每个月赚 $x$ 元，在 $m$ 个月中每个月都可以花费 $c_i$ 元获取 $h_i$ 的快乐值，这种操作最多进行1次。&lt;/p&gt;
&lt;p&gt;$m$​ 个月后小 C 的快乐值最大是多少&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;似乎是 PTA 上的原题&lt;/p&gt;
&lt;p&gt;注意数据范围发现 $m$ 和 $h$ 出奇的小，故可以将背包的维度掉转一下。使 $dp[i][j]$ 表示第 $i$ 个月有 $h$ 快乐的时候花了多少钱&lt;/p&gt;
&lt;p&gt;那么就有 $$dp[i][j] = \begin{cases}\max\left(dp[i-1][j-h[i]] - c[i] + x,dp[i-1][j] + x\right) &amp;amp;, j - h[i] \ge 0 \ dp[i][j] = dp[i - 1][j] + x &amp;amp;, \text{Otherwise}\end{cases}$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int dp[67][50017];

void solve(){
    int m, x;
    read(m, x);
    std::vector&amp;lt;int&amp;gt; c(m + 1), h(m + 1);
    int max_h = 50010;
    for (int i = 1; i &amp;lt;= m; i++){
        read(c[i], h[i]);
    }

    std::memset(dp, -0x3f, sizeof(dp));
    dp[0][0] = 0;

    for (int i = 1; i &amp;lt;= m; i++){
        for (int j = 0; j &amp;lt;= max_h; j++){
            if (j - h[i] &amp;gt;= 0 &amp;amp;&amp;amp; dp[i - 1][j - h[i]] &amp;gt;= c[i]){
                dp[i][j] = std::max(dp[i - 1][j - h[i]] - c[i] + x, dp[i-1][j] + x);
            }else{
                dp[i][j] = dp[i - 1][j] + x;
            }
        }
    }
    int ans = 0;
    for (int j = 0; j &amp;lt;= max_h; j++){
        if (dp[m][j] &amp;gt;= 0){
            ans = mmax(ans, j);
        }
    }
    std::cout &amp;lt;&amp;lt; ans;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;F. Cutting Game&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有 $a\times b$ 大小的格子，上面摆有 $n$​ 个物品。A 和 B 轮流从上、下、左或右侧删一定的行或列，每当他们删去的格子上有1个物品时得一分。给出格子、物品和操作，求得分&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;拿个 set 存位置打暴力即可，注意行列&lt;/p&gt;
&lt;p&gt;复杂度 $n\log{n}$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int a, b, n, m;
  read(a, b, n, m);

  std::set&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; rchip, cchip, removed;
  for (int i = 0; i &amp;lt; n; i++) {
    int x, y;
    read(x, y);
    rchip.insert({x, y});
    cchip.insert({y, x});
  }

  int lbound = 1, rbound = b, tbound = 1, bbound = a;

  int point[2] = {0, 0};

  for (int i = 0; i &amp;lt; m; i++) {
    char op;
    int opnum;
    std::cin &amp;gt;&amp;gt; op &amp;gt;&amp;gt; opnum;
    if (op == &apos;U&apos;) {
      while (!rchip.empty() &amp;amp;&amp;amp; rchip.begin()-&amp;gt;first - tbound &amp;lt; opnum) {
        cchip.erase({rchip.begin()-&amp;gt;second, rchip.begin()-&amp;gt;first});
        rchip.erase(rchip.begin());
        point[i % 2]++;
      }
      tbound += opnum;
    } else if (op == &apos;D&apos;) {
      while (!rchip.empty() &amp;amp;&amp;amp; bbound - rchip.rbegin()-&amp;gt;first &amp;lt; opnum) {
        cchip.erase({rchip.rbegin()-&amp;gt;second, rchip.rbegin()-&amp;gt;first});
        rchip.erase(--rchip.end());
        point[i % 2]++;
      }
      bbound -= opnum;
    } else if (op == &apos;L&apos;) {
      while (!cchip.empty() &amp;amp;&amp;amp; cchip.begin()-&amp;gt;first - lbound &amp;lt; opnum) {
        rchip.erase({cchip.begin()-&amp;gt;second, cchip.begin()-&amp;gt;first});
        cchip.erase(cchip.begin());
        point[i % 2]++;
      }
      lbound += opnum;
    } else {
      while (!cchip.empty() &amp;amp;&amp;amp; rbound - cchip.rbegin()-&amp;gt;first &amp;lt; opnum) {
        rchip.erase({cchip.rbegin()-&amp;gt;second, cchip.rbegin()-&amp;gt;first});
        cchip.erase(--cchip.end());
        point[i % 2]++;
      }
      rbound -= opnum;
    }
  }
  std::cout &amp;lt;&amp;lt; point[0] &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; point[1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;G. Money Buys Less Happiness Now&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在 $m$ 个月中每月收入 $x$ 元，每个月都可以花费 $c_i$ 元购买 1 点幸福&lt;/p&gt;
&lt;p&gt;输出最大幸福&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;反悔贪心。由于每次购买的幸福都是1，所以在钱不够是反悔1次总能得到最优解&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
    int m, x;
    read(m, x);
    std::vector&amp;lt;int&amp;gt; c(m);
    reads(all(c));

    std::priority_queue&amp;lt;int&amp;gt; rec;

    int bag = 0;
    int happ = 0;
    for(auto v: c){
        if(bag &amp;lt; v &amp;amp;&amp;amp; !rec.empty() &amp;amp;&amp;amp; rec.top() &amp;gt; v){
            // regret
            bag += rec.top();
            rec.pop();
            bag -= v;
            rec.push(v);
        }else if(bag &amp;gt;= v){
            happ++;
            rec.push(v);
            bag-=v;
        }

        bag += x;
    }
    std::cout &amp;lt;&amp;lt; happ;
}

&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>Codeforces</category><author>Mslxl</author></item><item><title>使用 LaTeX 完成毕业论文——SDUFE thesis 开发记录</title><link>https://blog.mslxl.com/posts/others/sdufe-thesis-in-latex/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/sdufe-thesis-in-latex/</guid><description>为了准备课程论文和毕业论文，我决定魔改一份 LaTex 模板 —— 但因学校规定告终</description><pubDate>Sat, 27 Apr 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最近因为课程作业的原因，不得以提前准备毕业论文的 LaTeX 模板。作为一个仅使用过 LaTeX 而未制作过模板的人来说，这其实挑战还挺大的。不如从 WHU-Thesis[^1]（以下简称为whu） 开始魔改一份模板出来。&lt;/p&gt;
&lt;p&gt;[^1]: &lt;a href=&quot;https://github.com/whutug/whu-thesis&quot;&gt;武汉大学毕业论文 LaTeX 模版 2024&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;那么，WHU-Thesis 做了什么?&lt;/p&gt;
&lt;h2&gt;创建 Logger&lt;/h2&gt;
&lt;p&gt;首先 whu 为 &lt;code&gt;\msg_new&lt;/code&gt; 等函数创建了一个别名&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;%tag 简化-msg-模块的函数
\cs_new:Npn \__whu_msg_new:nn  { \msg_new:nnn      { whu-thesis } }
\cs_new:Npn \__whu_warning:n   { \msg_warning:nn   { whu-thesis } }
\cs_new:Npn \__whu_warning:nn  { \msg_warning:nnn  { whu-thesis } }
\cs_new:Npn \__whu_error:n     { \msg_error:nn     { whu-thesis } }
\cs_new:Npn \__whu_error:nn    { \msg_error:nnn    { whu-thesis } }
\cs_new:Npn \__whu_fatal:nx    { \msg_fatal:nnx    { whu-thesis } }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中这里由于 LaTeX 顺序展开的原因，可以做到类似柯里化的机制。&lt;/p&gt;
&lt;p&gt;对于 &lt;code&gt;\cs_new:Npn \__whu_msg_new:nn  { \msg_new:nnn      { whu-thesis } }&lt;/code&gt; 来说，它的完整定义应该是这样&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\cs_new:Npn \__whu_msg_new:nn #1#2  { \msg_new:nnn { whu-thesis } {#1} {#2} }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这代表着定义了一个新函数 &lt;code&gt;\__whu_msg_new:nn&lt;/code&gt;，它接受两个参数，分别是消息的唯一名称和实际输出的消息。当调用此消息时将创建一个新的输出函数，该函数以 &lt;code&gt;whu-thesis&lt;/code&gt; 为分类名进行输出&lt;/p&gt;
&lt;h2&gt;提供兼容方案&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\cs_if_exist:NF \NewDocumentCommand
  { \RequirePackage { xparse } }
\RequirePackage { xtemplate, l3keys2e }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;检查 &lt;code&gt;\NewDocumentCommand&lt;/code&gt; 是否存在。如果它不存在，那么执行 &lt;code&gt;{ \RequirePackage { xparse } }&lt;/code&gt;，即要求加载 &lt;code&gt;xparse&lt;/code&gt; 包&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\__whu_msg_new:nn { l3-too-old }
  {
    Package~ &quot;#1&quot;~ is~ too~ old. \\\\
    Please~ update~ an~ up-to-date~ version~ of~ the~ bundles \\
    &quot;l3kernel&quot;~ and~ &quot;l3packages&quot;~ using~ your~ TeX~ package \\
    manager~ or~ from~ CTAN.
  }
\clist_map_inline:nn { expl3, xtemplate, l3keys2e }
  {
    \@ifpackagelater {#1} { 2018/05/12 }
      { } { \__whu_error:nn { l3-too-old } {#1} }
  }
\sys_if_engine_xetex:F
  {
    \sys_if_engine_luatex:F
      {
        \__whu_fatal:nx { unsupported-engine }
          { \c_sys_engine_str }
      }
  }
\__whu_msg_new:nn { unsupported-engine }
  {
    The~ whu-thesis~ class~ requires~ either~ XeTeX~ or~ LuaTeX. \\\\
    &quot;#1&quot;~ is~ not~ supported~ at~ present.~ You~ must~ change \\
    your~ typesetting~ engine~ to~ &quot;xelatex&quot;~ or~ &quot;lualatex&quot;.
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;上述语句中分别通过 &lt;code&gt;\__whu_msg_new:nn&lt;/code&gt; 创建两条输出属于 &lt;code&gt;unsupported-engine&lt;/code&gt; 和 &lt;code&gt;l3-to-old&lt;/code&gt;。接下来先检查 &lt;code&gt;expl3&lt;/code&gt;, &lt;code&gt;xtemplate&lt;/code&gt; 和 &lt;code&gt;l3keys2e&lt;/code&gt; 的包发行时期是否在 &lt;code&gt;2018/05/12&lt;/code&gt; 之前，如果在此之前则调用 &lt;code&gt;l3-to-old&lt;/code&gt; 进行输出。同理，如果引擎不支持则调用 &lt;code&gt;unsupported-engine&lt;/code&gt; 进行输出。&lt;/p&gt;
&lt;h2&gt;为用户提供初始化命令&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;%tag 用户设置命令接口
\NewDocumentCommand \whusetup { m }
  { \keys_set:nn { whu } {#1} }

%tag meta-key
\keys_define:nn { whu }
  {
    style .meta:nn = { whu / style } {#1},
    info  .meta:nn = { whu / info  } {#1}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在下面的语句中定义了 &lt;code&gt;whu/style&lt;/code&gt; 和 &lt;code&gt;whu/info&lt;/code&gt; 两个元键值对。&lt;/p&gt;
&lt;p&gt;这种写法基本相当于:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\keys_define:nn { whu }
  {
    style .code:n = { \keys_set:nn { whu/style } { #1 } } ,
    info .code:n = { \keys_set:nn { whu/info } { #1 } } ,
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;感觉有点废话？但是实际上上面的代码是不能运行的。因为上面的代码缺少 &lt;code&gt;whu/style&lt;/code&gt; 和 &lt;code&gt;whu/info&lt;/code&gt; 的定义。但对于最初的代码来说则是可执行的，因为他的定义和赋值在同时发生&lt;/p&gt;
&lt;h2&gt;定义全局变量&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;%tag 定义全局变量
\clist_new:N \g__whu_to_ctexbook_clist   % 储存通过文档类选项传递给 ctexbook 的选项
\int_new:N \g__whu_thesis_type_int   % 论文类型：本、硕、博
\tl_new:N \g__whu_thesis_type_tl
\tl_new:N \g__whu_thesis_class_tl % 学术学位、专业学位
\bool_new:N \g__whu_draft_bool
\bool_new:N \g__whu_twoside_bool

%tag 临时变量
\box_new:N \l__whu_tmpa_box
\box_new:N \l__whu_tmpb_box
\clist_new:N \l__whu_tmpa_clist
\clist_new:N \l__whu_tmpb_clist
\tl_new:N \l__whu_tmpa_tl
\tl_new:N \l__whu_tmpb_tl
\dim_new:N \l__whu_tmpa_dim
\dim_new:N \l__whu_tmpb_dim
\dim_new:N \l__whu_tmpc_dim
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不必多言&lt;/p&gt;
&lt;h2&gt;?&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\hook_gset_rule:nnnn { begindocument/before } { . } { &amp;lt; } { xeCJK }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不知道在干什么&lt;/p&gt;
&lt;p&gt;似乎是在文档开始前去调用 xeCJK&lt;/p&gt;
&lt;h2&gt;创建函数变体&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\prg_generate_conditional_variant:Nnn \int_case:nn { Vn , xn } { T, F, TF }
\cs_generate_variant:Nn \int_case:nn { Vn, xn }
\cs_generate_variant:Nn \tl_map_inline:nn { xn }
\cs_generate_variant:Nn \dim_set:Nn { Nx }
\cs_generate_variant:Nn \str_case:nn { xn }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;基本函数&lt;/h2&gt;
&lt;h3&gt;空白页&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 空白页
\cs_new:Npn \__whu_new_blank_page:
  {
    \newpage \null \thispagestyle{empty} \newpage
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;__whu_new_blank_page&lt;/code&gt; 创建一个新页面，并将页面为空白页样式。这意味着当前页面上不会显示页眉、页脚或页码，整个页面将是空白的&lt;/p&gt;
&lt;h3&gt;分散盒子&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 分散盒子
\cs_new_protected:Npn \__whu_spread_box:nn #1#2
  % #1: 宽度
  % #2: 内容
  {
    \mode_leave_vertical:
    \hbox_to_wd:nn {#1}
      { \tl_map_inline:xn {#2} { ##1 \hfil } \unskip }
  }
\cs_new_protected:Npn \__whu_spread_box_with_end_spaces:nn #1#2
  {
    \mode_leave_vertical:
    \hbox_to_wd:nn {#1}
      { \hspace{0.19cm} \tl_map_inline:xn {#2} { ##1 \hfil } \unskip \hspace{0.19cm}}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;\__whu_spread_box&lt;/code&gt; 创建分散盒子：先创建一个水平盒子，再对于 &lt;code&gt;#2&lt;/code&gt; 中的内容的每两个元素之间添加一个弹性填空(&lt;code&gt;\hfil&lt;/code&gt;)&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\__whu_spread_box_with_end_spaces&lt;/code&gt; 同理，只是在最后重新添加了 &lt;code&gt;0.19cm&lt;/code&gt; 的空白&lt;/p&gt;
&lt;h3&gt;带圈数字&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\NewDocumentCommand \circlednumber { s m }
  {
    \IfBooleanTF {#1}
      { \__whu_tikz_circled_number:n {#2} }
      { \__whu_circled_number:n {#2} }
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为用户创建 &lt;code&gt;circlenumber&lt;/code&gt; 命令，可创建带圈数字。如果第一个参数为 true 则使用 tikz 创建;否则使用 Unicode&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\cs_new:Npn \__whu_circled_number:n #1
  {
    \int_set:Nn \l_tmpa_int {#1}
    \int_compare:nNnTF { \l_tmpa_int } = { 0 }
      { \int_set:Nn \l_tmpa_int { &quot;24EA } }
      {
        \int_compare:nNnTF { \l_tmpa_int } &amp;lt; { 21 }
          { \int_add:Nn \l_tmpa_int { &quot;245F } }
          {
            \int_compare:nNnTF { \l_tmpa_int } &amp;lt; { 36 }
              { \int_add:Nn \l_tmpa_int { &quot;3250 } }
              {
                \int_compare:nNnTF { \l_tmpa_int } &amp;lt; { 51 }
                  { \int_add:Nn \l_tmpa_int { &quot;32B0 } }
                  {
                    \msg_error:nnn { whu }
                      { invalid-circled-number } { \int_use:N \l_tmpa_int }
                  }
              }
          }
      }
    \group_begin:
      \CJKfamily+ { }
      \symbol { \l_tmpa_int }
    \group_end:
  }

\msg_new:nnn { whu } { invalid-circled-number }
  { Invalid~ circled~ number~ #1. }
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;graph TD
invoke(&quot;用户选择使用 Unicode&quot;)
set(&quot;将 tempa 设置为第一个参数&quot;)
if0{&quot;判断 tempa = 0&quot;}
set24ea(&quot;将 tempa 设置为 ⓪(U+24EA)&quot;)
if21{&quot;判断 tempa &amp;lt; 21&quot;}
add245f(&quot;tempa += 0x245F\n将 1-20 对应到 ①(U+2460) 到⑳(U+2473)&quot;)
if36{&quot;判断 tempa &amp;lt; 36&quot;}
add3250(&quot;tempa += 0x3250\n将 21-35 对应到 ㉑(U+3251) 到㉟(U+325F)&quot;)
if51{&quot;判断 tempa &amp;lt; 51&quot;}
add32b0(&quot;tempa += 0x32b0\n将36-50对应到㊱(U+32B1)到㊿(U+32BF)&quot;)

error(&quot;输出 invalid circled number&quot;)
finish(&quot;使用 CJKfamily 输出 tempa&quot;)

invoke --&amp;gt; set --&amp;gt; if0 --&amp;gt;|&quot;N&quot;| if21 --&amp;gt;|&quot;N&quot;| if36 --&amp;gt;|&quot;N&quot;| if51 --&amp;gt; |&quot;N&quot;| error
if0 --&amp;gt;|&quot;Y&quot;| set24ea --&amp;gt; finish
if21 --&amp;gt;|&quot;Y&quot;| add245f --&amp;gt; finish
if36 --&amp;gt;|&quot;Y&quot;| add3250 --&amp;gt; finish
if51 --&amp;gt;|&quot;Y&quot;| add32b0 --&amp;gt; finish

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;%tag tikz-绘制带圈数字
\fp_new:N \l__whu_tikz_circled_number_xscale_fp   % 水平压缩系数
\fp_new:N \l__whu_tikz_circled_number_yscale_fp   % 垂直压缩系数
\dim_new:N \l__whu_tikz_circled_number_total_hegiht_dim   % 数字的总高度
\dim_new:N \l__whu_tikz_circled_number_radius_dim     % 半径

\cs_new:Npn \__whu_tikz_circled_number:n #1
  {
    % 根据数字大小设置压缩系数
    \fp_set:Nn \l__whu_tikz_circled_number_xscale_fp
      {
        \int_compare:nNnTF {#1} &amp;lt; { 10 }
          { 0.9 }
          {
            \int_compare:nNnTF {#1} &amp;lt; { 100 }
              { 0.7 }
              { 0.5 }
          }
      }
    \fp_set:Nn \l__whu_tikz_circled_number_yscale_fp
      {
        \int_compare:nNnTF {#1} &amp;lt; { 10 }
          { 0.9 }
          {
            \int_compare:nNnTF {#1} &amp;lt; { 100 }
              { 0.8 }
              { 0.6 }
          }
      }
    % 获取数字的高度
    \hbox_set:Nn \l_tmpa_box {#1}
    \dim_set:Nn \l__whu_tikz_circled_number_total_hegiht_dim
      { \box_ht:N \l_tmpa_box + \box_dp:N \l_tmpa_box  }
    % 设置圆的半径
    \dim_set:Nn \l__whu_tikz_circled_number_radius_dim
      { \dim_eval:n { \l__whu_tikz_circled_number_total_hegiht_dim / 2 + 0.34 ex } }
    % 绘制
    \tikz [ baseline ]
      {
        \node
          [ inner~sep = 0pt, outer~sep = 0pt ]
          at (0, \dim_use:N \l__whu_tikz_circled_number_total_hegiht_dim / 2 )
          {
            \hbox_set:Nn \l_tmpa_box
              {
                \int_compare:nNnTF {#1} &amp;gt; {9}
                  { \textbf {#1} }
                  {#1}
              }
            \makebox[0.35em][c]
              {
                \box_scale:Nnn \l_tmpa_box
                  { \fp_use:N \l__whu_tikz_circled_number_xscale_fp }
                  { \fp_use:N \l__whu_tikz_circled_number_yscale_fp }
                \box_use_drop:N \l_tmpa_box
              }
          };
        \draw (0, \l__whu_tikz_circled_number_total_hegiht_dim / 2 )
          circle ( \l__whu_tikz_circled_number_radius_dim );
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;tikz 画图硬汉&lt;/p&gt;
&lt;h3&gt;获取宽度与-clist-的内容的最大宽度&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_new:Npn \__whu_get_text_width:Nn #1#2
  {
    \hbox_set:Nn \l__whu_tmpa_box {#2}
    \dim_set:Nn #1 { \box_wd:N \l__whu_tmpa_box }
  }

\cs_generate_variant:Nn \__whu_get_text_width:Nn { NV }

\cs_new:Npn \__whu_get_max_text_width:NN #1#2
  {
    \group_begin:
      \clist_set_eq:NN \l__whu_tmpa_clist #2
      \bool_until_do:nn { \clist_if_empty_p:N \l__whu_tmpa_clist }
        {
          \clist_pop:NN \l__whu_tmpa_clist \l__whu_tmpa_tl
          \__whu_get_text_width:NV \l__whu_tmpa_dim \l__whu_tmpa_tl
          \dim_gset:Nn #1 { \dim_max:nn {#1} { \l__whu_tmpa_dim } }
        }
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;\__whu_get_text_width&lt;/code&gt; 通过设置&lt;code&gt;hbox&lt;/code&gt;的内容为 &lt;code&gt;#2&lt;/code&gt; 获取其宽度并存储在 &lt;code&gt;#1&lt;/code&gt; 中&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\__whu_get_max_text_width:NN&lt;/code&gt; 将列表&lt;code&gt;#2&lt;/code&gt; 的内容依次弹出，然后通过 &lt;code&gt;\__whu_get_text_width&lt;/code&gt;获取其大小并比较，最后将最大的宽度存储在 &lt;code&gt;#1&lt;/code&gt; 中&lt;/p&gt;
&lt;h3&gt;删除章标题中的-\quad&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 删除章标题中的-\quad
\cs_new_protected:Npn \__whu_sanitize_chapter_title:n #1
  {
    \tl_clear:N \l__whu_tmpa_tl
    \tl_set:No \l__whu_tmpa_tl {#1}
    \tl_remove_all:Nn \l__whu_tmpa_tl { \quad }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;\__whu_sanitize_chapter_title&lt;/code&gt; 将 token list &lt;code&gt;#1 &lt;/code&gt; 中的 \quad 全部移除&lt;/p&gt;
&lt;p&gt;这是一个相当有技巧性的写法。通过将 &lt;code&gt;#1&lt;/code&gt; 记 tl 类型并通过 &lt;code&gt;\tl_remove_all&lt;/code&gt; 操作删除其中所有的 &lt;code&gt;\quad&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;不过要注意这样删除之后的&lt;strong&gt;输出在 &lt;code&gt;\l__whu_tmpa_tl&lt;/code&gt; 变量中&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;手动生成章的标题，用于摘要、参考文献等&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 手动生成章的标题，用于摘要、参考文献等
\cs_new_protected:Npn \__whu_chapter:n #1
  {
    \__whu_sanitize_chapter_title:n {#1}
    \group_begin:
      \ctexset { chapter / numbering = false }
      \chapter [ \l__whu_tmpa_tl ] {#1}
    \group_end:
    \__whu_chapter_header:n {#1}
  }
\cs_generate_variant:Nn \__whu_chapter:n { V }

\cs_new_protected:Npn \__whu_chapter_header:n #1
  {
    \bool_if:NTF \g__whu_twoside_bool
      { \markboth {#1} {#1} }
      { \markboth { \hfill #1 \hfill } { } }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于 &lt;code&gt;\__whu_chapter_header&lt;/code&gt;，它判断是否设置了 &lt;code&gt;\g__whu_twoside_bool&lt;/code&gt; 变量，如果设置了则将左右页眉都设为 &lt;code&gt;#1&lt;/code&gt;; 否则则设置单个页眉，并通过两个 &lt;code&gt;\hfill&lt;/code&gt; 居中显示&lt;/p&gt;
&lt;p&gt;再来说 &lt;code&gt;\\__whu_chapter&lt;/code&gt;，它首先在该作用域中关闭了自动编号，接着创建了 &lt;code&gt;#1&lt;/code&gt; 章节，并通过删去 &lt;code&gt;\quad&lt;/code&gt; 的 &lt;code&gt;#1&lt;/code&gt; 作为目录页的索引。最后通过调用 &lt;code&gt;\__whu_chapter_header&lt;/code&gt; 创建页眉&lt;/p&gt;
&lt;h2&gt;处理文档类选项&lt;/h2&gt;
&lt;h3&gt;定义选项&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 选项定义
\keys_define:nn { whu / option }
  {
    type .choice:,
    type .value_required:n = true,
    type .choices:nn =
      { proposal, bachelor, master, doctor }
      {
        \int_gset_eq:NN \g__whu_thesis_type_int \l_keys_choice_int
        \tl_gset_eq:NN \g__whu_thesis_type_tl \l_keys_choice_tl
      },
    type .initial:n = bachelor,
    class .choice:,
    class .value_required:n = true,
    class .choices:nn =
      { academic, professional }
      { \tl_gset_eq:NN \g__whu_thesis_class_tl \l_keys_choice_tl },
    class .initial:n = academic,
    oneside .value_forbidden:n = true,
    twoside .value_forbidden:n = true,
    oneside .code:n =
      {
        \clist_gput_right:Nn \g__whu_to_ctexbook_clist { oneside }
        \bool_set_false:N    \g__whu_twoside_bool
      },
    twoside .code:n =
      {
        \clist_gput_right:Nn \g__whu_to_ctexbook_clist { twoside }
        \bool_set_true:N     \g__whu_twoside_bool
      },
    openany .value_forbidden:n = true,
    openany .code:n =
      {
        \clist_gput_right:Nn \g__whu_to_ctexbook_clist { openany }
      },
    showframe .value_forbidden:n = true,
    showframe .code:n =
      {
        \PassOptionsToPackage { showframe } { geometry }
      },
    draft .choice:,
    draft / true  .code:n =
      {
        \bool_set_true:N     \g__whu_draft_bool
        \clist_gput_right:Nn \g__whu_to_ctexbook_clist { draft }
      },
    draft / false .code:n =
      { \bool_set_false:N    \g__whu_draft_bool },
    draft .default:n = true,
    draft .initial:n = false,
    unknown .code:n = { \__whu_error:n { unknown-option } }
  }
\__whu_msg_new:nn { unknown-option }
  { Class~ option~ &quot;\l_keys_key_str&quot;~ is~ unknown. }
\ProcessKeysOptions { whu / option }

&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;%tag 行距

% 本科的 linespread
\fp_const:Nn \c__whu_bachelor_line_spread_fp
  { \dim_ratio:nn { 23 pt } { 12 bp } / 1.2 }
% 硕士的 linespread
\fp_const:Nn \c__whu_master_line_spread_fp
  { \dim_ratio:nn { 20 bp } { 12 bp } / 1.2 }
% 博士的 linespread
\fp_const:Nn \c__whu_doctor_line_spread_fp
  { \dim_ratio:nn { 20 bp } { 12 bp } / 1.2 }

%tag 字号和行距处理
\int_case:nn { \g__whu_thesis_type_int }
  {
    % 开题报告字号小四
    {1} { \PassOptionsToClass { zihao = -4 } { ctexbook } }
    % 本科小四，23磅
    {2} { \PassOptionsToClass { zihao = -4 , linespread = \c__whu_bachelor_line_spread_fp } { ctexbook } }
    % 硕士小四，20磅
    {3} { \PassOptionsToClass { zihao = -4 , linespread = \c__whu_bachelor_line_spread_fp } { ctexbook } }
    % 博士小四，20磅
    {4} { \PassOptionsToClass { zihao = -4 , linespread = \c__whu_bachelor_line_spread_fp } { ctexbook } }
  }

%tag 页面的单双面设置
\int_case:nn { \g__whu_thesis_type_int }
  {
    % 开题报告：oneside
    {1} { \PassOptionsToClass { oneside } { ctexbook } }
    % 本科：默认 oneside
    {2} { \PassOptionsToClass { oneside } { ctexbook } }
  }

\PassOptionsToClass
  {
    UTF8,
    heading  = true,
    \g__whu_to_ctexbook_clist,
    fontset = none
  }
  { ctexbook }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;一些中规中矩却又容易出错的常量设置&lt;/p&gt;
&lt;p&gt;值得一提的是此处将所有配置都传给了 &lt;code&gt;ctexbook&lt;/code&gt; 包，包括:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;字号 zhihao&lt;/li&gt;
&lt;li&gt;行距倍数 linespread &lt;a href=&quot;%5BLaTeX%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0(5)-%E8%A1%8C%E8%B7%9D%5D(https://zhuanlan.zhihu.com/p/138408387)&quot;&gt;^2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;编码&lt;/li&gt;
&lt;li&gt;字体集&lt;/li&gt;
&lt;li&gt;外部配置 &lt;code&gt;g__whu_to_ctexbook_clist&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于行距倍数，这里通过 &lt;code&gt;\dim_radion:nn&lt;/code&gt; 进行了单位换算。以本科为例：当字号为小四(12pt)时，23磅间距是指 &lt;code&gt;23pt / 12pb&lt;/code&gt; 倍&lt;/p&gt;
&lt;p&gt;对于 ctexbook，它的 layout&lt;a href=&quot;%5B%E4%B8%AD%E6%96%87%E7%89%88%E5%BF%83%E8%AE%BE%E8%AE%A1%E7%9A%84%E7%96%91%E9%9A%BE%E4%B8%8E%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%5D(https://github.com/CTeX-org/forum/issues/47#issuecomment-511120397)&quot;&gt;^3&lt;/a&gt; 是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;61171943-ded48a00-a56d-11e9-8d03-e1dfd52e742c.png&quot; alt=&quot;issue-geometry-origin&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;给预加载的宏包传递选项&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 给预加载的宏包传递选项
\clist_map_inline:nn
  {
    { no-math  } { fontspec },
    { numbered } { bookmark },
    { titles   } { tocloft  },
    { perpage  } { footmisc }
  }
  { \PassOptionsToPackage #1 }

\RequirePackage { filehook }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;消去 CJK 警告&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\AtEndOfPackageFile* { fontspec }
  { \msg_redirect_name:nnn { fontspec } { no-script } { none } }
\AtEndOfPackageFile* { xeCJK }
  {
    \msg_redirect_name:nnn { xeCJK } { CJKfamily-redef } { none }
    \defaultCJKfontfeatures { Script  = CJK }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在包执行结束后进行消息重定向，以达到丢弃消息的目的&lt;/p&gt;
&lt;h3&gt;加载包&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\LoadClass { ctexbook }

%tag 加载宏包 (in alphabetic order)
\RequirePackage { amsmath }
\RequirePackage { amssymb }
\RequirePackage { amsthm }
\RequirePackage { bookmark }
\RequirePackage { booktabs }
\RequirePackage { caption }
\RequirePackage { enumitem }
\RequirePackage { etoolbox }
\RequirePackage { fancyhdr }
\RequirePackage { fixdif }
\RequirePackage { fontspec }
\RequirePackage { footmisc }
\RequirePackage { geometry }
\RequirePackage { graphicx }
\RequirePackage { thmtools }
\RequirePackage { tikzpagenodes }
\RequirePackage { tocloft }
\RequirePackage { xeCJK }
\RequirePackage { xeCJKfntef }

\AtEndPreamble
  {
    \RequirePackage { hyperref }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;页面尺寸设置&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;%region 页面尺寸设置 (paper size setting)
% 统一都是 A4 纸大小
\geometry{paper = a4paper}

%tag 开题报告
\cs_new:Npn \__whu_proposal_set_paper_size:
  {
    \geometry
      {
        left       = 31.75mm,
        right      = 31.75mm,
        top        = 25.4mm,
        bottom     = 25.4mm,
        headheight = 0pt,
        headsep    = 0pt
      }
  }
%tag 本科
\cs_new:Npn \__whu_bachelor_set_paper_size:
  {
    \geometry
      {
        left       = 31.8mm,
        right      = 31.8mm,
        top        = 25.4mm,
        bottom     = 25.4mm,
        headheight = 3mm,
        headsep    = 2mm,
        footskip   = 6mm
      }
  }
%tag 硕士
\cs_new:Npn \__whu_master_set_paper_size:
  {
    \geometry
      {
        left       = 28mm,
        right      = 25mm,
        top        = 30mm,
        bottom     = 29mm,
        headheight = 15pt
      }
  }
%tag 博士
\cs_new:Npn \__whu_doctor_set_paper_size:
  {
    \geometry
      {
        left       = 28mm,
        right      = 25mm,
        top        = 30mm,
        bottom     = 29mm,
        headheight = 15pt
      }
  }

\int_case:Vn \g__whu_thesis_type_int
  {
    % 开题报告
    {1} { \__whu_proposal_set_paper_size: }
    % 本科
    {2} { \__whu_bachelor_set_paper_size: }
    % 硕士
    {3} { \__whu_master_set_paper_size: }
    % 博士
    {4} { \__whu_doctor_set_paper_size: }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;处理图书馆版本选项&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;%region 图书馆版本 去除所有空白页
\keys_define:nn { whu / style }
  {
    library .bool_gset:N = \g__whu_library_version_bool,
    library .initial:n   = false,
    library .default:n   = true,
  }
\ctex_after_end_preamble:n
{
  \bool_if:NT \g__whu_library_version_bool
  {
    \cs_set_eq:NN \__whu_new_blank_page: \newpage
    \renewcommand{\cleardoublepage}{\clearpage}
  }
}
%endregion 图书馆版本
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果启用了 &lt;code&gt;library&lt;/code&gt; 选项，则在接下来的代码中用 &lt;code&gt;\clearpage&lt;/code&gt; 取代 &lt;code&gt;\cleardoublepage&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\cleardouble&lt;/code&gt; 和 &lt;code&gt;\clearpage&lt;/code&gt; 在大部分时间是一致的，但 &lt;code&gt;\cleardoublepage&lt;/code&gt; 同时还会检查页码。如果当前的页码是奇数并且 typesettings 是 &lt;code&gt;twosided&lt;/code&gt; 时，&lt;code&gt;\cleardoublepage&lt;/code&gt; 还会再多插入一页，使新的一页仍是奇数页[^5]。如果启用了 &lt;code&gt;library&lt;/code&gt; 选项，则不会再新插入一页&lt;/p&gt;
&lt;p&gt;[^5]: &lt;a href=&quot;https://tex.stackexchange.com/questions/497746/comparison-between-newpage-clearpage-and-pagebreak-etc&quot;&gt;Comparison between \newpage, \clearpage and \pagebreak, etc.?&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;字体配置&lt;/h2&gt;
&lt;h3&gt;字体配置预备函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_new_protected:Npn \__whu_set_cjk_main_font:nn #1#2
  {
    \setCJKmainfont{#1}[#2]
    \newCJKfontfamily [zhsong] \songti {#1} [#2]
  }
\cs_new_protected:Npn \__whu_set_cjk_sans_font:nn #1#2
  {
    \setCJKsansfont{#1}[#2]
    \newCJKfontfamily [zhhei] \heiti {#1} [#2]
  }
\cs_new_protected:Npn \__whu_set_cjk_mono_font:nn #1#2
  {
    \setCJKmonofont{#1}[#2]
    \newCJKfontfamily [zhfs] \fangsong {#1} [#2]
  }
\cs_new_protected:Npn \__whu_set_cjk_font_kaishu:nn #1#2
  {
    \newCJKfontfamily [zhkai] \kaishu {#1} [#2]
  }
\tl_const:Nn \l__whu_cjk_font_options_tl { UprightFont = *, ItalicFont = *, AutoFakeBold }
\cs_new_protected:Npx \__whu_set_cjk_main_font:n #1
  { \__whu_set_cjk_main_font:nn {#1} { \l__whu_cjk_font_options_tl } }
\cs_new_protected:Npx \__whu_set_cjk_sans_font:n #1
  { \__whu_set_cjk_sans_font:nn {#1} { \l__whu_cjk_font_options_tl } }
\cs_new_protected:Npx \__whu_set_cjk_mono_font:n #1
  { \__whu_set_cjk_mono_font:nn {#1} { \l__whu_cjk_font_options_tl } }
\cs_new_protected:Npx \__whu_set_cjk_font_kaishu:n #1
  { \__whu_set_cjk_font_kaishu:nn {#1} { \l__whu_cjk_font_options_tl } }

\bool_new:N \g__whu_style_cjk_fakefont_bool
\tl_new:N \g__whu_style_math_font_choice_tl
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提供了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\__whu_set_cjk_main_font:nn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_set_cjk_sans_font:nn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_set_cjk_mono_font:nn&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_set_cjk_font_kaishu:nn&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用于设置字体&lt;/p&gt;
&lt;h3&gt;字体配置项&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 定义键
\keys_define:nn { whu / style }
  {
    font .choices:nn =
      { times, xits, termes, default }
      { \cs_gset_eq:Nc \__whu_style_font_use: { __whu_style_font_set_ \l_keys_choice_tl : } },
    font .value_required:n = true,
    math-font .choices:nn =
      { xits, termes, default }
      {
        \cs_gset_eq:Nc \__whu_style_math_font_use: { __whu_style_math_font_set_ \l_keys_choice_tl : }
        \tl_gset_eq:NN \g__whu_style_math_font_choice_tl \l_keys_choice_tl
      },
    math-font .value_required:n = true,
    cjk-font .choices:nn =
      { windows, mac, fandol, sourcehan, founder, none }
      { \cs_gset_eq:Nc \__whu_style_cjk_font_use: { __whu_style_cjk_font_set_ \l_keys_choice_tl : } },
    cjk-font .value_required:n = true,
    cjk-fakefont .bool_set:N = \g__whu_style_cjk_fakefont_bool,
    cjk-fakefont .default:n = true
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;whu/style&lt;/code&gt; 中添加了多个与字体相关的项，在设置该项时会调阅&lt;a href=&quot;#%E5%AD%97%E4%BD%93%E9%85%8D%E7%BD%AE%E9%A2%84%E5%A4%87%E5%87%BD%E6%95%B0&quot;&gt;前面的&lt;/a&gt;配置语句&lt;/p&gt;
&lt;h3&gt;西文字体配置预备函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%region 西文字体设置 (english font setting)
%tag times
\cs_new_protected:Npn \__whu_style_font_set_times:
  {
    \setmainfont { Times ~ New ~ Roman }
      [
        SmallCapsFont = { TeX ~ Gyre ~ Termes },
        SmallCapsFeatures = { Letters = SmallCaps }
      ]
  }
%tag xits
\cs_new_protected:Npn \__whu_style_font_set_xits:
  {
    \setmainfont { XITS }
      [
        Extension      = .otf,
        UprightFont    = *-Regular,
        BoldFont       = *-Bold,
        ItalicFont     = *-Italic,
        BoldItalicFont = *-BoldItalic
      ]
  }
%tag termes
\cs_new_protected:Npn \__whu_style_font_set_termes:
  {
    \setmainfont { texgyretermes }
      [
        Extension      = .otf,
        UprightFont    = *-regular,
        BoldFont       = *-bold,
        ItalicFont     = *-italic,
        BoldItalicFont = *-bolditalic
      ]
  }
\cs_new_protected:Npn \__whu_style_font_set_default: { }
%endregion 西文字体设置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提供&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\__whu_style_font_set_times&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_style_font_set_xits&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_style_font_set_terms&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;用于设置西文字体&lt;/p&gt;
&lt;h3&gt;数学字体预备函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 数学字体设置 (math font setting)
\cs_new_protected:Npn \__whu_style_math_font_set_xits:
  {
    \setmathfont { XITSMath-Regular.otf }
      [
        BoldFont     = XITSMath-Bold.otf,
      ]
    \setmathfont { XITSMath-Regular.otf }
      [
        range        = {cal, bfcal},
        StylisticSet = 01
      ]
  }
\cs_new_protected:Npn \__whu_style_math_font_set_termes:
  {
    \setmathfont { texgyretermes-math.otf }
  }
\cs_new_protected:Npn \__whu_style_math_font_set_default: { }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;中文字体预备函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%region 中文字体设置 (chinese font setting)
%tag default
\cs_new_protected:Npn \__whu_style_cjk_font_set_none: { }
%tag windows
\cs_new_protected:Npn \__whu_style_cjk_font_set_windows:
  {
    \bool_if:NTF \g__whu_style_cjk_fakefont_bool
      {
        \__whu_set_cjk_main_font:nn { SimSun }
          { AutoFakeBold = 4, AutoFakeSlant = 0.167 }
        \__whu_set_cjk_sans_font:nn { SimHei }
          { AutoFakeBold = 4, AutoFakeSlant = 0.167 }
        \__whu_set_cjk_mono_font:nn { FangSong }
          { AutoFakeBold = 4, AutoFakeSlant = 0.167 }
        \__whu_set_cjk_font_kaishu:nn { KaiTi }
          { AutoFakeBold = 4, AutoFakeSlant = 0.167 }
      }
      {
        \__whu_set_cjk_main_font:nn { SimSun }
          {
            BoldFont       = SimHei,
            ItalicFont     = KaiTi,
            SlantedFont    = KaiTi,
            BoldItalicFont = SimHei
          }
        \__whu_set_cjk_sans_font:nn { SimHei }
          { BoldFont = *, ItalicFont = *, SlantedFont = *, BoldItalicFont = * }
        \__whu_set_cjk_mono_font:nn { FangSong }
          { BoldFont = *, ItalicFont = *, SlantedFont = *, BoldItalicFont = * }
        \__whu_set_cjk_font_kaishu:nn { KaiTi }
          { BoldFont = *, ItalicFont = *, SlantedFont = *, BoldItalicFont = * }
      }
  }
%tag mac
\cs_new_protected:Npn \__whu_style_cjk_font_set_mac:
  {
    \bool_if:NTF \g__whu_style_cjk_fakefont_bool
      {
        \__whu_set_cjk_main_font:nn { Songti~ SC~ Light }
          {
            BoldFont       = Songti~ SC~ Bold,
            AutoFakeSlant  = 0.167
          }
        \__whu_set_cjk_sans_font:nn { Heiti~ SC~ Light }
          {
            BoldFont      = Heiti~ SC~ Medium,
            AutoFakeSlant = 0.167
          }
        \__whu_set_cjk_mono_font:nn { STFangsong }
          { AutoFakeBold = 4, AutoFakeSlant = 0.167 }
        \__whu_set_cjk_font_kaishu:nn { Kaiti~ SC~ Regular }
          {
            BoldFont      = Kaiti~ SC~ Bold,
            AutoFakeSlant = 0.167
          }
      }
      {
        \__whu_set_cjk_main_font:nn { Songti~ SC~ Light }
          {
            BoldFont       = Songti~ SC~ Bold,
            ItalicFont     = Kaiti~ SC~ Regular,
            SlantedFont    = Kaiti~ SC~ Regular,
            BoldItalicFont = Songti~ SC~ Bold
          }
        \__whu_set_cjk_sans_font:nn { Heiti~ SC~ Light }
          {
            BoldFont       = Heiti~ SC~ Medium,
            ItalicFont     = *,
            SlantedFont    = *,
            BoldItalicFont = Heiti~ SC~ Medium
          }
        \__whu_set_cjk_mono_font:nn { STFangsong }
          { BoldFont = *, ItalicFont = *, SlantedFont = *, BoldItalicFont = * }
        \__whu_set_cjk_font_kaishu:nn { Kaiti~ SC~ Regular }
          {
            BoldFont       = Kaiti~ SC~ Bold,
            ItalicFont     = *,
            SlantedFont    = *,
            BoldItalicFont = Kaiti~ SC~ Bold
          }
      }
  }
%tag fandol
\cs_new_protected:Npn \__whu_style_cjk_font_set_fandol:
  {
    \bool_if:NTF \g__whu_style_cjk_fakefont_bool
      {
        \__whu_set_cjk_main_font:nn { FandolSong-Regular.otf }
          {
            BoldFont      = FandolSong-Bold.otf,
            AutoFakeSlant = 0.167
          }
        \__whu_set_cjk_sans_font:nn { FandolHei-Regular.otf }
          {
            BoldFont      = FandolHei-Bold.otf,
            AutoFakeSlant = 0.167
          }
        \__whu_set_cjk_mono_font:nn { FandolFang-Regular.otf }
          { AutoFakeBold = 4, AutoFakeSlant = 0.167 }
        \__whu_set_cjk_font_kaishu:nn { FandolKai-Regular.otf }
          { AutoFakeBold = 4, AutoFakeSlant = 0.167 }
      }
      {
        \__whu_set_cjk_main_font:nn { FandolSong-Regular.otf }
          {
            BoldFont       = FandolSong-Bold.otf,
            ItalicFont     = FandolKai-Regular.otf,
            SlantedFont    = FandolKai-Regular.otf,
            BoldItalicFont = FandolSong-Bold.otf
          }
        \__whu_set_cjk_sans_font:nn { FandolHei-Regular.otf }
          {
            BoldFont       = FandolHei-Bold.otf,
            ItalicFont     = *,
            SlantedFont    = *,
            BoldItalicFont = FandolHei-Bold.otf
          }
        \__whu_set_cjk_mono_font:nn { FandolFang-Regular.otf }
          { BoldFont = *, ItalicFont = *, SlantedFont = *, BoldItalicFont = * }
        \__whu_set_cjk_font_kaishu:nn { FandolKai-Regular.otf }
          { BoldFont = *, ItalicFont = *, SlantedFont = *, BoldItalicFont = * }
      }
  }
%tag founder
\cs_new_protected:Npn \__whu_style_cjk_font_set_founder:
  {
    \__whu_set_cjk_main_font:nn  { FZShuSong-Z01  } { BoldFont = FZHei-B01, ItalicFont = FZKai-Z03 }
    \__whu_set_cjk_sans_font:n   { FZHei-B01      }
    \__whu_set_cjk_mono_font:n   { FZFangSong-Z02 }
    \__whu_set_cjk_font_kaishu:n { FZKai-Z03      }
  }
%tag source-han
\cs_new_protected:Npn \__whu_style_cjk_font_set_sourcehan:
  {
    \bool_if:NTF \g__whu_style_cjk_fakefont_bool
      {
        \__whu_set_cjk_main_font:nn { Source~ Han~ Serif~ SC }
          {
            UprightFont   = *-Regular,
            BoldFont      = *-Bold,
            AutoFakeSlant = 0.167
          }
        \__whu_set_cjk_sans_font:nn { Source~ Han~ Sans~ SC }
          {
            UprightFont   = *-Regular,
            BoldFont      = *-Bold,
            AutoFakeSlant = 0.167
          }
        \__whu_set_cjk_font_kaishu:nn { FZKai-Z03 }
          { AutoFakeBold = 4, AutoFakeSlant = 0.167 }
        \__whu_set_cjk_mono_font:nn { FZFangSong-Z02 }
          { AutoFakeBold = 4, AutoFakeSlant = 0.167 }
      }
      {
        \__whu_set_cjk_main_font:nn { Source~ Han~ Serif~ SC }
          {
            UprightFont    = *-Regular,
            BoldFont       = *-Bold,
            ItalicFont     = *-Regular,
            BoldItalicFont = *-Bold
          }
        \__whu_set_cjk_sans_font:nn { Source~ Han~ Sans~ SC }
          {
            UprightFont    = *-Regular,
            BoldFont       = *-Bold,
            ItalicFont     = *-Regular,
            BoldItalicFont = *-Bold
          }
        \__whu_set_cjk_font_kaishu:nn { FZKai-Z03 }
          {
            BoldFont       = *,
            ItalicFont     = *,
            BoldItalicFont = *
          }
        \__whu_set_cjk_mono_font:nn { FZFangSong-Z02 }
          {
            BoldFont       = *,
            ItalicFont     = *,
            BoldItalicFont = *
          }
      }
  }
%endregion 中文字体设置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;提供设置中文字体的方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\__whu_style_cjk_font_set_none&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_style_cjk_font_set_windows&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_style_cjk_font_set_mac&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_style_cjk_font_set_fandol&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_style_cjk_font_set_founder&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\__whu_style_cjk_font_set_sourcehan&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用字体[^6]&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 使用字体 (use font)
\AtEndPreamble
  {
    \tl_if_eq:NnTF \g__whu_style_math_font_choice_tl {default}
      {
        \RequirePackage{mathrsfs}
        \DeclareFontFamily{U}{rsfs}{\skewchar\font127 }
        \DeclareFontShape{U}{rsfs}{m}{n}{
          &amp;lt;5-6&amp;gt; rsfs5
          &amp;lt;6-8&amp;gt; rsfs7
          &amp;lt;8-&amp;gt; rsfs10
        }{}
      }
      {
        \RequirePackage [ bold-style = ISO ] { unicode-math }
      }
    \__whu_style_font_use:
    \__whu_style_math_font_use:
    \__whu_style_cjk_font_use:
  }
%tag 设置默认字体
\keys_set:nn { whu / style }
  {
    font         = times,
    math-font    = termes,
    cjk-font     = fandol,
    cjk-fakefont = false,
  }
%endregion 字体配置
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;[^6]: &lt;a href=&quot;http://mirrors.ibiblio.org/CTAN/macros/latex/contrib/etoolbox/etoolbox.pdf&quot;&gt;etoolbox book&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在 preamble 的最后（&lt;code&gt;\documentclass&lt;/code&gt; 命令和 &lt;code&gt;\begin{document}&lt;/code&gt; 命令之间）添加字体使用语句&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;\g__whu_style_math_font_choice_tl&lt;/code&gt; 为 &lt;code&gt;default&lt;/code&gt; 时使用 &lt;code&gt;Ralph Smith&apos;s Formal Script&lt;/code&gt; 字体。接下来声明了一个名为 &lt;code&gt;rsfs&lt;/code&gt; 的字体族（font family），并设置了其 skew 字符（倾斜字符）为 127。这个设置可以确保字体在倾斜时不会出现问题。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\DeclareFontShape{U}{rsfs}{m}{n}{...}&lt;/code&gt;：这行命令用于声明字体的形状（font shape），这里的 &lt;code&gt;U&lt;/code&gt; 表示使用 Unicode 编码，&lt;code&gt;rsfs&lt;/code&gt; 是字体族名称，&lt;code&gt;m&lt;/code&gt; 表示字体系列（font series），&lt;code&gt;n&lt;/code&gt; 表示字体形状（font shape）。&lt;/p&gt;
&lt;p&gt;在大括号内的 &lt;code&gt;&amp;lt;5-6&amp;gt; rsfs5&lt;/code&gt;、&lt;code&gt;&amp;lt;6-8&amp;gt; rsfs7&lt;/code&gt; 和 &lt;code&gt;&amp;lt;8-&amp;gt; rsfs10&lt;/code&gt; 分别表示字体大小的范围和对应的字体文件。它们表示：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于字体大小在 5pt 到 6pt 之间的情况，使用 &lt;code&gt;rsfs5&lt;/code&gt; 字体文件；&lt;/li&gt;
&lt;li&gt;对于字体大小在 6pt 到 8pt 之间的情况，使用 &lt;code&gt;rsfs7&lt;/code&gt; 字体文件；&lt;/li&gt;
&lt;li&gt;对于字体大小大于等于 8pt 的情况，使用 &lt;code&gt;rsfs10&lt;/code&gt; 字体文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;章节标题设置与列表设置&lt;/h2&gt;
&lt;h3&gt;移除列表垂直间距&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\setlist{nosep}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;设置列表（&lt;code&gt;enumerate&lt;/code&gt;、&lt;code&gt;itemize&lt;/code&gt; 和 &lt;code&gt;description&lt;/code&gt; 环境）的垂直间距为零&lt;/p&gt;
&lt;h3&gt;配置 ctex&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 开题报告
\cs_new:Npn \__whu_proposal_report_set_ctex_format:
  {
    \keys_set:nn { ctex }
      {
        chapter =
          {
            numbering   = false,
            format      = \zihao{2}\bfseries\centering,
            beforeskip  = -3.5ex,
            afterskip   = 5ex plus 1ex minus 1ex,
            pagestyle   = empty,
            titleformat = \__whu_spread_box_with_quad:n
          },
        section =
          {
            number      = \chinese{section},
            name        = {,、},
            aftername   = {},
            format      = \zihao{4}
          }
    }
  }

%tag 本科毕业论文（设计）任务书
\cs_new:Npn \__whu_proposal_tasks_set_ctex_format:
  {
    \keys_set:nn { ctex }
      {
        chapter =
          {
            numbering   = false,
            format      = \zihao{3}\bfseries\centering,
            beforeskip  = 3ex,
            afterskip   = 7.5ex,
            pagestyle   = empty
          },
        section =
          {
            number      = \chinese{section},
            name        = {,、},
            aftername   = {},
            format      = \zihao{4}
          }
    }
  }

%tag 本科
\cs_new:Npn \__whu_bachelor_set_ctex_format:
  {
    \keys_set:nn { ctex }
      {
        % 编号到 subsubsection
        secnumdepth = 3,
        chapter =
          {
            format       = \zihao{-2}\sffamily\centering,
            number       = \arabic{chapter},
            numberformat = \rmfamily,
            name         = {},
            beforeskip   = 0.8 \baselineskip,
            afterskip    = 0.5 \baselineskip,
            fixskip      = true,
            pagestyle    = bachelor-mainmatter
          },
        section =
          {
            format       = \zihao{4}\sffamily,
            numberformat = \rmfamily,
            beforeskip   = 0.5 \baselineskip,
            afterskip    = 0.5 \baselineskip,
            fixskip      = true,
          },
        subsection =
          {
            format       = \zihao{-4}\sffamily,
            numberformat = \rmfamily,
            beforeskip   = 0.5 \baselineskip,
            afterskip    = 0.5 \baselineskip,
            fixskip      = true,
          },
        subsubsection =
          {
            format       = \zihao{-4}\sffamily,
            numberformat = \rmfamily,
            beforeskip   = 0.5 \baselineskip,
            afterskip    = 0.5 \baselineskip,
            fixskip      = true,
          },
    }
  }
\cs_new:Npn \__whu_bachelor_set_enumerate_format:
  {
    % enumerate
    \setenumerate[1]
      {
        labelindent    = \parindent,
        leftmargin     = 0pt,
        widest         = 0,
        itemindent     = *,
        listparindent  = \parindent,
        label          = (\arabic*)
      }
    \setenumerate[2]
      {
        labelindent    = \parindent,
        leftmargin     = 4em,
        itemindent     = 13pt,
        listparindent  = \parindent,
        label          = \circlednumber{\arabic*}
      }
  }
%tag 硕士
\cs_new:Npn \__whu_master_set_ctex_format:
  {
    \keys_set:nn { ctex }
      {
        % 编号到 subsubsection
        secnumdepth = 3,
        chapter =
          {
            format      = \zihao{-2}\sffamily\raggedright,
            number      = \arabic{chapter},
            name        = {},
            beforeskip  = 4 ex plus 0.5 ex,
            afterskip   = 4 ex plus 0.5 ex,
            fixskip     = true,
          },
        section =
          {
            format      = \zihao{4}\sffamily,
            % beforeskip  = 0.5 \baselineskip,
            % afterskip   = 0.5 \baselineskip,
            fixskip     = true,
          },
        subsection =
          {
            format      = \zihao{-4}\sffamily,
            % beforeskip  = 0.5 \baselineskip,
            % afterskip   = 0.5 \baselineskip,
            fixskip     = true,
          },
        subsubsection =
          {
            format      = \zihao{-4}\sffamily,
            % beforeskip  = 0.5 \baselineskip,
            % afterskip   = 0.5 \baselineskip,
            fixskip     = true,
          },
    }
  }
\cs_new:Npn \__whu_master_set_enumerate_format:
  {
    % enumerate
    \setenumerate[1]
      {
        labelindent    = \parindent,
        leftmargin     = 0pt,
        widest         = 0,
        itemindent     = *,
        listparindent  = \parindent,
        label          = (\arabic*)
      }
    \setenumerate[2]
      {
        labelindent    = \parindent,
        leftmargin     = 4em,
        itemindent     = 13pt,
        listparindent  = \parindent,
        label          = \roman{*}.
      }
  }
%tag 博士
\cs_new:Npn \__whu_doctor_set_ctex_format:
  {
    \keys_set:nn { ctex }
      {
        % 编号到 subsubsection
        secnumdepth = 3,
        chapter =
          {
            format      = \zihao{-2}\sffamily\raggedright,
            number      = \arabic{chapter},
            name        = {},
            beforeskip  = 4 ex plus 0.5 ex,
            afterskip   = 4 ex plus 0.5 ex,
            fixskip     = true,
          },
        section =
          {
            format      = \zihao{4}\sffamily,
            % beforeskip  = 0.5 \baselineskip,
            % afterskip   = 0.5 \baselineskip,
            fixskip     = true,
          },
        subsection =
          {
            format      = \zihao{-4}\sffamily,
            % beforeskip  = 0.5 \baselineskip,
            % afterskip   = 0.5 \baselineskip,
            fixskip     = true,
          },
        subsubsection =
          {
            format      = \zihao{-4}\sffamily,
            % beforeskip  = 0.5 \baselineskip,
            % afterskip   = 0.5 \baselineskip,
            fixskip     = true,
          },
    }
  }
\cs_new:Npn \__whu_doctor_set_enumerate_format:
  {
    % enumerate
    \setenumerate[1]
      {
        labelindent    = \parindent,
        leftmargin     = 0pt,
        widest         = 0,
        itemindent     = *,
        listparindent  = \parindent,
        label          = (\arabic*)
      }
    \setenumerate[2]
      {
        labelindent    = \parindent,
        leftmargin     = 4em,
        itemindent     = 13pt,
        listparindent  = \parindent,
        label          = \roman{*}.
      }
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;创建不同的函数用于适配不同的用途，主要包含以下属性:&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Desc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;chapter/numbering&lt;/td&gt;
&lt;td&gt;章节编号&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chapter/format&lt;/td&gt;
&lt;td&gt;章节标题格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chapter/number&lt;/td&gt;
&lt;td&gt;章编号内容，例如阿拉伯数字、罗马数字等&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chapter/numberformat&lt;/td&gt;
&lt;td&gt;章编号格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chapter/beforeskip&lt;/td&gt;
&lt;td&gt;章节标题之前的垂直间距，设置为负数即向上移动&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chapter/afterskip&lt;/td&gt;
&lt;td&gt;章节标题之后的垂直间距。 &lt;code&gt;5ex plus 1ex minus 1ex&lt;/code&gt; 意为5 行高，最多扩展 1 行高，最少减少 1 行高&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chapter/pagestyle&lt;/td&gt;
&lt;td&gt;章节页眉页脚样式设置为空白&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chapter/titleformat&lt;/td&gt;
&lt;td&gt;章节标题的格式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;chapter/fixskip&lt;/td&gt;
&lt;td&gt;调整章标题前后的垂直间距&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;对于 &lt;code&gt;section&lt;/code&gt;、&lt;code&gt;subsection&lt;/code&gt;、&lt;code&gt;subsubsection&lt;/code&gt; 等同理&lt;/p&gt;
&lt;p&gt;作者分别通过下列函数进行设置&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Desc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\__whu_proposal_report_set_ctex_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;开题报告&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\__whu_proposal_tasks_set_ctex_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;本科毕业论文（设计）任务书&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\__whu_bachelor_set_ctex_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;本科&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\__whu_master_set_ctex_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;硕士&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\__whu_doctor_set_ctex_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;博士&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;除此之外还通过 &lt;code&gt;\setenumerate&lt;/code&gt; 设置了列表项样式&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Key&lt;/th&gt;
&lt;th&gt;Desc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;labelindent&lt;/td&gt;
&lt;td&gt;标签缩进&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;leftmargin&lt;/td&gt;
&lt;td&gt;左侧边距&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;widest&lt;/td&gt;
&lt;td&gt;最宽项&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;itemindent&lt;/td&gt;
&lt;td&gt;项目缩进设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;listparindent&lt;/td&gt;
&lt;td&gt;段落缩进量&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;label&lt;/td&gt;
&lt;td&gt;标签格式设置(如罗马数字)&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Name&lt;/th&gt;
&lt;th&gt;Desc&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\__whu_bachelor_set_enumerate_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;本科列表样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\__whu_master_set_enumerate_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;硕士列表样式&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;\__whu_doctor_set_enumerate_format&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;博士列表样式&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;判断论文种类&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\int_case:Vn \g__whu_thesis_type_int
  {
    % 本科
    {2}
      {
        \__whu_bachelor_set_enumerate_format:
        \__whu_bachelor_set_ctex_format:
      }
    % 硕士
    {3}
      {
        \__whu_master_set_enumerate_format:
        \__whu_master_set_ctex_format:
      }
    % 博士
    {4}
      {
        \__whu_doctor_set_enumerate_format:
        \__whu_doctor_set_ctex_format:
      }
  }

\NewDocumentCommand { \ProposalTasks } { O{武汉大学本科毕业论文（设计）任务书} }
  {
    \__whu_proposal_tasks_set_ctex_format:
    \chapter{#1}
    \int_set:Nn \c@section {0}
  }
\NewDocumentCommand { \ProposalReport } { O{开题报告} }
  {
    \__whu_proposal_report_set_ctex_format:
    \chapter{#1}
    \int_set:Nn \c@section {0}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先对本科、硕士和博士论文分别进行样式设置。然后创建了两个命令，分别是 &lt;code&gt;\ProposalTasks&lt;/code&gt; 和 &lt;code&gt;\ProposalReport&lt;/code&gt;。这两个命令接受一个参数，并具有一个默认值。在命令的实现中首先设置了相关样式，接着以传递参数创建了一个章节，并在之后重置了计数器 &lt;code&gt;\c@section&lt;/code&gt; 。这样新的章节开始后，下一个节的编号将从 1 开始。&lt;/p&gt;
&lt;h2&gt;页眉页脚样式&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;%region 页眉页脚样式
%tag 本科
\fancypagestyle { bachelor-frontmatter }
  {
    \fancyhf { }
    \fancyfoot[C] { \zihao{5} \Roman{page} }
    \renewcommand \headrulewidth { 0pt }
  }
\fancypagestyle { bachelor-mainmatter }
  {
    \fancyhf { }
    \fancyfoot[C] { \zihao{5} \arabic{page} }
    \fancyhead[C] { \zihao{5} \__whu_spread_box:nn {8cm} {武汉大学本科毕业论文（设计）}}
    \renewcommand \headrulewidth { 0.5pt }
    \setlength{\headheight}{13pt}
  }
%tag 硕士
% 页眉从中文摘要开始至论文末，偶数页码内容为：武汉大学硕士学位论文，奇数页码内容为学位论文题目。
% 摘要页码用罗马数字单独编排，并标注在每页页脚中部，英文摘要页码续接中文摘要的页码。
\fancypagestyle { master-frontmatter }
  {
    \fancyhf { }
    \fancyhead [CE] { 武汉大学硕士学位论文 }
    \fancyhead [CO] { \l__whu_info_title_tl }
    \fancyfoot [C]  { \zihao{5} \Roman{page} }
  }
\fancypagestyle { master-mainmatter  }
  {
    \fancyhf { }
    \fancyhead [CE] { 武汉大学硕士学位论文 }
    \fancyhead [CO] { \l__whu_info_title_tl }
    \fancyfoot [C]  { \zihao{5} \arabic{page} }
  }
%tag 博士
% 页眉从中文摘要开始至论文末，偶数页码内容为“武汉大学博士学位论文”，奇数页码内容为学位论文题目。
\fancypagestyle { doctor-frontmatter }
  {
    \fancyhf { }
    \fancyhead [CE] { 武汉大学博士学位论文 }
    \fancyhead [CO] { \l__whu_info_title_tl }
    \fancyfoot [C]  { \zihao{5} \Roman{page} }
  }
\fancypagestyle { doctor-mainmatter  }
  {
    \fancyhf { }
    \fancyhead [CE] { 武汉大学博士学位论文 }
    \fancyhead [CO] { \l__whu_info_title_tl }
    \fancyfoot [C]  { \zihao{5} \arabic{page} }
  }
%tag 给-\mainmatter-添加钩子
\AddToHook{ cmd / mainmatter / after }
  { \exp_args:No \pagestyle { \g__whu_thesis_type_tl - mainmatter } }
%endregion

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;\fancyhf&lt;/code&gt; 用于清除当前的页眉页脚设置，然后调用 &lt;code&gt;\fancyhead&lt;/code&gt; 设置页眉也页脚。在页眉和页脚的设置中，&lt;code&gt;C&lt;/code&gt; 表示居中，类似的有 &lt;code&gt;L&lt;/code&gt; 和 &lt;code&gt;R&lt;/code&gt;。&lt;code&gt;E&lt;/code&gt; 和 &lt;code&gt;O&lt;/code&gt; 表示 even 和 odd&lt;/p&gt;
&lt;p&gt;在最后使用 &lt;code&gt;\AddToHook&lt;/code&gt;在 &lt;code&gt;cmd/mainmatter/after&lt;/code&gt;之后执行 &lt;code&gt;\pagestyle&lt;/code&gt; 设置相关样式，其目的是统一后记 (backmatter) 的样式与 mainmatter&lt;/p&gt;
&lt;h2&gt;个人信息配置项&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;%region 个人信息
%tag 定义键
\keys_define:nn { whu / info }
  {
    title           .tl_set:N = \l__whu_info_title_tl,
    title*          .tl_set:N = \l__whu_info_title_en_tl,
    department      .tl_set:N = \l__whu_info_department_tl,
    department*     .tl_set:N = \l__whu_info_department_en_tl,
    student-id      .tl_set:N = \l__whu_info_student_id_tl,
    author          .tl_set:N = \l__whu_info_author_tl,
    author*         .tl_set:N = \l__whu_info_author_en_tl,
    subject         .tl_set:N = \l__whu_info_subject_tl,
    subject*        .tl_set:N = \l__whu_info_subject_en_tl,
    major           .tl_set:N = \l__whu_info_major_tl,
    major*          .tl_set:N = \l__whu_info_major_en_tl,
    supervisor      .tl_set:N = \l__whu_info_supervisor_tl,
    supervisor*     .tl_set:N = \l__whu_info_supervisor_en_tl,
    supervisor-outer.tl_set:N = \l__whu_info_supervisor_outer_tl,
    academic-title  .tl_set:N = \l__whu_info_supervisor_academic_title_tl,
    academic-title* .tl_set:N = \l__whu_info_supervisor_academic_title_en_tl,
    academic-title-outer.tl_set:N = \l__whu_info_supervisor_outer_academic_title_tl,
    research-area   .tl_set:N = \l__whu_info_research_area_tl,
    research-area*  .tl_set:N = \l__whu_info_research_area_en_tl,
    clc             .tl_set:N = \l__whu_info_clc_tl,
    secret-level    .tl_set:N = \l__whu_info_secret_level_tl,
    udc             .tl_set:N = \l__whu_info_udc_tl,
    year           .int_set:N = \l__whu_info_year_int,
    month          .int_set:N = \l__whu_info_month_int,
    day            .int_set:N = \l__whu_info_day_int,
    keywords     .clist_set:N = \l__whu_info_keywords_clist,
    keywords*    .clist_set:N = \l__whu_info_keywords_en_clist,
    cover-en-type .choice:,
    cover-en-type .choices:nn = { normal, cs }
                                { \tl_set_eq:NN \l__whu_cover_en_type_tl \l_keys_choice_tl },
    cover-en-type .initial:n = normal
  }
%tag 初始化公共键
\keys_set:nn { whu / info }
  {
    year = \c_sys_year_int,
    month = \c_sys_month_int,
    day = \c_sys_day_int,
    keywords = {\LaTeX{}, 毕业论文, 模版, 武汉大学},
    keywords* = {\LaTeX{}, Thesis, Template, Wuhan~University},
    clc = \c_empty_tl,
    secret-level = \c_empty_tl,
    udc = \c_empty_tl,
    student-id = xxxxxxxxxxx
  }

%tag 函数，用于定义常量
% 只定义中文
\cs_new_protected:Npn \__whu_define_name:nn #1#2
  { \tl_const:cn { c__whu_name_ #1 _tl } {#2} }
% 中英文（或中文+拼音）
\cs_new_protected:Npn \__whu_define_name:nnn #1#2#3
  {
    \tl_const:cn { c__whu_name_ #1    _tl } {#2}
    \tl_const:cn { c__whu_name_ #1 _en_tl } {#3}
  }
%tag 本科初始化
\cs_new_protected:Npn \__whu_bachelor_info_initial:
  {
    \clist_map_inline:nn
      {
        { secret_level } { 密级 },
        { student_id } { 学号 },
        { toc } { 目 \hspace{2em} 录 },
      }
      { \__whu_define_name:nn ##1 }
    \clist_map_inline:nn
      {
        { type } { 本科毕业论文（设计） } { BACHELOR’S~DEGREE~THESIS~OF~WUHAN~UNIVERSITY },
        { department } { 学院 } { School (Department) },
        { major } { 专业 } { Major },
        { author } { 姓名 } { Candidate },
        { supervisor } { 指导教师 } { Supervisor },
        { keywords } { 关键词 } { Keywords },
        { abstract } { 摘 \hspace{2em} 要 } { ABSTRACT },
      }
      { \__whu_define_name:nnn ##1 }
    \keys_set:nn { whu / info }
      {
        title           = {武汉大学本科生毕业论文 \LaTeX{} 模版},
        title*          = {A~\LaTeX{}~Thesis~Template~for~Wuhan~University},
        department      = {数学与统计学院},
        department*     = {School~of~Mathematics~and~Statistics},
        major           = {数学与应用数学},
        major*          = {Mathematics~and~Applied~Mathematics},
        author          = {夏大鱼羊},
        author*         = {XIA~Dayuyang},
        supervisor      = {夏大鱼羊},
        supervisor*     = {XIA~Kangwei},
        academic-title  = {教授},
        academic-title* = {Prof},
      }
  }
%tag 硕博公共部分常量定义
\cs_new:Npn \__whu_master_and_doctor_info_initial:
  {
    \clist_map_inline:nn
      {
        { secret_level } { 密级 },
        { clc } { 分类号 },
        { numbering } { 编号 },
        { udc } { UDC },
        { subject_major_academic } { 学科、专业名称 },
        { subject_major_professional } { 专业学位类别、领域 },
        { academic } { 学术学位  },
        { professional } { 专业学位 },
        { toc } { 目 \qquad 录 },
      }
      { \__whu_define_name:nn ##1 }
    \clist_map_inline:nn
      {
        { author } { 研究生姓名 } { Candidate },
        { student_id } { 学号 } { Student~ number },
        { supervisor } { 校内导师姓名、职称 } { Supervisor },
        { supervisor_outer } { 校外导师姓名、职称 } { Supervisor Outside },
        { major } { 专业名称 } { Major },
        { research_area  } { 研究方向 } { Speciality },
        { abstract } { 摘 \hspace{2em} 要 } { ABSTRACT },
        { keywords } { 关键词 } { Keywords },
      }
      { \__whu_define_name:nnn ##1 }
  }
%tag 硕士初始化
\cs_new:Npn \__whu_master_info_initial:
  {
    \clist_map_inline:nn
      {
        { type } { 硕士学位论文 }
      }
      { \__whu_define_name:nn ##1 }
    \keys_set:nn { whu / info }
      {
        title         = {武汉大学硕士学位论文 \LaTeX{} 模版},
        title*        = {A~\LaTeX{}~Thesis~Template~for~Wuhan~University},
        department    = {数学与统计学院},
        department*   = {School~of~Mathematics~and~Statistics},
        major         = {基础数学},
        major*        = {Pure~Mathematics},
        research-area = {函数空间上的算子理论},
        research-area* = {Operator~Theory~on~Function~Spaces},
        author        = {夏大鱼羊},
        author*       = {XIA~Kangwei},
        supervisor    = {夏大鱼羊},
        supervisor*   = {XIA~Dayuyang},
        academic-title = {教授},
        academic-title* = {Prof}
      }
  }
%tag 博士初始化
\cs_new:Npn \__whu_doctor_info_initial:
  {
    \clist_map_inline:nn
      {
        { type } { 博士学位论文 }
      }
      { \__whu_define_name:nn ##1 }
    \keys_set:nn { whu / info }
      {
        title         = {武汉大学博士学位论文 \LaTeX{} 模版},
        title*     = {A~\LaTeX{}~Thesis~Template~for~Wuhan~University},
        department    = {数学与统计学院},
        department*    = {School~of~Mathematics~and~Statistics},
        major         = {基础数学},
        major*        = {Pure~Mathematics},
        research-area = {函数空间上的算子理论},
        research-area* = {Operator~Theory~on~Function~Spaces},
        author        = {夏大鱼羊},
        author*       = {XIA~Kangwei},
        supervisor    = {夏大鱼羊},
        supervisor*   = {XIA~Dayuyang},
        academic-title = {教授},
        academic-title* = {Prof},
      }
  }
%tag 执行初始化
\int_case:Vn \g__whu_thesis_type_int
  {
    % 本科
    {2} { \__whu_bachelor_info_initial: }
    % 硕士
    {3} { \__whu_master_and_doctor_info_initial:
          \__whu_master_info_initial: }
    % 博士
    {4} { \__whu_master_and_doctor_info_initial:
          \__whu_doctor_info_initial: }
  }
%endregion 个人信息

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;值的一提的是这里会将公共常量定义为&lt;code&gt;c__whu_name_#1_tl&lt;/code&gt;，例如 &lt;code&gt;\c_whu_name_author_tl&lt;/code&gt; 对应 &lt;code&gt;姓名&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;根据 &lt;code&gt;\g__whu_thesis_type_int  &lt;/code&gt; 不同，调用的命令来初始化常量&lt;/p&gt;
&lt;h2&gt;落款&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;
%tag 本科任务书个人信息
\NewDocumentCommand \ProposalTasksinformation { }
  {
    \par \noindent
    毕业论文（设计）题目：\CJKunderline*{ \l__whu_info_title_tl }\\[5pt]
    学院：\CJKunderline*{ \l__whu_info_department_tl } \c_space_tl
    学号：\CJKunderline*{ \l__whu_info_student_id_tl } \c_space_tl
    姓名：\CJKunderline*{ \l__whu_info_author_tl }
  }
% 本科开题报告个人信息
\NewDocumentCommand \ProposalReportinformation { }
  {
    \par \noindent
    论文题目：\CJKunderline*{ \l__whu_info_title_tl }\\[10pt]
    学院：\CJKunderline*{ \l__whu_info_department_tl } \c_space_tl
    学号：\CJKunderline*{ \l__whu_info_student_id_tl } \c_space_tl
    姓名：\CJKunderline*{ \l__whu_info_author_tl }
  }
% 本科任务书落款
\NewDocumentCommand \ProposalTasksSignature { }
  {
    \dim_compare:nNnTF
      { \pagetotal } &amp;lt; { .5 \textheight }
      { \vfil \null \vfil }
      {
        \dim_compare:nNnTF
          { \pagegoal - \pagetotal } &amp;lt; { 8em }
          { \vfill }
          { \vfil \null \vfil }
      }
    \noindent
    指导老师签名：\CJKunderline*{\hspace*{10em}}  \hfill
    年 \hspace*{2em} 月 \hspace*{2em} 日
  }
% 本科任务书落款
\NewDocumentCommand \ProposalReportSignature { }
  {
    \dim_compare:nNnTF
      { \pagetotal } &amp;lt; { .5 \textheight }
      { \vfil }
      {
        \dim_compare:nNnTF
          { \pagegoal - \pagetotal } &amp;lt; { 8em }
          { \vfill }
          { \vfil \null \vfil }
      }
    \begin{flushright}
      指导老师签名：\hspace*{8em} \null\\[5pt]
      年 \hspace*{2em} 月 \hspace*{2em} 日
    \end{flushright}
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;以 &lt;code&gt;ProposalReportSignature&lt;/code&gt; 为例&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;graph LR
start[&quot;\ProposalReportSignature&quot;]
em{&quot;当前页剩余 &amp;lt; 8em&quot;}
haft{当前位置 &amp;lt; 文本区高度 * 0.5}
fill[&quot;\vfil&quot;]
fnf[&quot;\vfil\ null\vfil&quot;]
endd[签名]
start --&amp;gt; haft --&amp;gt;|Y| fill
haft --&amp;gt;|N| em --&amp;gt;|Y| fill
em --&amp;gt;|N| fnf
fill --&amp;gt;endd
fnf --&amp;gt; endd

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即将签名放到页面最下放&lt;/p&gt;
&lt;h2&gt;中文封面&lt;/h2&gt;
&lt;h3&gt;本科&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%region 本科
\cs_new_protected:Npn \__whu_bachelor_cover_i:
  {
    \newgeometry { hmargin = 2.445 cm , vmargin = 2.54cm }
    % logo and type
    \__whu_bachelor_cover_i_logo_and_type:
    % 论文标题
    \__whu_bachelor_cover_i_title:
    % 个人信息
    \__whu_bachelor_cover_i_information:
    % 时间
    \__whu_bachelor_cover_i_date_zh:
    \restoregeometry
  }

%tag logo-and-type
\cs_new_protected:Npn \__whu_bachelor_cover_i_logo_and_type:
  {
    \mode_leave_vertical:
    \skip_vertical:n { 2.01 cm }
    \noindent
    \begin{minipage}[t][3.85cm]{\textwidth}
      \centering
      \includegraphics[ width = 5.5cm ]{ logo / whu-name.pdf }
      \skip_vertical:n { 0.46 cm }
      \zihao{2} \bfseries \c__whu_name_type_tl
    \end{minipage}\par
  }

%tag 论文标题
\cs_new_protected:Npn \__whu_bachelor_cover_i_title:
  {
    \skip_vertical:n { 2.62cm }
    \noindent
    \begin{minipage}[t][5.01cm]{\textwidth}
      \skip_vertical:n { 0.5cm }
      \centering \zihao{1} \kaishu
      \l__whu_info_title_tl
    \end{minipage}\par
  }
%tag 个人信息
\cs_new_protected:Npn \__whu_bachelor_cover_i_information:
  {
    \clist_set:Nx \l__whu_tmpa_clist
      {
        \c__whu_name_author_tl,
        \c__whu_name_student_id_tl,
        \c__whu_name_major_tl,
        \c__whu_name_department_tl,
        \c__whu_name_supervisor_tl
      }
    \clist_set:Nx \l__whu_tmpb_clist
      {
        \l__whu_info_author_tl,
        \l__whu_info_student_id_tl,
        \l__whu_info_major_tl,
        \l__whu_info_department_tl,
        \l__whu_info_supervisor_tl
      }
    \noindent
    \begin{minipage}[t][4.5cm]{\textwidth}
      \zihao{4}
      \skip_vertical:n { 0.26cm }
      \bool_until_do:nn
        { \clist_if_empty_p:N \l__whu_tmpa_clist }
        {
          \clist_pop:NN \l__whu_tmpa_clist \l__whu_tmpa_tl
          \clist_pop:NN \l__whu_tmpb_clist \l__whu_tmpb_tl
          \hspace*{3.65cm}
          \__whu_spread_box:nn { 4em } { \l__whu_tmpa_tl }
          \skip_horizontal:n { 0.25cm } ：
          \makebox[6.91cm][c]{ \l__whu_tmpb_tl }
          \skip_vertical:n { 0.158cm }
        }
    \end{minipage}\par
  }
%tag 时间
\cs_new_protected:Npn \__whu_bachelor_cover_i_date_zh:
  {
    \skip_vertical:n { 4.85cm }
    \noindent
    \begin{minipage}[c][0.83cm]{\textwidth}
      \centering \zihao{4}
      \zhdigits { \int_use:N \l__whu_info_year_int }
      \, 年 \,
      \zhnumber { \int_use:N \l__whu_info_month_int }
      \, 月
    \end{minipage}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;本科论文的封面由 logo, title, info, date 组成。&lt;/p&gt;
&lt;p&gt;封面使用的边距不同于内容，此处通过 &lt;code&gt;\newgeometry&lt;/code&gt; 调整了外边距，并在结束处使用 &lt;code&gt;\restoregeometry&lt;/code&gt; 恢复&lt;/p&gt;
&lt;h3&gt;硕士&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%region 硕士
\cs_new_protected:Npn \__whu_master_cover_i:
  {
    \newgeometry { hmargin = 2.445 cm , vmargin = 2.54cm }
    % 顶部四项
    \__whu_master_cover_i_topmatter:
    % logo 和 type
    \__whu_master_cover_i_logo_and_type:
    % class (academic or professional)
    \__whu_master_cover_i_class:
    % 论文标题
    \__whu_master_cover_i_title:
    % 个人信息
    \__whu_master_cover_i_information:
    % 时间
    \__whu_master_cover_i_date_zh:
    \restoregeometry
  }
%tag 顶部四项
\cs_new_protected:Npn \__whu_master_cover_i_topmatter:
  {
    \noindent
    \begin{minipage}[b][0.9cm][b]{\textwidth}
      \fangsong \zihao{4} \mode_leave_vertical:
      \__whu_spread_box_with_end_spaces:nn { 2.04cm } { 分类号 }
      \CJKunderline { \hbox_to_wd:nn { 2.41cm } { \hfill \l__whu_info_clc_tl \hfill } }
      \hfill
      \__whu_spread_box_with_end_spaces:nn { 1.67cm } { 密级 }
      \CJKunderline { \hbox_to_wd:nn { 2.4cm } { \hfill \l__whu_info_secret_level_tl \hfill } }
    \end{minipage}\par\noindent
    \begin{minipage}[b][0.9cm][b]{\textwidth}
      \fangsong \zihao{4} \mode_leave_vertical:
      \__whu_spread_box_with_end_spaces:nn { 2.04cm } { UDC }
      \CJKunderline { \hbox_to_wd:nn { 2.41cm } { \hfill \l__whu_info_udc_tl \hfill } }
      \hfill
      \__whu_spread_box_with_end_spaces:nn { 1.67cm } { 编号 }
      \CJKunderline { \hbox_to_wd:nn { 2.4cm } { \hfill 10486 \hfill } }
    \end{minipage}\par
    \skip_vertical:n { 2cm }
  }
%tag logo-and-type
\cs_new_protected:Npn \__whu_master_cover_i_logo_and_type:
  {
    \noindent
    \begin{minipage}[t][3.5cm]{\textwidth}
      \centering
      \includegraphics [ width = 5 cm ] { logo / whu-name.pdf }
      \skip_vertical:n { 0.57cm }
      { \zihao{2} \bfseries
        \__whu_spread_box_with_quad:n { \c__whu_name_type_tl } }
      \vfil
    \end{minipage}\par
  }
%tag class (academic or professional)
\cs_new_protected:Npn \__whu_master_cover_i_class:
  {
    \noindent
    \begin{minipage}[t][2.25cm]{\textwidth}
      \skip_vertical:n { 0.2cm }
      \centering \zihao{-2} \bfseries
        （\use:c { c__whu_name_ \g__whu_thesis_class_tl _tl}）
    \end{minipage}\par
  }
%tag 论文标题
\cs_new_protected:Npn \__whu_master_cover_i_title:
  {
    \noindent
    \begin{minipage}[t][4.49cm]{\textwidth}
      \skip_vertical:n { 0.23cm }
      \centering \zihao{1} \kaishu \l__whu_info_title_tl
    \end{minipage}\par
  }
%region 个人信息
\cs_new:Npn \__whu_master_cover_i_information:
  {
    \str_case:xn { \tl_to_str:N \g__whu_thesis_class_tl }
      {
        { academic } { \__whu_master_academic_cover_information: }
        { professional } { \__whu_master_professional_cover_information: }
      }
  }
%tag 学术学位
\cs_new_protected:Npn \__whu_master_academic_cover_information:
  {
    \clist_set:Nx \l__whu_tmpa_clist
      {
        \c__whu_name_author_tl,
        \c__whu_name_student_id_tl,
        \c__whu_name_supervisor_tl,
        \c__whu_name_subject_major_academic_tl,
        \c__whu_name_research_area_tl
      }
    \clist_set:Nx \l__whu_tmpb_clist
      {
        \l__whu_info_author_tl,
        \l__whu_info_student_id_tl,
        \l__whu_info_supervisor_tl \l__whu_info_supervisor_academic_title_tl,
        \l__whu_info_subject_tl、\l__whu_info_major_tl,
        \l__whu_info_research_area_tl
      }
    \noindent
    \begin{minipage}[t][5.55cm]{\textwidth}
      \zihao{4}
      \skip_vertical:n { 0.35cm }
      \bool_until_do:nn
        { \clist_if_empty_p:N \l__whu_tmpa_clist }
        {
          \clist_pop:NN \l__whu_tmpa_clist \l__whu_tmpa_tl
          \clist_pop:NN \l__whu_tmpb_clist \l__whu_tmpb_tl
          \hspace*{2.19cm}
          \__whu_spread_box_with_end_spaces:nn { 4.67cm } { \l__whu_tmpa_tl }
          \makebox[0.42cm][c]{：}
          \__whu_spread_box_with_end_spaces:nn { 6.17cm } { \l__whu_tmpb_tl }
          \skip_vertical:n { .185cm }
        }
    \end{minipage}\par
    \skip_vertical:n { 1.95cm }
  }
%tag 专业学位 (比学术学位多一个校外导师项)
\cs_new_protected:Npn \__whu_master_professional_cover_information:
  {
    \clist_set:Nx \l__whu_tmpa_clist
      {
        \c__whu_name_author_tl,
        \c__whu_name_student_id_tl,
        \c__whu_name_supervisor_tl,
        \c__whu_name_supervisor_outer_tl,
        \c__whu_name_subject_major_professional_tl,
        \c__whu_name_research_area_tl
      }
    \clist_set:Nx \l__whu_tmpb_clist
      {
        \l__whu_info_author_tl,
        \l__whu_info_student_id_tl,
        \l__whu_info_supervisor_tl \l__whu_info_supervisor_academic_title_tl,
        \l__whu_info_supervisor_outer_tl \l__whu_info_supervisor_outer_academic_title_tl,
        \l__whu_info_subject_tl、\l__whu_info_major_tl,
        \l__whu_info_research_area_tl
      }
    \noindent
    \begin{minipage}[t][6.66cm]{\textwidth}
      \zihao{4}
      \skip_vertical:n { 0.35cm }
      \bool_until_do:nn
        { \clist_if_empty_p:N \l__whu_tmpa_clist }
        {
          \clist_pop:NN \l__whu_tmpa_clist \l__whu_tmpa_tl
          \clist_pop:NN \l__whu_tmpb_clist \l__whu_tmpb_tl
          \hspace*{2.19cm}
          \__whu_spread_box_with_end_spaces:nn { 4.67cm } { \l__whu_tmpa_tl }
          \makebox[0.42cm][c]{：}
          \__whu_spread_box_with_end_spaces:nn { 6.17cm } { \l__whu_tmpb_tl }
          \skip_vertical:n { .185cm }
        }
    \end{minipage}\par
    \skip_vertical:n { 1.95cm }
  }
%endregion 个人信息
%tag 时间
\cs_new_protected:Npn \__whu_master_cover_i_date_zh:
  {
    \noindent
    \begin{minipage}[c][0.81cm]{\textwidth}
      \centering \heiti \zihao { 3 }
      \zhdigits { \int_use:N \l__whu_info_year_int}
      年
      \zhnumber { \int_use:N \l__whu_info_month_int }
      月
    \end{minipage}
  }
%endregion 硕士
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;博士&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%region 博士
\cs_set_eq:NN \__whu_doctor_cover_i: \__whu_master_cover_i:
%endregion 博士
%endregion 中文封面
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;博士封面与硕士封面的布局一样，唯一的区别就是 logo 下方的论文类型，&lt;/p&gt;
&lt;p&gt;一个是“博士学位论文”，一个是“硕士学位论文”&lt;/p&gt;
&lt;h2&gt;英文封面&lt;/h2&gt;
&lt;h3&gt;本科&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;% 本科生是否显示英文封面（教务处规范中没有，黄老师模版中有）
\keys_define:nn { whu / style }
  {
    bachelor-encover .bool_set:N = \l__whu_bachelor_english_cover_bool,
    bachelor-encover .initial:n = false,
    bachelor-encover .default:n = true
  }
  \cs_new:Npn \__whu_bachelor_cover_ii:
  {
    \begin{tikzpicture} [ remember~picture, overlay ]
      % 类型
      \__whu_bachelor_cover_ii_type:
      % 标题
      \__whu_bachelor_cover_ii_title:
      % 个人信息
      \__whu_bachelor_cover_ii_information:
      % 时间
      \__whu_bachelor_cover_ii_date_en:
      % 学校名和logo
      \__whu_bachelor_cover_ii_logo:
    \end{tikzpicture}
  }
%tag 类型
\cs_new:Npn \__whu_bachelor_cover_ii_type:
  {
    \node [ anchor = north ] at
      ( [ shift = { ( 0 , -0.07\textheight ) } ] current~page~text~area.north )
      {
        \bfseries
        \parbox { 0.6\textwidth }
          {
            \centering \large \linespread{1.4}\selectfont
            \c__whu_name_type_en_tl
            \par
          }
      };
  }
%tag 标题
\cs_new:Npn \__whu_bachelor_cover_ii_title:
  {
    \node (title) at
      ( [ shift = { ( 0 , -0.29\textheight ) } ] current~page~text~area.north )
      {
        \begin{minipage}{\textwidth}
          \zihao{2} \centering \linespread{1.2}\selectfont
          \l__whu_info_title_en_tl
        \end{minipage}
      };
  }
%tag 个人信息
\cs_new:Npn \__whu_bachelor_cover_ii_information:
  {
    \node (information) at
      ( [shift = {(0em, 0em)}]current~page~text~area.center )
      {
        \tl_put_left:Nn \l__whu_info_supervisor_en_tl
          { \l__whu_info_supervisor_academic_title_en_tl .~ }
        \begin{tabular}{r@{\hspace{.5em}}l}
          \c__whu_name_department_en_tl : &amp;amp; \l__whu_info_department_en_tl \\
          \c__whu_name_major_en_tl : &amp;amp; \l__whu_info_major_en_tl\\
          \c__whu_name_author_en_tl : &amp;amp; \textsc{ \l__whu_info_author_en_tl } \\
          \c__whu_name_supervisor_en_tl : &amp;amp; \textsc{ \l__whu_info_supervisor_en_tl } \\
        \end{tabular}
      };
  }
%tag 学校名和logo
\cs_new:Npn \__whu_bachelor_cover_ii_logo:
  {
    \node [anchor = south] at ([ shift = { ( 0 , 2.5em ) } ] date.north)
      {
        \zihao{-2}
        \begin{tabular}{c}
          \includegraphics[width=4cm]{./logo/whu-logo.pdf} \\[3pt]
          \textsc{Wuhan~University}
        \end{tabular}
      };
  }
%tag 时间
\prop_const_from_keyval:Nn \l__whu_month_prop
  {
    1  = Jan,
    2  = Feb,
    3  = Mar,
    4  = Apr,
    5  = May,
    6  = Jun,
    7  = Jul,
    8  = Aug,
    9  = Sept,
    10 = Oct,
    11 = Nov,
    12 = Dec,
  }
\cs_new:Npn \__whu_month_cover_to_english_version:n #1
  {
    \prop_get:NnN \l__whu_month_prop {#1} \l__whu_tmpa_tl
    \l__whu_tmpa_tl
  }
\cs_generate_variant:Nn \__whu_month_cover_to_english_version:n { V }
\cs_new:Npn \__whu_bachelor_cover_ii_date_en:
  {
    \node [anchor = south] (date) at
      ([ shift = { ( 0 , 0.05\textheight ) } ] current~page~text~area.south)
      {
        \zihao{-2}
        \__whu_month_cover_to_english_version:V \l__whu_info_month_int, \c_space_tl \int_use:N\l__whu_info_year_int
      };
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这边的个人信息部分竟然是表格 :)&lt;/p&gt;
&lt;p&gt;不太明白这里为什么要用 &lt;code&gt;tikzpicture&lt;/code&gt; 环境，WHU 这么干一定有它的道理&lt;/p&gt;
&lt;h3&gt;硕士&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%region 硕士
\cs_new:Npn \__whu_master_cover_ii:
  {
    \pdfbookmark{英文封面}{titlepage-en}
    \tl_if_eq:NnTF \l__whu_cover_en_type_tl { normal }
      {
        \begin{tikzpicture} [ remember~picture, overlay ]
          % 标题
          \__whu_master_cover_ii_title:
          % 个人信息
          \__whu_master_cover_ii_information:
          % 时间
          \__whu_master_cover_ii_date_en:
          % 学校名和logo
          \__whu_master_cover_ii_logo:
        \end{tikzpicture}
      }
      {
        \tl_if_eq:NnT \l__whu_cover_en_type_tl { cs }
          {
            \__whu_master_cs_cover_ii:
          }
      }
  }
%tag 标题
\cs_new:Npn \__whu_master_cover_ii_title:
  {
    \node (title) at
      ( [ shift = { ( 0 , -0.1\textheight ) } ] current~page~text~area.north )
      {
        \begin{minipage}{\textwidth}
          \zihao{2} \centering \linespread{1.2}\selectfont
          \l__whu_info_title_en_tl
        \end{minipage}
      };
  }
%tag 个人信息
\cs_new:Npn \__whu_master_cover_ii_information:
  {
    \node (information) at
      ( [shift = {(3em, 5em)}]current~page~text~area.center )
      {
        \tl_put_left:Nn \l__whu_info_supervisor_en_tl
          { \l__whu_info_supervisor_academic_title_en_tl .~ }
        \renewcommand \arraystretch { 1.2 }
        \AddToHookNext { env / tabular / begin }
          { \zihao{4} }
        \begin{tabular}{r@{\hspace{.5em}}l}
          \c__whu_name_author_en_tl : &amp;amp; \textsc{ \l__whu_info_author_en_tl } \\
          \c__whu_name_student_id_en_tl : &amp;amp; \l__whu_info_student_id_tl \\
          \c__whu_name_supervisor_en_tl : &amp;amp; \textsc{ \l__whu_info_supervisor_en_tl } \\
          \c__whu_name_major_en_tl : &amp;amp; \l__whu_info_major_en_tl \\
          \c__whu_name_research_area_en_tl : &amp;amp; \l__whu_info_research_area_en_tl
        \end{tabular}
      };
  }
%tag 学校名和 logo
\cs_new:Npn \__whu_master_cover_ii_logo:
  {
    \node [anchor = south] at ([ shift = { ( 0 , 2em ) } ] date.north)
      {
        \begin{tabular}{c}
          \includegraphics[width=4cm]{./logo/whu-logo.pdf} \\[3pt]
          \zihao{-2}\l__whu_info_department_en_tl \\[3pt]
          \zihao{-2}\textsc{Wuhan~University}
        \end{tabular}
      };
  }
%tag 时间
\cs_new:Npn \__whu_master_cover_ii_date_en:
  {
    \node [anchor = south] (date) at
      ([ shift = { ( 0 , 0.01\textheight ) } ] current~page~text~area.south)
      {
        \zihao{-2}
        \__whu_month_cover_to_english_version:V \l__whu_info_month_int, \c_space_tl \int_use:N\l__whu_info_year_int
      };
  }
% 计算机学院、网络安全学院英文封面，依据为计算机学院于
% 2023-05-10 发布的链接文件 https://cs.whu.edu.cn/info/1140/4335.htm
\cs_new:Npn \__whu_master_cs_cover_ii:
  {
    \begin{tikzpicture}[ remember~picture, overlay, align=center ]
      \node at ([shift = {(0,-4.16cm)}]current~page~text~area.north)
        {
          \begin{minipage}{\textwidth}
            \zihao{2} \centering \linespread{1.2}\selectfont
            \l__whu_info_title_en_tl
          \end{minipage}
        };
      \node at ([shift={(0,1.35cm)}]current~page~text~area.center)
        { \zihao{4} By \\ \l__whu_info_author_en_tl };
      \node at ([shift={(0,-2.75cm)}]current~page~text~area.center)
        { \zihao{4} Supervised~by \\
          \l__whu_info_supervisor_academic_title_en_tl .\c_space_tl
          \l__whu_info_supervisor_en_tl };
      \node [anchor=south] at ([shift={(0,1.45cm)}]current~page~text~area.south)
        { \zihao{4} Wuhan~University \\
          \__whu_month_cover_to_english_version:V \l__whu_info_month_int, \c_space_tl
          \int_use:N \l__whu_info_year_int };
      % 用于对比测试
      % \node at (current~page.center)
      %   { \includegraphics[width = \paperwidth, height = \paperheight]{./reference/b.pdf} };
    \end{tikzpicture}
  }
%endregion 硕士
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;博士&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%region 博士
\cs_new:Npn \__whu_doctor_cover_ii:
  {
    \pdfbookmark{英文封面}{titlepage-en}
    \begin{tikzpicture} [ remember~picture, overlay ]
      % 标题
      \__whu_doctor_cover_ii_title:
      % 个人信息
      \__whu_doctor_cover_ii_information:
      % 时间
      \__whu_doctor_cover_ii_date_en:
      % 学校名和logo
      \__whu_doctor_cover_ii_logo:
    \end{tikzpicture}
  }
%tag 标题
\cs_new:Npn \__whu_doctor_cover_ii_title:
  {
    \node (title) at
      ( [ shift = { ( 0 , -0.1\textheight ) } ] current~page~text~area.north )
      {
        \begin{minipage}{\textwidth}
          \zihao{2} \centering \linespread{1.2}\selectfont
          \l__whu_info_title_en_tl
        \end{minipage}
      };
  }
%tag 个人信息
\cs_new:Npn \__whu_doctor_cover_ii_information:
  {
    \node (information) at
      ( [shift = {(3em, 5em)}]current~page~text~area.center )
      {
        \tl_put_left:Nn \l__whu_info_supervisor_en_tl
          { \l__whu_info_supervisor_academic_title_en_tl .~ }
        \AddToHookNext { env / tabular / begin }
          { \zihao{4} }
          \renewcommand \arraystretch { 1.2 }
        \begin{tabular}{r@{\hspace{.5em}}l}
          \c__whu_name_author_en_tl : &amp;amp; \textsc{ \l__whu_info_author_en_tl } \\
          \c__whu_name_supervisor_en_tl : &amp;amp; \textsc{ \l__whu_info_supervisor_en_tl } \\
          \c__whu_name_major_en_tl : &amp;amp; \l__whu_info_major_en_tl \\
          \c__whu_name_research_area_en_tl : &amp;amp; \l__whu_info_research_area_en_tl
        \end{tabular}
      };
  }
%tag 学校名和logo
\cs_new:Npn \__whu_doctor_cover_ii_logo:
  {
    \node [anchor = south] at ([ shift = { ( 0 , 2em ) } ] date.north)
      {
        \AddToHookNext { env / tabular / begin }
          { \zihao{-2} }
        \begin{tabular}{c}
          \includegraphics[width=4cm]{./logo/whu-logo.pdf} \\[3pt]
          \l__whu_info_department_en_tl \\[3pt]
          \textsc{Wuhan~University}
        \end{tabular}
      };
  }
%tag 时间
\cs_new:Npn \__whu_doctor_cover_ii_date_en:
  {
    \node [anchor = south] (date) at
      ([ shift = { ( 0 , 0.01\textheight ) } ] current~page~text~area.south)
      {
        \zihao{-2}
        \__whu_month_cover_to_english_version:V \l__whu_info_month_int
        \c_space_tl \int_use:N\c_sys_day_int, \c_space_tl \int_use:N\l__whu_info_year_int
      };
  }
%endregion 博士
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;原创声明&lt;/h2&gt;
&lt;h3&gt;本科原创性声明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_new_protected:Npn \__whu_bachelor_originality_statement:
  {
    \noindent
    \begin{minipage}[b][0.8cm]{\textwidth}
      \centering \zihao{-2} \heiti 原创性声明
    \end{minipage}
    \skip_vertical:n { 1.3cm }
    \group_begin:
      \zihao{-4}
      本人郑重声明：所呈交的论文（设计），是本人在指导教师的指导下，严格按照学校和学院有关规定完成的。除文中已经标明引用的内容外，本论文（设计）不包含任何其他个人或集体已发表及撰写的研究成果。对本论文（设计）做出贡献的个人和集体，均已在文中以明确方式标明。本人承诺在论文（设计）工作过程中没有伪造数据等行为。若在本论文（设计）中有侵犯任何方面知识产权的行为，由本人承担相应的法律责任。
      \skip_vertical:n { 1.61cm }
      \noindent
      \hspace*{4.653cm} \__whu_spread_box:nn{4em}{作者签名}： \makebox[5.285cm][r]{指导教师签名：} \hfil \par
      \noindent
      \hspace*{4.653cm} \__whu_spread_box:nn{4em}{日期}： \hspace{1.28cm}
        \__whu_spread_box:nn{2.5cm}{年月日}
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;本科版权使用授权书&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_new_protected:Npn \__whu_bachelor_copyright:
  {
    \skip_vertical:n { 2.3cm }
    \begin{center}
      \heiti \zihao{-2} 版权使用授权书
    \end{center}\par
    \skip_vertical:n { 1.16cm }
    \group_begin:
      \zihao{-4}
      本人完全了解武汉大学有权保留并向有关部门或机构送交本论文（设计）的复印件和电子版，允许本论文（设计）被查阅和借阅。本人授权武汉大学将本论文的全部或部分内容编入有关数据进行检索和传播，可以采用影印、缩印或扫描等复制手段保存和汇编本论文（设计）。
      \skip_vertical:n { 2.1cm }
      \noindent
      \hspace*{4.653cm} \__whu_spread_box:nn{4em}{作者签名}： \makebox[5.285cm][r]{指导教师签名：} \hfil \par
      \noindent
      \hspace*{4.653cm} \__whu_spread_box:nn{4em}{日期}： \hspace{1.28cm}
        \__whu_spread_box:nn{2.5cm}{年月日}
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;4.653cm 是用尺子量出来的吗&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240507210727123.png&quot; alt=&quot;image-20240507210727123&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;硕士原创声明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 硕士原创性声明
\fp_const:Nn \c__whu_master_statement_line_spread_fp
  { \dim_ratio:nn { 28 bp } { 14 bp } / 1.2 }
\cs_new:Npn \__whu_master_statement:
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter =
            {
              format = \sffamily\zihao{-2}\centering,
              afterskip = 8ex,
              pagestyle = empty
            }
        }
      \chapter*{论文原创性声明}
      \linespread{1}
      \fontsize{14bp}{28bp}\selectfont
      本人郑重声明：所呈交的学位论文，是本人在导师指导下，独立进行研究工作所取得的研究成果。除文中已经标明引用的内容外，本论文不包含任何其他个人或集体已经发表或撰写过的研究成果。对本文的研究做出贡献的个人和集体，均已在文中以明确方式标明。本声明的法律结果由本人承担。

      \vspace*{3em}
      \begin{flushright}
        学位论文作者（签名）：\hspace*{4em}\mbox{}\\[12pt]
        年 \qquad 月 \qquad 日
      \end{flushright}
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;博士原创性声明&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 博士原创性声明
\cs_new:Npn \__whu_doctor_statement:
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter =
            {
              format = \sffamily\zihao{-2}\centering,
              afterskip = 8ex,
              pagestyle = empty
            }
        }
      \pdfbookmark{原创性声明}{doctor-statement}
      \chapter*{论文原创性声明}
      \linespread{1}
      \fontsize{14bp}{28bp}\selectfont
      本人郑重声明：所呈交的学位论文，是本人在导师指导下，独立进行研究工作所取得的研究成果。除文中已经标明引用的内容外，本论文不包含任何其他个人或集体已发表或撰写的研究成果。对本文的研究做出贡献的个人和集体，均已在文中以明确方式标明。本声明的法律结果由本人承担。

      \vspace*{3em}
      \begin{flushright}
        学位论文作者（签名）：\hspace*{4em}\mbox{}\\[12pt]
        年 \qquad 月 \qquad 日
      \end{flushright}
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;博士使用授权协议书&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 博士使用授权协议书
\cs_new:Npn \__whu_doctor_license_agreement:
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter =
            {
              format = \sffamily\zihao{4}\centering,
              beforeskip = 2ex,
              afterskip = 8ex,
              pagestyle = empty
            }
        }
      \pdfbookmark{使用授权协议书}{doctor-license-agreement}
      \chapter*{武汉大学学位论文使用授权协议书}
      \linespread{1}
      \fontsize{12bp}{28bp}\selectfont
      本学位论文作者愿意遵守武汉大学关于保存、使用学位论文的管理办法及规定，即：学校有权保存学位论文的印刷本和电子版，并提供文献检索与阅览服务；学校可以采用影印、缩印、数字化或其它复制手段保存论文；在以教学与科研服务为目的前提下，学校可以在校园网内公布部分或全部内容。 \par
      \textbf{一、}在本论文提交当年，同意在校园网内以及中国高等教育文献保障系统（CALIS）、高校学位论文系统提供查询及前十六页浏览服务。 \par
      \textbf{二、}在本论文提交 $\square$ 当年／$\square$一年／$\square$ 两年／$\square$ 三年以后，同意在校园网内允许读者在线浏览并下载全文，学校可以为存在馆际合作关系的兄弟高校用户提供文献传递服务和交换服务。（保密论文解密后遵守此规定）\par

      \vspace*{3em}
      \begin{minipage}{0.5\textwidth}
        论文作者（签名）：\CJKunderline*{\hfill}\\[12pt]
        学号：\CJKunderline*{\hfill}\\[12pt]
        学院：\CJKunderline*{\hfill}\\[12pt]
      \end{minipage} \par
      \hfill 日期：\hspace{3em} 年 \qquad 月 \qquad 日
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;博士论文创新点&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 博士论文创新点
\cs_new_protected:Npn \__whu_doctor_innovation:
  {
    \group_begin:
    \keys_set:nn { ctex }
      {
        chapter =
          {
            format+ = \centering,
            pagestyle = empty
          }
      }
    \chapter*{ 论文创新点 }
    \pdfbookmark{ 论文创新点 }{ doctor-innovation }
    \zihao{-4}
    \file_if_exist:nT { pages / innovation.tex }
      {
        \file_input:n { pages / innovation.tex }
      }
    \newpage
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里重设了 ctex 的 chapter ，使之居中对齐并取消页眉页脚&lt;/p&gt;
&lt;p&gt;之后判断文件 &lt;code&gt;pages/innovation.tex&lt;/code&gt; 是否存在，如果存在则导入此文件&lt;/p&gt;
&lt;h2&gt;摘要和关键词&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;%region 摘要和关键词
%tag 摘要与关键词之间的间距样式
\str_new:N \l__whu_abstract_keywords_zh_type_str  % 摘要和关键词之间的换行情况
\str_new:N \l__whu_abstract_keywords_en_type_str  % 摘要和关键词之间的换行情况
\keys_define:nn { whu / style }
  {
    abstract-keywords-type  .choices:nn = { newline, blankline, vfill }
     { \str_set:Nx \l__whu_abstract_keywords_zh_type_str { \l_keys_choice_tl } },
    abstract-keywords-type .initial:n = blankline,
    abstract-keywords-type* .choices:nn = { newline, blankline, vfill }
     { \str_set:Nx \l__whu_abstract_keywords_en_type_str { \l_keys_choice_tl } },
  }
% 如果只设置了 zh 的就默认 en 和 zh 相同
\AtEndPreamble
  {
    \str_if_empty:NT \l__whu_abstract_keywords_en_type_str
      { \str_set_eq:NN \l__whu_abstract_keywords_en_type_str \l__whu_abstract_keywords_zh_type_str }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这个位置关于 &lt;code&gt;\l__whu_abstract_keywords_en_type_str&lt;/code&gt; 取默认值的方法相当精彩。&lt;/p&gt;
&lt;p&gt;在 key 定义时不配置默认值，而是在 Preamble 的结束部分进行判断。按照标准，如果在这时候该值仍未配设置，则以后也不会更新，那么这时就可以将 &lt;code&gt;\l__whu_abstract_keywords_zh_type_str&lt;/code&gt; 赋值到 &lt;code&gt;\l__whu_abstract_keywords_en_type_str&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;本科&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_new:Npn \__whu_bachelor_abstract_output:
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter =
            {
              numbering  = false,
              pagestyle  = bachelor-frontmatter,
              format     = \heiti \zihao{-2} \centering,
              beforeskip = 15pt,
              afterskip  = 20pt
            }
        }
      \chapter* { \c__whu_name_abstract_tl }
      \addcontentsline{toc}{chapter}{摘要}
      \zihao{-4}
      \file_if_exist:nT { pages/abstract.tex }
        {
          \file_input:n { pages/abstract.tex }
        }
      \__whu_abstract_keywords_zh_vsep_set:
      {\bfseries \c__whu_name_keywords_tl ：}
    \clist_use:Nn \l__whu_info_keywords_clist {；}
    \newpage
    \group_end:
  }
\cs_new:Npn \__whu_bachelor_abstract_en_output:
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter =
            {
              numbering  = false,
              format     = \normalfont \bfseries \centering \zihao{-2},
              pagestyle  = bachelor-frontmatter,
              beforeskip = 15pt,
              afterskip  = 20pt
            }
        }
      \chapter{ \c__whu_name_abstract_en_tl }
      \zihao{-4}
      % \g__whu_abstract_en_content_tl
      \file_if_exist:nT { pages/abstract.tex }
        {
          \file_input:n { pages/enabstract.tex }
        }
      \__whu_abstract_keywords_zh_vsep_set:
      {\textbf { \c__whu_name_keywords_en_tl :} ~}
      \clist_use:Nn \l__whu_info_keywords_en_clist {;~}
      \newpage
    \group_end:
  }
\cs_new:Npn \__whu_abstract_keywords_zh_vsep_set:
  {
    \str_case:Vn \l__whu_abstract_keywords_zh_type_str
      {
        { newline } { \par \noindent }
        { blankline } { \par \vspace*{ .5\baselineskip } \noindent }
        { vfill } { \par \vfill \noindent }
      }
  }
\cs_new:Npn \__whu_abstract_keywords_en_vsep_set:
  {
    \str_case:Vn \l__whu_abstract_keywords_en_type_str
      {
        { newline } { \par \noindent}
        { blankline } { \par \vspace*{ .5\baselineskip } \noindent }
        { vfill } { \vfill }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;s&gt;这里还能水个 &lt;a href=&quot;https://github.com/whutug/whu-thesis/pull/277&quot;&gt;pr&lt;/a&gt;&lt;/s&gt;&lt;/p&gt;
&lt;h3&gt;硕士&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;%tag 硕士
\cs_new:Npn \__whu_master_abstract_output:
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter =
            {
              numbering = false,
              format+ = \centering,
              pagestyle = master-frontmatter
            }
        }
      \chapter{ \c__whu_name_abstract_tl }
      \zihao{-4} \pagestyle{empty}
      \file_if_exist:nT { pages/abstract.tex }
        {
          \file_input:n { pages/abstract.tex }
        }
      \__whu_abstract_keywords_zh_vsep_set:
      {\heiti \c__whu_name_keywords_tl ：}
    \clist_use:Nn \l__whu_info_keywords_clist {；}
    \newpage
    \group_end:
  }
\cs_new:Npn \__whu_master_abstract_en_output:
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter =
            {
              numbering = false,
              format    = \normalfont\bfseries\centering\zihao{-2},
              pagestyle = master-frontmatter
            }
        }
      \chapter{ \c__whu_name_abstract_en_tl }
      \zihao{-4}
      % \g__whu_abstract_en_content_tl
      \file_if_exist:nT { pages/enabstract.tex }
        {
          \file_input:n { pages/enabstract.tex }
        }
      \__whu_abstract_keywords_zh_vsep_set:
      {\textbf { \c__whu_name_keywords_en_tl :} ~}
      \clist_use:Nn \l__whu_info_keywords_en_clist {;~}
      \newpage
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;博士&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_new:Npn \__whu_doctor_abstract_output:
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter =
            {
              numbering = false,
              format+ = \centering,
              pagestyle = doctor-frontmatter
            }
        }
      \chapter{ \c__whu_name_abstract_tl }
      \zihao{-4}
      \file_if_exist:nT { pages/abstract.tex }
        {
          \file_input:n { pages/abstract.tex }
        }
      \__whu_abstract_keywords_zh_vsep_set:
      {\heiti \c__whu_name_keywords_tl ：}
    \clist_use:Nn \l__whu_info_keywords_clist {；}
    \newpage
    \group_end:
  }
\cs_new:Npn \__whu_doctor_abstract_en_output:
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter =
            {
              numbering = false,
              format    = \normalfont\bfseries\centering\zihao{-2},
              pagestyle = doctor-frontmatter
            }
        }
      \chapter{ \c__whu_name_abstract_en_tl }
      \zihao{-4}
      \file_if_exist:nT { pages/enabstract.tex }
        {
          \file_input:n { pages/enabstract.tex }
        }
      \__whu_abstract_keywords_zh_vsep_set:
      {\textbf { \c__whu_name_keywords_en_tl :} ~}
      \clist_use:Nn \l__whu_info_keywords_en_clist {;~}
      \newpage
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;输出封面及摘要&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\int_compare:nNnF { \g__whu_thesis_type_int } = {1}
  {
    \ctex_after_end_preamble:n
    {
      \pdfbookmark{中文封面}{titlepage}
      \int_case:Vn \g__whu_thesis_type_int
        {
          % 本科
          {2}
            {
              \pagestyle{empty}
              \__whu_bachelor_cover_i:
              \bool_if:NT \l__whu_bachelor_english_cover_bool
                {
                  \newpage
                  \__whu_bachelor_cover_ii:
                }
              \newpage
              \__whu_bachelor_originality_statement:
              \__whu_bachelor_copyright:
              \newpage
              \frontmatter
              \pagenumbering{Roman}
              \pagestyle{ bachelor-frontmatter }
              \__whu_bachelor_abstract_output:
              \newpage
              \__whu_bachelor_abstract_en_output:
              \newpage
            }
          % 硕士
          {3}
            {
              \pagestyle{empty}
              \__whu_master_cover_i:
              \__whu_new_blank_page:
              \__whu_master_cover_ii:
              \__whu_new_blank_page:
              \__whu_master_statement:
              \newpage
              \frontmatter
              \pagestyle{ master-frontmatter }
              \pagenumbering{Roman}
              \__whu_master_abstract_output:
              \newpage
              \__whu_master_abstract_en_output:
              \newpage
            }
          % 博士
          {4}
            {
              \pagestyle{empty}
              \__whu_doctor_cover_i:
              \__whu_new_blank_page:
              \__whu_doctor_cover_ii:
              \__whu_new_blank_page:
              \__whu_doctor_statement:
              \__whu_new_blank_page:
              \__whu_doctor_license_agreement:
              \__whu_new_blank_page:
              \__whu_doctor_innovation:
              \frontmatter
              \pagestyle{ doctor-frontmatter }
              \pagenumbering{Roman}
              \__whu_doctor_abstract_output:
              \newpage
              \__whu_doctor_abstract_en_output:
              \newpage
            }
        }
    }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;目录&lt;/h2&gt;
&lt;h3&gt;统一目录标题和正文标题&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;__whu_msg_new:nn { bachelor-no-optional-argument }
  { #1~shouldn&apos;t~be~used~with~optional~argument~in~bachelor&apos;s~thesis.\\
    The~optional~argument~of~#1~is~ignored.
  }
\cs_new:Npn \__whu_bachelor_chapter_cmds_no_optional_argument:
  {
    \NewCommandCopy { \bachelorchapter } { \chapter }
    \NewCommandCopy { \bachelorsection } { \section }
    \NewCommandCopy { \bachelorsubsection } { \subsection }
    \RenewDocumentCommand \chapter { s o m }
      {
        \IfBooleanTF {##1}
          { \bachelorchapter* {##3} }
          { \bachelorchapter {##3} }  % ]
        \IfNoValueF {##2}
          { \__whu_warning:nn { bachelor-no-optional-argument } { \chapter } }
      }
    \RenewDocumentCommand \section { s o m }
      {
        \IfBooleanTF {##1}
          { \bachelorsection* {##3} }
          { \bachelorsection {##3} }  % ]
        \IfNoValueF {##2}
          { \__whu_warning:nn { bachelor-no-optional-argument } { \section } }
      }
    \RenewDocumentCommand \subsection { s o m }
      {
        \IfBooleanTF {##1}
          { \bachelorsubsection* {##3} }
          { \bachelorsubsection {##3} }  % ]
        \IfNoValueF {##2}
          { \__whu_warning:nn { bachelor-no-optional-argument } { \subsection } }
      }
  }
\AddToHook { begindocument }
  {
    \int_case:Vn \g__whu_thesis_type_int
      {
        % 本科
        {2} { \__whu_bachelor_chapter_cmds_no_optional_argument: }
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;使 &lt;code&gt;\chapter&lt;/code&gt; 、&lt;code&gt;\section&lt;/code&gt; 等命令吞参数，即不能输入 &lt;code&gt;\chapter[]{}&lt;/code&gt; 而只能输入 &lt;code&gt;\chapter{}&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这里使用了 &lt;code&gt;\RenewDocumentCommend&lt;/code&gt; 命令来重新创建这几个参数，在其中如果 &lt;code&gt;#2&lt;/code&gt; 不为空，则给出一段 warning&lt;/p&gt;
&lt;p&gt;上述语句被定义在 &lt;code&gt;\__whu_bachelor_chapter_cmds_no_optional_argument:&lt;/code&gt; 中，只有当 &lt;code&gt;\g__whu_thesis_type_int&lt;/code&gt; 为 2 时才会启用&lt;/p&gt;
&lt;h3&gt;本科设置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_new:Npn \__whu_bachelor_set_tocline:
  {
    \keys_set:nn { ctex }
      { contentsname   = \c__whu_name_toc_tl }
    % 字体字号
    \renewcommand{\cftchapfont}{\bfseries \zihao{-4}}
    \renewcommand{\cftsecfont}{\normalfont \zihao{-4}}
    \renewcommand{\cftsubsecfont}{\normalfont \zihao{-4}}
    \renewcommand{\cftchappagefont}{\normalfont \zihao{-4}}
    % 引导线
    \renewcommand{\cftchapleader}{\cftdotfill{\cftdotsep}}
    % 缩进
    \dim_set:Nn \cftchapindent { 0em }
    \dim_set:Nn \cftsecindent  { 1em }
    \dim_set:Nn \cftsubsecindent { 3em }
    % 计数器宽度
    \dim_set:Nn \cftchapnumwidth { 1.5em }
    \dim_set:Nn \cftsecnumwidth { 2.5em }
    \dim_set:Nn \cftsubsecnumwidth { 1.5em }
    % 垂直间距
    \setlength{\cftbeforechapskip}{0pt}
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;硕士设置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_new:Npn \__whu_master_set_tocline:
  {
    \keys_set:nn { ctex }
      { contentsname   = \c__whu_name_toc_tl }
    % 字体字号
    \renewcommand{\cftchapfont}{\heiti \zihao{4}}
    \renewcommand{\cftsecfont}{\normalfont \zihao{-4}}
    \renewcommand{\cftsubsecfont}{\normalfont \zihao{-4}}
    % % 缩进
    % \dim_set:Nn \cftchapindent { 0em }
    % \dim_set:Nn \cftsecindent  { 0em }
    % \dim_set:Nn \cftsubsecindent { 0em }
    % 计数器宽度
    % \dim_set:Nn \cftchapnumwidth { 1.5em }
    \dim_set:Nn \cftsecnumwidth { 2em }
    \dim_set:Nn \cftsubsecnumwidth { 2.8em }
    % chapter前的额外垂直间距
    % \dim_set:Nn \cftbeforechapskip { 0.5\baselineskip }
    % section前的额外垂直间距
    % \dim_set:Nn \cftbeforesecskip { 0.2\baselineskip }
    % subsection前的额外垂直间距
    % \dim_set:Nn \cftbeforesubsecskip { 0pt }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;博士设置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_new:Npn \__whu_doctor_set_tocline:
  {
    \keys_set:nn { ctex }
      { contentsname   = \c__whu_name_toc_tl }
    % 字体字号
    \renewcommand{\cftchapfont}{\bfseries \zihao{4}}
    \renewcommand{\cftsecfont}{\normalfont \zihao{-4}}
    \renewcommand{\cftsubsecfont}{\normalfont \zihao{-4}}
    % 引导线
    \renewcommand{\cftchapleader}{\cftdotfill{\cftdotsep}}
    % % 缩进
    % \dim_set:Nn \cftchapindent { 0em }
    % \dim_set:Nn \cftsecindent  { 2em }
    % \dim_set:Nn \cftsubsecindent { 4em }
    % 计数器宽度
    % \dim_set:Nn \cftchapnumwidth { 1.5em }
    \dim_set:Nn \cftsecnumwidth { 2em }
    \dim_set:Nn \cftsubsecnumwidth { 2.8em }
    % % chapter前的额外垂直间距
    % \dim_set:Nn \cftbeforechapskip { 0.5\baselineskip }
    % % section前的额外垂直间距
    % \dim_set:Nn \cftbeforesecskip { 0.4\baselineskip }
    % % subsection前的额外垂直间距
    % \dim_set:Nn \cftbeforesubsecskip { 0.1\baselineskip }
  }

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;输出配置&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\int_case:Vn \g__whu_thesis_type_int
  {
    % 本科
    {2} { \__whu_bachelor_set_tocline: }
    % 硕士
    {3} { \__whu_master_set_tocline: }
    % 博士
    {4} { \__whu_doctor_set_tocline: }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;重定义目录&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\cs_set_eq:NN \__whu_old_tableofcontents: \tableofcontents
\RenewDocumentCommand \tableofcontents { }
  {
    \group_begin:
    \keys_set:nn { ctex }
      {
        chapter / format += \centering,
        chapter / pagestyle = \tl_use:N \g__whu_thesis_type_tl -frontmatter
      }
    \__whu_old_tableofcontents:
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先配置目录的 chapter 应当是居中的（注意不是目录内容中的 chapter，而是目录两个字），且该页的页眉页脚应当是 frontmatter 的样式。配置结束后调用旧的 &lt;code&gt;\tableofcontents&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;插图目录和表格目录&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\keys_set:nn { ctex }
  {
    listfigurename = { 插\qquad 图 },
    listtablename  = { 表\qquad 格 }
  }
\cs_set_eq:NN \__whu_old_listoffigures: \listoffigures
\RenewDocumentCommand \listoffigures { }
  {
    \group_begin:
    \keys_set:nn { ctex }
      {
        chapter / format += \centering,
        chapter / pagestyle = \tl_use:N \g__whu_thesis_type_tl -frontmatter
      }
    \__whu_old_listoffigures:
    \group_end:
  }
\cs_set_eq:NN \__whu_old_listoftables: \listoftables
\RenewDocumentCommand \listoftables { }
  {
    \group_begin:
    \keys_set:nn { ctex }
      {
        chapter / format += \centering,
        chapter / pagestyle = \tl_use:N \g__whu_thesis_type_tl -frontmatter
      }
    \__whu_old_listoftables:
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;致谢环境&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\NewDocumentEnvironment{acknowledgements}{ +b }
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter / format = \centering \zihao{-2} \heiti,
        }
      \chapter* { 致 \qquad 谢 }
      \addcontentsline{toc}{chapter}{致谢}
      #1
    \group_end:
  }{}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;添加了 &lt;code&gt;acknowledgements&lt;/code&gt; 环境，这样的话可以直接这样使用该环境&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\begin{acknowledgements}
感谢导师的悉心指导，感谢家人的支持，感觉我家的猫（虽然我并没有猫）,感谢所有帮助过我的人。
\end{acknowledgements}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;附录&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\cs_new:Npn \__whu_bachelor_set_appendix:
  {
    \AddToHook { cmd / appendix / after }
      {
        \renewcommand{ \theequation }{ \thechapter \arabic{equation} }
        \keys_set:nn { ctex }
          {
            section/number = \Alph{chapter}\arabic{section},
            subsection/number = \Alph{chapter}\arabic{section}.\arabic{subsection},
            subsubsection/number = \Alph{chapter}\arabic{section}.\arabic{subsection}.\arabic{subsubsection},
          }
      }
  }
\int_case:Vn \g__whu_thesis_type_int
  {
    % 本科
    {2} { \__whu_bachelor_set_appendix: }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改附录中编号为 &lt;code&gt;\thechater \arabic{equation}&lt;/code&gt;。这样做的效果是，每个数学公式的编号前面会加上章节编号，以区分不同章节中的公式。&lt;/p&gt;
&lt;p&gt;并设置附录的章节编号格式设置为了大写字母表示的章节编号&lt;/p&gt;
&lt;h2&gt;脚注&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\cs_new_protected:Npn \__whu_define_fn_style:nn #1#2
  { \tl_const:cn { c__whu_fn_style_ #1 _tl } {#2} }
\cs_new:Npn \__whu_symbol:n #1 { \tex_char:D #1 \scan_stop: } % \tex_char:D = \char

\clist_map_inline:nn
  {
    { plain           } { plain           },
    { libertinus      } { libertinus      },
    { libertinus_neg  } { libertinus*     },
    { libertinus_sans } { libertinus-sans },
    { pifont          } { pifont          },
    { pifont_neg      } { pifont*         },
    { pifont_sans     } { pifont-sans     },
    { pifont_sans_neg } { pifont-sans*    },
    { xits            } { xits            },
    { xits_sans       } { xits-sans       },
    { xits_sans_neg   } { xits-sans*      }
  }
  { \__whu_define_fn_style:nn #1 }
%tag 定义键
\tl_new:N \l__whu_fn_style_tl
\keys_define:nn { whu / style }
  {
    footnote-style .choices:nn =
      {
        plain,
        libertinus, libertinus*, libertinus-sans,
        pifont,     pifont*,     pifont-sans,     pifont-sans*,
        xits,                    xits-sans,       xits-sans*
      }
      {
        \tl_gset_eq:NN \l__whu_fn_style_tl \l_keys_choice_tl
        \int_compare:nT { 5 &amp;lt;= \l_keys_choice_int &amp;lt;= 8 }
          { \RequirePackage { pifont } }
      },
    footnote-style .value_required:n = true
  }
%tag 设置键
\keys_set:nn { whu / style }
  {
    footnote-style = libertinus
  }
%tag libertinus
\cs_new:Npn \__whu_fn_symbol_libertinus:n #1
  {
    \int_compare:nTF { #1 &amp;gt;= 21 }
      {
        \int_compare:nTF { #1 &amp;gt;= 47 }
          { \__whu_symbol:n { \int_eval:n { &quot;24B6 - 47 + #1 } } }
          { \__whu_symbol:n { \int_eval:n { &quot;24D0 - 21 + #1 } } }
      }
      { \__whu_symbol:n { \int_eval:n { &quot;2460 - 1 + #1 } } }
  }
\cs_new:Npn \__whu_fn_symbol_libertinus_neg:n #1
  {
    \int_compare:nTF { #1 &amp;gt;= 11 }
      { \__whu_symbol:n { \int_eval:n { &quot;24EB - 11 + #1 } } }
      { \__whu_symbol:n { \int_eval:n { &quot;2776 -  1 + #1 } } }
  }
\cs_new_eq:NN \__whu_fn_symbol_libertinus_sans:n \__whu_fn_symbol_libertinus:n
%tag pifont texdoc psnfss2e
\cs_new:Npn \__whu_fn_symbol_pifont:n #1
  { \ding { \int_eval:n { 171 + #1 } } }
\cs_new:Npn \__whu_fn_symbol_pifont_neg:n #1
  { \ding { \int_eval:n { 181 + #1 } } }
\cs_new:Npn \__whu_fn_symbol_pifont_sans:n #1
  { \ding { \int_eval:n { 191 + #1 } } }
\cs_new:Npn \__whu_fn_symbol_pifont_sans_neg:n #1
  { \ding { \int_eval:n { 201 + #1 } } }
%tag xits
\cs_new:Npn \__whu_fn_symbol_xits:n #1
  {
    \int_compare:nTF { #1 &amp;gt;= 10 }
      {
        \int_compare:nTF { #1 &amp;gt;= 36 }
          { \__whu_symbol:n { \int_eval:n { &quot;24B6 - 36 + #1 } } }
          { \__whu_symbol:n { \int_eval:n { &quot;24D0 - 10 + #1 } } }
      }
      { \__whu_symbol:n { \int_eval:n { &quot;2460 - 1 + #1 } } }
  }
\cs_new:Npn \__whu_fn_symbol_xits_sans:n #1
  { \__whu_symbol:n { \int_eval:n { &quot;2780 - 1 + #1 } } }
\cs_new:Npn \__whu_fn_symbol_xits_sans_neg:n #1
  { \__whu_symbol:n { \int_eval:n { &quot;278A - 1 + #1 } } }
%tag 定义脚注计数器格式
\cs_set:Npn \thefootnote { \whu_footnote_number:N \c@footnote }
\cs_new:Npn \whu_footnote_number:N #1
  {
    \tl_case:NnF \l__whu_fn_style_tl
      {
        \c__whu_fn_style_plain_tl
          { \int_use:N #1 }
        \c__whu_fn_style_libertinus_tl
          {
            \fontspec { LibertinusSerif-Regular .otf }
            \__whu_fn_symbol_libertinus:n {#1}
          }
        \c__whu_fn_style_libertinus_neg_tl
          {
            \fontspec { LibertinusSerif-Regular .otf }
            \__whu_fn_symbol_libertinus_neg:n {#1}
          }
        \c__whu_fn_style_libertinus_sans_tl
          {
            \fontspec { LibertinusSans-Regular .otf }
            \__whu_fn_symbol_libertinus_sans:n {#1}
          }
        \c__whu_fn_style_pifont_tl
          { \__whu_fn_symbol_pifont:n {#1} }
        \c__whu_fn_style_pifont_neg_tl
          { \__whu_fn_symbol_pifont_neg:n {#1} }
        \c__whu_fn_style_pifont_sans_tl
          { \__whu_fn_symbol_pifont_sans:n {#1} }
        \c__whu_fn_style_pifont_sans_neg_tl
          { \__whu_fn_symbol_pifont_sans_neg:n {#1} }
        \c__whu_fn_style_xits_tl
          {
            \fontspec { XITS-Regular .otf }
            \__whu_fn_symbol_xits:n {#1}
          }
        \c__whu_fn_style_xits_sans_tl
          {
            \fontspec { XITS-Regular .otf }
            \__whu_fn_symbol_xits_sans:n {#1}
          }
        \c__whu_fn_style_xits_sans_neg_tl
          {
            \fontspec { XITS-Regular .otf }
            \__whu_fn_symbol_xits_sans_neg:n {#1}
          }
      }
      { \int_use:N #1 }
  }
\cs_set:Npn \@makefntext #1
  {
    \mode_leave_vertical:
    \hbox_to_wd:nn { 1 em } { \@thefnmark \hfil }
    \zihao{5}
    #1
  }
%tag 修改脚注的横线长度
\cs_set:Npn \footnoterule
  {\kern-3\p@ \hrule \@width 2in \@height 1pt \kern 2.6\p@ }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;\cs_set:Npn \thefootnote {\whu_footnote_number:N}&lt;/code&gt;重新定义了脚注的编号格式。默认情况下，LaTeX 中脚注的编号是阿拉伯数字，但这里通过 &lt;code&gt;\cs_set:Npn&lt;/code&gt; 命令将其重新定义为调用 &lt;code&gt;\whu_footnote_number:N&lt;/code&gt; 函数，并传递当前脚注计数器的值。&lt;/p&gt;
&lt;p&gt;在&lt;code&gt;\whu_fontnote_number&lt;/code&gt; 中会对 &lt;code&gt;\l__whu_fn_style_tl&lt;/code&gt; 的值进行判断，并依据其 token list 的值生成对应的数字&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;\cs_set:Npn \@makefntext&lt;/code&gt; 设置了脚注文本的格式的命令 &lt;code&gt;\@makefntext&lt;/code&gt;。其保证了:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\mode_leave_vertical:&lt;/code&gt;: 垂直模式处于结束状态&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\hbox_to_wd:nn {1 em} {\@thefnmark \hfil}&lt;/code&gt;: 创建了水平 &lt;code&gt;1em&lt;/code&gt; 的盒子用于容纳脚注标记&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\zihao{5}&lt;/code&gt; 字号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#1&lt;/code&gt; 脚注内容&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;p&gt;&lt;code&gt;\cs_set:Npn \footnoterule&lt;/code&gt;重新定义了 LaTeX 中用于绘制脚注分隔线的命令&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;\kern-3\p@&lt;/code&gt;：这个命令在竖直方向上向上移动 3pt 的距离。&lt;code&gt;3\p@&lt;/code&gt; 表示 3pt，负号表示向上移动。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\hrule&lt;/code&gt;：这个命令用于绘制一条水平线。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@width 2in&lt;/code&gt;：这个命令指定水平线的宽度为 2in（英寸）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;@height 1pt&lt;/code&gt;：这个命令指定水平线的高度为 1pt（点）。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\kern 2.6\p@&lt;/code&gt;：这个命令在竖直方向上向下移动 2.6pt 的距离。&lt;code&gt;2.6\p@&lt;/code&gt; 表示 2.6pt，正号表示向下移动。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这段代码的效果是绘制一个宽度为 2in、高度为 1pt 的水平线，该线的顶部边缘与脚注文本底部略微重叠，与页面底部有一定的间距。&lt;/p&gt;
&lt;h2&gt;符号表&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\NewDocumentEnvironment { notation } { O{符号表} O{lp{7.5cm}} }
  {
    \newpage
    \__whu_notation_begin:n {#1}
    \group_begin:
      \centering
      \tabular{ #2 }
  }
  {
      \endtabular
      \newpage
    \group_end:
  }
\cs_new_protected:Npn \__whu_notation_begin:n #1
  {
    \group_begin:
      \keys_set:nn { ctex }
        {
          chapter / format   += \centering,
          chapter / numbering = false,
          chapter / pagestyle = \tl_use:N \g__whu_thesis_type_tl -frontmatter
        }
      \chapter { #1 }
    \group_end:
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;此处创建了一个 &lt;code&gt;notation&lt;/code&gt; 环境，这种操作和上面的致谢环境很类似。&lt;/p&gt;
&lt;p&gt;在 notation 环境中，会先创建一个居中不带标号且有frontmatter样式页眉的章节，内容为第一个参数（默认是“符号表”），然后创建一个居中的表格，其内容为第二个参数。&lt;/p&gt;
&lt;p&gt;这也意味着在这个环境中，需要用 tabular 环境中的语言来进行书写&lt;/p&gt;
&lt;p&gt;比如说官方示例给出的用法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;\begin{notation}
  $\omega_n$ &amp;amp; $n$-维欧氏空间中单位球的表面积 \\
  $\alpha_n$ &amp;amp; $n$-维欧氏空间中单位球的体积 \\
\end{notation}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;图表&lt;/h2&gt;
&lt;h3&gt;图&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;\DeclareCaptionFont { whufigurecaptionfont }
  { \bfseries \zihao { 5 } }

\DeclareCaptionFont { whutablecaptionfont }
  { \bfseries \zihao { 5 } }

\captionsetup [ figure ]
  {
    font     = whufigurecaptionfont,
    position = bottom,
    labelsep = space
  }
\captionsetup [ table  ]
  {
    font     = whutablecaptionfont,
    position = top,
    labelsep = space
  }
\AddToHook { env / tabular / begin }
  { \zihao{5} }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;改个字体先&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\DeclareCaptionFont&lt;/code&gt; 是 LaTeX 中用于声明和设置图表标题字体的命令。它允许用户自定义图表标题的字体样式，比如字体族、字体大小、字体颜色等。&lt;/p&gt;
&lt;p&gt;通常，&lt;code&gt;\DeclareCaptionFont&lt;/code&gt; 命令被用于在 LaTeX 文档中使用 &lt;code&gt;caption&lt;/code&gt; 宏包时设置图表标题的字体。该命令允许用户指定多种不同的字体样式，并且可以为不同的图表类型设置不同的字体样式。&lt;/p&gt;
&lt;p&gt;这里通过这种方式设置了 figure,table和 tabular 的字体样式&lt;/p&gt;
&lt;h3&gt;定理环境&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;% 去掉 . 号，但只能通过新定义 style 的方式进行
\declaretheoremstyle
  [
    headpunct     = {},
    postheadspace = { 0.5em },
    headindent    = 2\ccwd
  ]
  { whustyle }
\cs_new:Npn \__whu_declare_theorem_with_counter_within:n #1
  {
    \declaretheorem
      [
        style   = whustyle,
        name    = \clist_item:nn {#1} {1} ,
        refname = \clist_item:nn {#1} {2} ,
        within  = \clist_item:nn {#1} {3} ,
      ]
      { \clist_item:nn {#1} {4} }
  }
\cs_new:Npn \__whu_declare_theorem_with_counter_sibling:n #1
  {
    \declaretheorem
      [
        style   = whustyle ,
        name    = \clist_item:nn {#1} {1} ,
        refname = \clist_item:nn {#1} {2} ,
        sibling = \clist_item:nn {#1} {3} ,
      ]
      { \clist_item:nn {#1} {4} }
  }

\clist_map_function:nN
  {
    { 定理, 定理, section, theorem },
    { 例, 例, section, example },
    { 问题, 问题, section, question },
    { 定义, 定义, section, definition },
    { 性质, 性质, section, property },
    { 命题, 命题, section, proposition },
    { 推论, 推论, section, corollary },
    { 引理, 引理, section, lemma },
    { 公理, 公理, section, axiom },
    { 反例, 反例, section, counterexample },
    { 猜想, 猜想, section, conjecture },
    { 断言, 断言, section, claim },
    { 注, 注, section, remark }
  }
  \__whu_declare_theorem_with_counter_within:n

\NewDocumentCommand { \whunewtheorem } { s O{} m m }
  {
    \IfBooleanTF {#1}
      {
        % 有*
        \declaretheorem
          [
            style = whustyle,
            name =  #4 ,
            refname = #4 ,
            numbered = no,
            #2
          ]
          { #3 }
      }
      {
        % 无*
        \declaretheorem
          [
            style = whustyle,
            name =  #4 ,
            refname = #4 ,
            #2
          ]
          { #3 }
      }
  }

% 重定义 proof 环境的样式
\RenewDocumentEnvironment { proof } { O{\proofname} +b }
  {
    \par
    \pushQED { \qed }
    \normalfont \topsep6 \p@ \@plus6 \p@ \relax
    \trivlist
    \item \relax
    \group_begin:
      \hspace*{2\ccwd}
      \bfseries #1 \@addpunct{:}
    \group_end:
    \hspace \labelsep \ignorespaces
    #2
  }
  {
    \popQED \endtrivlist \@endpefalse
  } +

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;\declaretheoremstyle&lt;/code&gt; 是用于声明定理环境样式的命令。在这个例子中，一个名为 &lt;code&gt;whustyle&lt;/code&gt; 的定理样式被声明。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;headpunct = {}&lt;/code&gt; 表示定理标题和定理内容之间的标点为空。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;postheadspace = {0.5em}&lt;/code&gt; 表示在定理标题和定理内容之间添加 0.5em 的额外空间。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;headindent = 2\ccwd&lt;/code&gt; 表示定理标题的缩进量为 2 个“当前字宽”的长度。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来通过 &lt;code&gt;\clist_map_function:nN&lt;/code&gt; 依次将不同环境的标题参数传入 &lt;code&gt;\__whu_declare_theorem_with_counter_within&lt;/code&gt; 来创建对应的定理环境。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;不过我没看到 &lt;code&gt;\__whu_declare_theorem_with_counter_sibling&lt;/code&gt;在哪里用到了&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;\RenewDocumentEnvironment { proof } { O{\proofname} +b }&lt;/code&gt;: 这一行声明了一个名为 &lt;code&gt;proof&lt;/code&gt; 的环境，并接受两个参数。第一个参数是可选的，用于指定证明环境的名称，默认值为 &lt;code&gt;\proofname&lt;/code&gt;（通常是“证明”）。第二个参数是必选的，用于指定证明环境的内容。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在环境的开头部分，进行了一些设置：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\par&lt;/code&gt;：开始新的段落。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\pushQED{\qed}&lt;/code&gt;：将证明环境的结束标志（通常是一个小方块，表示证明结束）推入证明结束的队列中，以便在证明结束时自动添加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\normalfont&lt;/code&gt;：设置字体为正常字体。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\topsep6\p@\@plus6\p@\relax&lt;/code&gt;：设置顶部间距为 6pt，允许额外的 6pt 弹性间距。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\trivlist&lt;/code&gt;：开始一个列表环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\item\relax&lt;/code&gt;：开始一个新的项，并使用 &lt;code&gt;\relax&lt;/code&gt; 避免出现意外的空白。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\group_begin:&lt;/code&gt;：开始一个分组，用于限制样式设置的作用范围。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\hspace*{2\ccwd}&lt;/code&gt;：插入一个长度为 2 个当前字符宽度的水平空白，用于缩进证明环境的标题。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\bfseries #1\@addpunct{：}&lt;/code&gt;：设置证明环境的标题为加粗字体，标题内容为参数 1（即&lt;code&gt;\proofname&lt;/code&gt; 或者自定义的标题），并加上一个冒号。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\group_end:&lt;/code&gt;：结束分组。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\hspace\labelsep&lt;/code&gt;：插入一个标签和文本之间的空白距离。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\ignorespaces&lt;/code&gt;：忽略环境开始时可能存在的空格。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;在环境的结束部分，进行了一些清理工作：
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;\popQED&lt;/code&gt;：弹出证明结束的标志，以便在证明环境结束时不再添加。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\endtrivlist&lt;/code&gt;：结束列表环境。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;\@endpefalse&lt;/code&gt;：确保不在环境结束时在段落后插入额外的垂直空白。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;效果：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240509030346271.png&quot; alt=&quot;image-20240509030346271&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20240509031435079.png&quot; alt=&quot;image-20240509031435079&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;钩子管理&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;% 封装 LaTeX 的钩子管理机制。本模板中的字体加载命令位于
% begindocument/before 钩子中，需确保在 xeCJK 之前执行。
\cs_new_protected:Npn \__whu_gadd_ltxhook:nn #1#2
  { \hook_gput_code:nnn {#1} { . } {#2} }
\hook_gset_rule:nnnn { begindocument/before } { . } { &amp;lt; } { xeCJK }

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;和 &lt;a href=&quot;#?&quot;&gt;上面的&lt;/a&gt; 一样，看不懂 :(&lt;/p&gt;
&lt;h2&gt;参考文献&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;%tag 定义变量
\tl_new:N \l__whu_bib_backend_tl        % 参考文献后端
\tl_new:N \l__whu_bib_style_tl          % 参考文献格式，接受其它值
\tl_new:N \l__whu_bib_gb_style_tl       % 参考文献格式（国标），接受 numerical 和 author-year 两个值
\tl_new:N \l__whu_cite_style_tl         % 参考文献引用格式
\clist_new:N \l__whu_bib_resource_clist % 参考文献 database
%tag 定义键
\keys_define:nn { whu / style }
  {
    bib-backend .choice:,
    bib-backend .value_required:n = true,
    bib-backend / bibtex   .code:n =
      { \tl_set:Nn \l__whu_bib_backend_tl { bibtex } },
    bib-backend / biblatex .code:n =
      {
        \tl_set:Nn \l__whu_bib_backend_tl { biblatex }
        \NewDocumentCommand \addbibresource { m }
          { \clist_gput_right:Nn \l__whu_bib_resource_clist {#1} }
      },
    bib-style .choice:,
    bib-style .value_required:n = true,
    bib-style / numerical   .code:n =
      {
        \tl_set:Nn  \l__whu_bib_gb_style_tl { numerical  }
        \tl_clear:N \l__whu_bib_style_tl
      },
    bib-style / author-year .code:n =
      {
        \tl_set:Nn  \l__whu_bib_gb_style_tl { author-year }
        \tl_clear:N \l__whu_bib_style_tl
      },
    bib-style / unknown     .code:n =
      {
        \tl_set_eq:NN \l__whu_bib_style_tl \l_keys_value_tl
        \tl_clear:N   \l__whu_bib_gb_style_tl
      },
    cite-style .tl_set:N = \l__whu_cite_style_tl,
    bib-resource .clist_set:N = \l__whu_bib_resource_clist
  }
%tag 设置参考文献格式默认值
% 本科默认使用顺序编码制，硕博默认使用著者-出版年制
\tl_if_eq:NnTF \g__whu_thesis_type_tl { bachelor }
  {
    \keys_set:nn { whu / style } { bib-style = numerical }
  }
  {
    \keys_set:nn { whu / style } { bib-style = author-year }
  }
%region 加载宏包
%tag bibtex 此时分两种情况：
% Case 1. bib-style = numerical or author-year，则调用 gbt7714 宏包，此宏包内部调用 natbib 宏包
% Case 2. otherwise，直接调用 natbib
\ctex_at_end_preamble:n
  {
    \tl_if_eq:NnT \l__whu_bib_backend_tl { bibtex }
      {
        \tl_if_empty:NTF \l__whu_bib_style_tl
          {
            \RequirePackage [ sort &amp;amp; compress ] { gbt7714 }
            \tl_if_eq:NnTF \g__whu_thesis_type_tl { bachelor }
              {
                \exp_args:No \bibliographystyle
                  { gbt7714- \l__whu_bib_gb_style_tl }
              }
              {
                \exp_args:No \bibliographystyle
                  { gbt7714-2005- \l__whu_bib_gb_style_tl }
              }
          }
          {
            \RequirePackage [ sort &amp;amp; compress ] { natbib }
            \exp_args:No \bibliographystyle
              { \l__whu_bib_style_tl }
          }
        \__whu_bibtex_setup:
      }
  }

%tag biblatex 调用 biblatex 宏包
% biblatex 会写入 begindocument/before 钩子，因此需在其之前通过
% env/document/begin 钩子载入 biblatex 宏包。注意这个
% 钩子仅适用于 \begin{document} 的写法，对于 \document 命令本身无效。
\__whu_gadd_ltxhook:nn { env/document/begin }
  {
    \tl_if_eq:NnT \l__whu_bib_backend_tl { biblatex }
      {
        \__whu_biblatex_pre_setup:
        \RequirePackage { biblatex }
        \__whu_biblatex_post_setup:
      }
  }
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;bibtex&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;\cs_new_protected:Npn \__whu_bibtex_setup:
  {
    \tl_if_eq:NnTF \l__whu_bib_gb_style_tl { numerical }
      {
        \exp_args:NNx \DeclareRobustCommand \parencite
          { \exp_args:No \exp_not:o { \cs:w cite ~ \cs_end: } }
        \exp_args:Nc \ctex_patch_cmd:Nnn { parencite ~ }
          { \begingroup }
          { \begingroup \bibstyle@numbers }
      }
      { \cs_set_eq:NN \parencite \cite }
    % 设置引用格式
    \tl_if_empty:NF \l__whu_cite_style_tl
      { \exp_args:NV \citestyle \l__whu_cite_style_tl }
    % 使用 \textendash 作为数字间的连接号
    \ctex_patch_cmd:Nnn \NAT@citexnum
      { - \NAT@penalty }
      { \textendash \NAT@penalty }
    \cs_set:Npn \bibsection { \__whu_chapter:V \bibname }
    % 让 bibtex 的接口与 biblatex 保持一致
    \NewDocumentCommand \printbibliography { o }
      {
        \exp_args:NV \bibliography \l__whu_bib_resource_clist
        \IfValueT {##1}
          { \__whu_warning:nn { invalid-option-in-bibtex } {##1} }
      }
  }
\__whu_msg_new:nn { invalid-option-in-bibtex }
  { Option(s)~ &quot;#1&quot;~ are~ invalid~ in~ BibTeX. }
%tag biblatex相关设置
\cs_new_protected:Npn \__whu_biblatex_pre_setup:
  {
    \cs_undefine:N \addbibresource
    \clist_new:N \l__whu_biblatex_options_clist
    \clist_put_right:Nn \l__whu_biblatex_options_clist { hyperref = manual }
    \clist_put_right:Nx \l__whu_biblatex_options_clist % 参考文献样式
      {
        style =
        \tl_if_empty:NTF \l__whu_bib_style_tl
          {
            \tl_if_eq:NnTF \g__whu_thesis_type_tl { bachelor }
              {
                \str_if_eq:VnTF \l__whu_bib_gb_style_tl { numerical }
                  { gb7714-2015 } { gb7714-2015ay }
              }
              {
                \str_if_eq:VnTF \l__whu_bib_gb_style_tl { numerical }
                  { gb7714-2005 } { gb7714-2005ay }
              }
          }
          { \l__whu_bib_style_tl }
      }
    \tl_if_empty:NF \l__whu_cite_style_tl % 引用样式
      {
        \clist_put_right:Nx \l__whu_biblatex_options_clist
          { citestyle = \l__whu_cite_style_tl }
      }
    \exp_args:NV \PassOptionsToPackage \l__whu_biblatex_options_clist
      { biblatex }
  }
\cs_new_protected:Npn \__whu_biblatex_post_setup:
  {
    \clist_map_function:NN \l__whu_bib_resource_clist \addbibresource
    \__whu_biblatex_allow_url_break:
    \__whu_biblatex_use_en_dash:
    \defbibheading { bibliography } [ \bibname ] { \__whu_chapter:n {##1} }
  }
% biblatex 下允许 URL 在字母、数字和一些特殊符号处断行
\cs_new:Npn \__whu_biblatex_allow_url_break:
  {
    \int_set_eq:NN \c@biburlucpenalty  \c_one_int
    \int_set_eq:NN \c@biburlnumpenalty \c_one_int
    \int_set_eq:NN \c@biburllcpenalty  \c_one_int
  }
% 使用 \textendash 作为数字间的连接符
\cs_new:Npn \__whu_biblatex_use_en_dash:
  {
    \DefineBibliographyExtras { english }
      {
        \cs_set_nopar:Npn \bibrangedash
          { \textendash \penalty \hyphenpenalty }
      }
    \DefineBibliographyExtras { russian }
      {
        \cs_set_nopar:Npn \bibrangedash
          { \textendash \penalty \hyphenpenalty }
      }
  }
%endregion 参考文献

%tag full-width stop
\keys_define:nn { whu / style }
  {
    fullwidth-stop .choice:,
    fullwidth-stop .value_required:n = true,
    fullwidth-stop / catcode .code:n =
      { \__whu_set_fullwidth_stop_catcode: },
    fullwidth-stop / mapping .code:n =
      {
        \sys_if_engine_xetex:TF
          {
            \clist_gset:Nn \g__xeCJK_default_features_clist
              { Mapping = fullwidth-stop }
          }
          {
            \sys_if_engine_luatex:T
              {
                \__whu_warning:n { mapping-not-available }
                \__whu_set_fullwidth_stop_catcode:
              }
          }
      },
    fullwidth-stop / false .code:n = { }
  }
\__whu_msg_new:nn { mapping-not-available }
  {
    Option~ &quot;fullwidth-stop = mapping&quot;~ is~ not~ available~ in~ LuaTeX. \\
    &quot;fullwidth-stop = catcode&quot;~ will~ be~ set~ instead.
  }
\cs_new:Npn \__whu_set_fullwidth_stop_catcode:
  {
    \char_set_active_eq:NN ^^^^3002 \c__whu_fwid_full_stop_tl
    \char_set_catcode_active:N ^^^^3002
    \clist_map_inline:nn
      { \c__whu_orig_decl_text_tl, \c__whu_auth_decl_text_tl }
      { \tl_set_rescan:Nno ##1 { } {##1} }
  }
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>LaTeX</category><category>山东财经大学</category><author>Mslxl</author></item><item><title>新春快乐</title><link>https://blog.mslxl.com/posts/others/2024-new-start/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/2024-new-start/</guid><description>时间总是在匆忙间悄悄溜走，曾经坚定的那些遥遥无期都已沦为了转身的天涯...</description><pubDate>Sat, 10 Feb 2024 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;时间总是在匆忙间悄悄溜走，曾经坚定的那些遥遥无期都已沦为了转身的天涯...&lt;/p&gt;
&lt;p&gt;很多计划还来不及执行&lt;/p&gt;
&lt;p&gt;很多设想还来不及规划&lt;/p&gt;
&lt;p&gt;很多美好还来不及体会&lt;/p&gt;
&lt;p&gt;但是，因幡之白兔却不再给予机会&lt;/p&gt;
&lt;p&gt;今天，她正式与我们告别，新春快乐wwww&lt;/p&gt;
</content:encoded><author>Mslxl</author></item><item><title>可靠 UDP 协议(RUDP协议)</title><link>https://blog.mslxl.com/posts/net/reliable-udp-translation/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/net/reliable-udp-translation/</guid><description>古早时期已过期的可靠 UDP 草案，也许还有些许价值</description><pubDate>Sun, 21 Jan 2024 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;此草案已过期，未成为事实标准&lt;/p&gt;
&lt;p&gt;原文地址: &lt;a href=&quot;https://datatracker.ietf.org/doc/html/draft-ietf-sigtran-reliable-udp-00.txt&quot;&gt;draft-ietf-sigtran-reliable-udp-00&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;1. 介绍&lt;/h2&gt;
&lt;p&gt;此互联网草案讨论了可靠UDP协议（RUDP）。RUDP是一个简单的基于数据包的传输协议。RUDP 基于 RFCs 1151 和 908 可靠数据协议。RUDP 位于UDP/IP 协议之上，为上层每个虚拟连接提供不超过最大重传次数的可靠的有序的数据传递。RUDP 具有灵活的设计，即它适用于多种传输用途，比如传输电信信号等&lt;/p&gt;
&lt;h3&gt;1.1 背景&lt;/h3&gt;
&lt;p&gt;跨 IP 网络的远程信号传输需要一种可靠的传输协议，这种传输协议的架构必须能够为多种应用在IP网提供传输服务&lt;/p&gt;
&lt;p&gt;对现有的 IP 协议进行审查，可得出：需要一种新的可靠传输机制来用于电信信号协议。这种协议需要满足下列标准：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;传输需要提供不超过最大重传次数的可靠传递服务（因此可避免旧消息滞留）&lt;/li&gt;
&lt;li&gt;传输需要保证消息有序传递&lt;/li&gt;
&lt;li&gt;传输基于消息报&lt;/li&gt;
&lt;li&gt;传输提供流量控制&lt;/li&gt;
&lt;li&gt;传输应该是低开销，高性能的&lt;/li&gt;
&lt;li&gt;每个虚拟连接应该是可配置的（比如定时器）&lt;/li&gt;
&lt;li&gt;传输应该提供保活机制&lt;/li&gt;
&lt;li&gt;传输应当提供错误检测机制&lt;/li&gt;
&lt;li&gt;应当保证安全传输&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;RUDP 旨在允许单独配置每个连接，以便可以在同一平台上同时实现具有不同传输要求的多种协议。&lt;/p&gt;
&lt;h3&gt;1.2 数据结构格式&lt;/h3&gt;
&lt;h4&gt;1. 用于数据传输的 6 个八位位组最小 RUDP 头部&lt;/h4&gt;
&lt;p&gt;每个由 RUDP 发送的 UDP 包的首部必须由 6 个八位位组的头部开始。第一个位组包含 8 个单独的 flags 位。接下来 3 个位组形成3个字段，每次字段占1个八位位组，分别是头长度(Header length)，序列号(Sequence number) 和确认号 (Acknowledgment number)。这三个字段后面是校验和，占2个位组。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    0 1 2 3 4 5 6 7 8            15
   +-+-+-+-+-+-+-+-+---------------+
   |S|A|E|R|N|C|T| |    Header     |
   |Y|C|A|S|U|H|C|0|    Length     |
   |N|K|K|T|L|K|S| |               |
   +-+-+-+-+-+-+-+-+---------------+
   |  Sequence #   +   Ack Number  |
   +---------------+---------------+
   |            Checksum           |
   +---------------+---------------+
        Figure 1, RUDP Header
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;控制位(Control bits)&lt;/h5&gt;
&lt;p&gt;控制位指示数据包中存在的内容。 SYN 位表示存在同步段。 ACK 位表示头中的确认号有效。 EACK 位表示存在扩展确认段。 RST位表示数据包是一个复位段。 NUL 位指示数据包是空段。 TCS 位指示该数据包是传输连接状态段。SYN， EACK， RST 和 TCS 互斥。当 NUL 位置1时，ACK位同时置1。CHK 位指示校验和字段仅包含标头或同时包含标头的校验和和主体（数据）。如果 CHK 位为零，则校验和字段 仅包含标头的校验和。如果 CHK 位为 1，则校验和字段包含报头和数据的校验和。&lt;/p&gt;
&lt;h5&gt;头长度(Header length)&lt;/h5&gt;
&lt;p&gt;头长度字段指示用户数据在数据包中的开始位置。 如果数据包的总长度大于标头的值，则数据包中存在用户数据。用户数据不能存在在设置了 EACK、NULL 或 RST 位的数据包中。包含用户数据的数据包中始终设置了 ACK 位，称为数据段。&lt;/p&gt;
&lt;h5&gt;序列号(Sequence number)&lt;/h5&gt;
&lt;p&gt;每个包包含一个序列号。当连接初次建立时，每个对等体随机选择一个初始序列号。序列号在同步段中用于打开连接。每次传输数据，发送空段或者重置都会增加序列号。&lt;/p&gt;
&lt;h5&gt;确认号(Acknowledgment Number)&lt;/h5&gt;
&lt;p&gt;确认号指示所接受到的最后一个有序分组的序列号&lt;/p&gt;
&lt;h5&gt;检验和(Checksum)&lt;/h5&gt;
&lt;p&gt;为了确保数据的完整性，在 RUDP 的头部总是会计算校验和。此外，当 CHK 位被置为 1 时，检验和同时计算头和数据的内容。RUDP 的校验和算法应当采用和 UDP 或 TCP 相同的检验和算法，即每16位数据位的二进制反码相加然后再进行取反。&lt;/p&gt;
&lt;h4&gt;2. 同步段(SYN Segment)&lt;/h4&gt;
&lt;p&gt;同步段用于建立连接，同时同步两个主机的序列号。同步段同时还包含两个连接的协商参数。对等方必须知道的所有可配置参数都包含在此段中。这包括本地 RUDP 愿意接受段的最大数量和正在建立的连接的选项的标志位。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
    0             7 8            15
   +-+-+-+-+-+-+-+-+---------------+
   | |A| | | | | | |               |
   |1|C|0|0|0|0|0|0|       28      |
   | |K| | | | | | |               |
   +-+-+-+-+-+-+-+-+---------------+
   +  Sequence #   +   Ack Number  |
   +---------------+---------------+
   | Vers  | Spare | Max # of Out  |
   |       |       | standing Segs |
   +---------------+---------------+
   | Option Flags  |     Spare     |
   +---------------+---------------+
   |      Maximum Segment Size       |
   +---------------+---------------+
   | Retransmission Timeout Value  |
   +---------------+---------------+
   | Cumulative Ack Timeout Value  |
   +---------------+---------------+
   |   Null Segment Timeout Value  |
   +---------------+---------------+
   | Transfer State Timeout Value  |
   +---------------+---------------+
   |  Max Retrans  | Max Cum Ack   |
   +---------------+---------------+
   | Max Out of Seq| Max Auto Reset|
   +---------------+---------------+
   |    Connection Identifier      |
   +                               +
   |      (32 bits in length)      |
   +---------------+---------------+
   |           Checksum            |
   +---------------+---------------+

        Figure 2, SYN segment
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;序列号(Sequence Number)&lt;/h5&gt;
&lt;p&gt;该字段包含了此连接选择的初始序列号&lt;/p&gt;
&lt;h5&gt;确认号(Acknowledgement Number)&lt;/h5&gt;
&lt;p&gt;该字段当且仅当 ACK 标志位置 1 时才有效。在这种情况下，该字段将会包含接受到的 RUDP 的序列号&lt;/p&gt;
&lt;h5&gt;版本号(Version)&lt;/h5&gt;
&lt;p&gt;使用的 RUDP 版本号。初始值为 1。&lt;/p&gt;
&lt;h5&gt;最大未完成段数列(Maximum Number of Outstanding Segments)&lt;/h5&gt;
&lt;p&gt;未收到 ACK 时能发送的最大分片。 被接收端用作流控手段。连接建立时确定，在通信过程中不会改变。发送数据时，每端必须使用对端提供的值。&lt;/p&gt;
&lt;h5&gt;选项标志字段(Options Flag Field)&lt;/h5&gt;
&lt;p&gt;这个两个八位位组的字段包含一组选项标志，指定此连接所需的一组可选功能。 标志的初步子集定义如下：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Bit&lt;/th&gt;
&lt;th&gt;#&lt;/th&gt;
&lt;th&gt;Bit Name&lt;/th&gt;
&lt;th&gt;Description&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;未使用&lt;/td&gt;
&lt;td&gt;未使用，必须设置为 1&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;CHK&lt;/td&gt;
&lt;td&gt;启用数据校验和。如果该位被启用，那么校验和字段应该包含整个 RUDP 包的校验和（头和数据）。这是一个协商字段&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;REUSE&lt;/td&gt;
&lt;td&gt;该位必须在自动复位(auto reset)期间设置，以指示应使用先前的可协商参数。当该位设置时，SYN 的以下字段应由发送方设置为零，并且必须由接收方忽略：最大段大小(Maximun Segment Size)、重传超时值(Retransmission Timeout Value)、累积确认超时值(Cumulative Ack Timeout Value)、最大重传数(Max Retransmissions)、最大累积确认数(Max Cumulative Ack)、最大超时数顺序(Max Out of Sequence)和最大自动重置次数(Max Auto Reset)。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3-7&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;Spare&lt;/td&gt;
&lt;td&gt;留空备用&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h5&gt;最大段大小(Maximum Segment Size)&lt;/h5&gt;
&lt;p&gt;发送该 SYN 段消息的对等体可以接收的最大八位字节数。每一个对等体都可以指定一个不同的数值。每个对等体不可发送多于对方在连接协商时发送的这个域的值。这个数值应当也包含 RUDP 头的大小。这不是一个协商字段&lt;/p&gt;
&lt;h5&gt;重传超时时间(Retransmission Timeout Value)&lt;/h5&gt;
&lt;p&gt;对于未确认的报文的超时重传时间。这个值以毫秒表示，有效值区间为 100 到 65536. 这是一个协商字段，对等双方必须在这个参数上达成一致。&lt;/p&gt;
&lt;h5&gt;累积确认超时时间(Cumulative Ack Timeout Value)&lt;/h5&gt;
&lt;p&gt;如果没有收到其他确认段时，超时发送确认段的时间。该字段以毫秒表示，有效值为 100 到 65536。这是一个协商字段，对等双方必须在这个参数上达成一致。此外，这个值应当比&lt;a href=&quot;#%E9%87%8D%E4%BC%A0%E8%B6%85%E6%97%B6%E6%97%B6%E9%97%B4retransmission-timeout-value&quot;&gt;超时重传时间&lt;/a&gt;小&lt;/p&gt;
&lt;h5&gt;心跳时间(Null Segment Timeout Value)&lt;/h5&gt;
&lt;p&gt;如果没有收到其他数据段时，超时发送 null 段的时间。null 段作为保活机制发挥作用，目的在于心跳。这个值以毫秒表示，取值范围为 0 到 65536。0代表禁用 null 段。这是一个协商字段，对等双方必须在这个参数上达成一致。&lt;/p&gt;
&lt;h5&gt;发送状态超时时间（Transfer State Timeout Value）&lt;/h5&gt;
&lt;p&gt;此超时值表示在自动重置发生之前为连接保存状态信息的时间量。这个值以毫秒表示，取值范围为 0 到 65536。这是一个协商字段，对等双方必须在这个参数上达成一致。取值为 0 则代表连接将会立刻自动重置。&lt;/p&gt;
&lt;h5&gt;最大重传次数(Max Retrans)&lt;/h5&gt;
&lt;p&gt;在认为连接断开之前，最大尝试重传的次数。取值 0 到 255。0 表示永远尝试重传而不认为是连接断开。这是一个协商字段，对等双方必须在这个参数上达成一致。&lt;/p&gt;
&lt;h5&gt;最大累计确认(Max Cum Ack)&lt;/h5&gt;
&lt;p&gt;如果未发送另一个段（指捎带确认）之前允许累积的最大确认数 。取值 0 到 255。如果取值为 0 则表示不进行累计确认，在收到数据段(data segment)，空段(null segment) 或者重置段(reset segment)时会立刻确认。这是一个协商字段，对等双方必须在这个参数上达成一致。&lt;/p&gt;
&lt;h5&gt;最大失序数(Max Out of Seq)&lt;/h5&gt;
&lt;p&gt;在发送 EACK 之前最大允许的失序数据报的积累数量。取值 0 到 255. 取值为0表示在收到失序报文后立刻发送 EACK。这是一个协商字段，对等双方必须在这个参数上达成一致。&lt;/p&gt;
&lt;h5&gt;最大自动复位（Max Auto Reset）&lt;/h5&gt;
&lt;p&gt;在连接被重置前，可执行连续自动复位的最大次数。取值 0 到 255. 0表示不会尝试自动复位。 这是一个协商字段，对等双方必须在这个参数上达成一致。当连接打开时，连续自动复位计数器应被清空。&lt;/p&gt;
&lt;h5&gt;连接标识(Connection Identifier)&lt;/h5&gt;
&lt;p&gt;建立一个新的连接时，对等双方会通过当前RUDP连接传输一个唯一的连接 ID 给对方。双方均保存这个唯一ID。当自动复位发生时，对等双方应该发送原本保存的 ID 来指示当前连接正在发生自动复位。&lt;/p&gt;
&lt;h4&gt;3. ACK 段&lt;/h4&gt;
&lt;p&gt;ACK 段用于确认有序段到达。它在RUDP头中包含接下来发送的序列号和确认序列号。ACK 段可以单独发送，也可以和数据组合进行捎带发送。Data 和 Null 段中必须设置 Ack 控制位(ACK bit)和确认号字段（Acknowledge Number field)。单独的确认段有 6 个八位位组。图 3 反应了一个单独的 ACK 段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    0 1 2 3 4 5 6 7 8            15
   +-+-+-+-+-+-+-+-+---------------+
   |0|1|0|0|0|0|0|0|       6       |
   +-+-+-+-+-+-+-+-+---------------+
   | Sequence #    |   Ack Number  |
   +---------------+---------------+
   |           Checksum            |
   +---------------+---------------+

    Figure 3, Stand-alone ACK segment
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;4. EACK 段&lt;/h4&gt;
&lt;p&gt;EACK 段用于确认到达的失序段。它包含一个或多个接收到的失序序列号。 EACK 总是应该和 ACK 段进行组合，并给出未失序情况下应当接收到的序号。对于 EACK 段来说，头的长度是一个变量。它最小是 7，最大取决于于最大接收队列长度。图 4 反应了单独的 EACK 段&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    0 1 2 3 4 5 6 7 8            15
   +-+-+-+-+-+-+-+-+---------------+
   |0|1|1|0|0|0|0|0|     N + 6     |
   +-+-+-+-+-+-+-+-+---------------+
   | Sequence #    |   Ack Number  |
   +---------------+---------------+
   |1st out of seq |2nd out of seq |
   |  ack number   |   ack number  |
   +---------------+---------------+
   |  . . .        |Nth out of seq |
   |               |   ack number  |
   +---------------+---------------+
   |            Checksum           |
   +---------------+---------------+

       Figure 4, EACK segment

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;5. RST 段&lt;/h4&gt;
&lt;p&gt;RST 段用于关闭或重置连接。在受到RST 段后，发送方应当在将从 API 接受到的数据包发送后停止发送新的数据报，在此期间停止API停止接受新数据。RST 段应当被单独发送且不包含任何数据。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    0 1 2 3 4 5 6 7 8            15
   +-+-+-+-+-+-+-+-+---------------+
   | |A| | | | | | |               |
   |0|C|0|1|0|0|0|0|        6      |
   | |K| | | | | | |               |
   +-+-+-+-+-+-+-+-+---------------+
   | Sequence #    |   Ack Number  |
   +---------------+---------------+
   |         Header Checksum       |
   +---------------+---------------+

          Figure 5, RST segment
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;6. NUL 段&lt;/h4&gt;
&lt;p&gt;NUL 段用于判断连接是否存活。因此 NUL 段作为保活机制发挥作用。当收到 NUL 段时，在连接合法的情况下RUDP 实现必须立刻发送确认，序列号为下一个应受到的序列号。NUL 段必须和 ACK 组合，但不和用户数据组合。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    0 1 2 3 4 5 6 7 8            15
   +-+-+-+-+-+-+-+-+---------------+
   |0|1|0|0|1|0|0|0|       6       |
   +-+-+-+-+-+-+-+-+---------------+
   | Sequence #    |  Ack Number   |
   +---------------+---------------+
   |            Checksum           |
   +---------------+---------------+

        Figure 6, NUL segment

&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;7. TCS 段&lt;/h4&gt;
&lt;p&gt;TCS 用于传输状态信息&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;    0 1 2 3 4 5 6 7 8            15
   +-+-+-+-+-+-+-+-+---------------+
   | |A| | | | | | |               |
   |0|C|0|0|0|0|1|0|       12      |
   | |K| | | | | | |               |
   +-+-+-+-+-+-+-+-+---------------+
   | Sequence #    |   Ack Number  |
   +---------------+---------------+
   | Seq Adj Factor|      Spare    |
   +---------------+---------------+
   |      Connection Identifier    |
   |       (32 bits in length)     |
   +---------------+---------------+
   |            Checksum           |
   +---------------+---------------+

          Figure 7, TCS segment
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;序列号(Sequence Number)&lt;/h5&gt;
&lt;p&gt;序列号字段包含该连接选择的初始序列号&lt;/p&gt;
&lt;h5&gt;确认号(Acknowledgement Number)&lt;/h5&gt;
&lt;p&gt;确认号指示收到的按序传输的最后一个数据包&lt;/p&gt;
&lt;h5&gt;序列调整因子(Seq Adj Factor)&lt;/h5&gt;
&lt;p&gt;这个字段用于在旧连接和新连接之间在传输阶段调整序列号的状态&lt;/p&gt;
&lt;h5&gt;连接标识(Connection Identifier)&lt;/h5&gt;
&lt;p&gt;建立一个新的连接时，对等双方会通过当前RUDP连接传输一个唯一的连接 ID 给对方。双方均保存这个唯一ID。当自动复位发生时，对等双方应该发送原本保存的 ID 来指示当前连接正在发生自动复位。&lt;/p&gt;
&lt;h4&gt;1.2.1 详细设计&lt;/h4&gt;
&lt;p&gt;单独的一份使用 SDL 格式描述连接状态和传输的互联网草案还在准备中。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;1999年就过期了，不会有了&lt;/s&gt;&lt;/p&gt;
&lt;h4&gt;1.2.2 功能描述&lt;/h4&gt;
&lt;h5&gt;1. 重传定时器&lt;/h5&gt;
&lt;p&gt;发送端有重传定时器，超时时间可配。每次发送 data，null 或 reset 段并且当前没有一个片段被计时，都会初始化此计时器。&lt;/p&gt;
&lt;p&gt;如果在定时器到期时未收到对此数据段的确认，则重发已发送但未确认的所有分片。如果仍有一个或多个已发送但未确认的数据包，则在收到定时段时重启重传定时器。 重传定时器的推荐值为600毫秒。&lt;/p&gt;
&lt;h5&gt;2. 重传计数器&lt;/h5&gt;
&lt;p&gt;发送端维护一个重发次数的计数器，计数器最大值可配，建议为 2。如果计数器超过其最大值，则认为连接已断开。&lt;/p&gt;
&lt;h5&gt;3. 独立 ACK 分片&lt;/h5&gt;
&lt;p&gt;独立 ACK 段是仅包含确认信息的段。 其 sequence number 字段包含要发送的下一个 data，null 或 reset 段的序列号。&lt;/p&gt;
&lt;h5&gt;4. ACK 信息捎带&lt;/h5&gt;
&lt;p&gt;当接收端向发送端发送 data，null 或 reset 段时，接收端需要在报头的 ACK 中填上最后的一次从发送端收到的 data，null 或 reset 段的序列号。&lt;/p&gt;
&lt;h5&gt;5. 累积 ACK 计数器&lt;/h5&gt;
&lt;p&gt;接收端维持接收到的未确认分片的计数器，计数器的最大值可配。 如果超过计数器的最大值，则接收端发送独立 ACK 或 EACK（如果存在无序分片）。 累积 ACK 计数器的建议值为3。&lt;/p&gt;
&lt;h5&gt;6. 无序 ACK 计数器&lt;/h5&gt;
&lt;p&gt;接收端维护一个已经无序到达的分片的计数器。当计数器超过配置的最大值时，发送一个包含已经接收的所有当前无序段的序列号的 EACK 段到发送端，然后计数器重置为零。无序 ACK 计数器的建议值为3。&lt;/p&gt;
&lt;p&gt;当发送端接收到 EACK 时，会将丢失的数据段重新发送给接收端。&lt;/p&gt;
&lt;h5&gt;7. 累积 ACK 分片定时器&lt;/h5&gt;
&lt;p&gt;当接收端有未确认的分片或无序队列中有分片时，它会分别在发送独立确认或扩展确认之前等待最长时间。 当此定时器到期时，如果在无序队列中存在分片，则发送扩展确认。 否则，如果当前有未确认分片，则发送独立确认。 累积 ACK 定时器的建议值为 300 毫秒。&lt;/p&gt;
&lt;p&gt;每当在数据，空或重置段中发送确认时，重新启动累积 ACK 定时器，前提是当前没有分片在无序列队列中。 如果序列外队列中存在分片，则不会重新启动定时器，以便在再次到期时再发送另一个扩展确认。&lt;/p&gt;
&lt;h5&gt;8. NULL 段定时器&lt;/h5&gt;
&lt;p&gt;Client 维护一个定时器，连接打开时启动，每次发送数据段时重置。如果 Client 的 NULL 段定时器到期，则 Client 将 NULL 段发送到 Server。&lt;/p&gt;
&lt;p&gt;如果 Server 的序列号有效，则由 Server 确认空段。 Server 维护一个空段定时器，其超时值是 Client 超时值的两倍。&lt;/p&gt;
&lt;p&gt;只要从 Client 收到数据或空段，Server 的计时器就会重置。 如果 Server 的空段定时器到期，则认为连接已断开。空段定时器的值是 2 秒。&lt;/p&gt;
&lt;h5&gt;9. 自动重置&lt;/h5&gt;
&lt;p&gt;连接的任何一方都可以自动重置。自动重置的原因可能是&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重传计数超过其最大值&lt;/li&gt;
&lt;li&gt;服务器的 NULL 段计时器到期&lt;/li&gt;
&lt;li&gt;传输状态计时器到期&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;自动重置将使两端重置其当前状态，包括刷新重传和无序队列，然后重置其初始序列号并重新协商连接。每端将通知其上层协议（ULP）自动重置。&lt;/p&gt;
&lt;p&gt;有一个连续的重置计数器，用于设置在没有连接打开的情况下可以发生的最大自动重置次数。 如果此计数器超过其最大值，则重置连接。连续重置计数器的建议值为 3。&lt;/p&gt;
&lt;h5&gt;10. 接收端接收队列大小&lt;/h5&gt;
&lt;p&gt;接收端接收队列的大小是可配置参数。建议值为 32 个数据包。&lt;/p&gt;
&lt;p&gt;接收队列大小充当流控制机制。&lt;/p&gt;
&lt;h5&gt;11. 拥塞控制和慢启动&lt;/h5&gt;
&lt;p&gt;RUDP 未提供。&lt;/p&gt;
&lt;h5&gt;12. UDP 端口号&lt;/h5&gt;
&lt;p&gt;RUDP 对使用哪个 UDP 端口号没有任何限制。
有效端口号是 RFC 1700 中未定义的端口。&lt;/p&gt;
&lt;h5&gt;13. 支持冗余连接&lt;/h5&gt;
&lt;p&gt;如果 RUDP 连接失败，将发信号通知上层协议，并启动传输状态计时器。 ULP 可以通过 API 调用启动将此状态传输到另一个 RUDP 连接
RUDP 会将状态信息传输到新连接，以确保数据包不会重复或丢失。&lt;/p&gt;
&lt;p&gt;如果 ULP 在传输状态计时器到期之前没有将状态转移到另一个连接，则连接状态将丢失，并且连接队列的缓冲区被释放。 传输状态定时器的超时值是可配置的。&lt;/p&gt;
&lt;p&gt;传输状态计时器的建议值为 1 秒。&lt;/p&gt;
&lt;h5&gt;14. 连接断开的处理&lt;/h5&gt;
&lt;p&gt;以下情况发生时，则认为 RUDP 连接断开：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;重传定时器到期且重传计数已超过其最大值。&lt;/li&gt;
&lt;li&gt;NULL 段定时器过期。
如果出现上述两种情况中的任何一种并且传输状态超时不为零，则通过 API 的连接失败信号通知ULP 连接失败，并且将启动传输状态定时器。 如果传输状态计时器到期，则执行自动复位，并通过 API 的连接自动复位信号通知 ULP。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果传输状态超时值为零，则当上述两种情况中的任何一种发生时，将立即执行自动复位。 ULP 将通过 API 的连接自动重置信号通知连接失败。&lt;/p&gt;
&lt;h5&gt;15. 重传算法&lt;/h5&gt;
&lt;p&gt;接收到 EACK 段或重传定时器超时而发生重传。&lt;/p&gt;
&lt;p&gt;收到 EACK 段时，消息中指定的段将从未确认的已发送队列中删除。 要重传的段是通过检查 EACK 段中的 ack 号和最后一个 seq 号来确定的。 重新发送未确认的发送队列不包括这两个序列号之间的所有报文段。&lt;/p&gt;
&lt;p&gt;当发生重传超时时，重传未确认的已发送队列上的所有消息。&lt;/p&gt;
&lt;h5&gt;16. 上层协议通信信号&lt;/h5&gt;
&lt;p&gt;以下信号将通过 API 传输给上层协议，通知异步事件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Connection open：连接状态变为 Open 时发送信号。&lt;/li&gt;
&lt;li&gt;Connection refused：连接状态从 Close Wait 以外状态转为 Closed 时发送信号。&lt;/li&gt;
&lt;li&gt;Connection closed：连接状态从 Close Wait 转为 Closed 时发送信号。&lt;/li&gt;
&lt;li&gt;Connection failure：连接状态断开时发送信号。&lt;/li&gt;
&lt;li&gt;Connection auto reset：连接自动复位时发送信号。向上层协议通知数据可能丢失且 RUDP 正试图将连接返回到打开状态。&lt;/li&gt;
&lt;/ul&gt;
&lt;h5&gt;17. 校验和算法&lt;/h5&gt;
&lt;p&gt;RUDP 中使用的校验和算法与 UDP 和 TCP 头中使用的算法相同，它是被检验数据的每16位求和的补码。CHK 置1时，对整个报文计算校验和。否则，只对头部计算校验和。&lt;/p&gt;
&lt;h5&gt;18. FEC 前向纠错&lt;/h5&gt;
&lt;p&gt;RUDP没有定义前向纠错（FEC）的处理。它会丢弃收到的重复包。&lt;/p&gt;
&lt;h5&gt;19. 安全性&lt;/h5&gt;
&lt;p&gt;RUDP 将兼容 IPsec 标准。&lt;/p&gt;
&lt;h3&gt;1.3. 参数协商&lt;/h3&gt;
&lt;p&gt;当客户端发起连接时，发送一个 SYN 段，包含上层通过 API 定义的协商参数。
服务器可以通过带有 ACK 响应的 SYN 接受这些参数，或者在其 SYN 中使用 ACK 响应提出不同的参数。
然后，客户端可以选择接受服务器发送的参数并发送 ACK 来建立连接，或者发送 RST 来拒绝连接。
在自动重置期间无法重新协商。&lt;/p&gt;
</content:encoded><category>译</category><category>计算机网络</category><author>Mslxl</author></item><item><title>Educational Codeforces Round 158 (Rated for Div. 2)</title><link>https://blog.mslxl.com/posts/cp/cf1901/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/cf1901/</guid><description>复健，也是重新认识自己</description><pubDate>Sat, 25 Nov 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;A. Line Trip&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;车从一条路的 0 点出发到达 $x$ ，然后再返回 $0$ 点。车每单位距离消耗 $1$ 升油，路上加油站的在 $a_i$。每次在加油站都会把油箱加满油。输出最小的油箱大小&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;找出两个相邻的加油站的最大距离，特别处理边缘即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int n, x;
  read(n, x);
  V&amp;lt;int&amp;gt; s(n+1);
  reads(all1(s));
  int max = 0;
  rep1(i, n){
    max = mmax(max, s[i] - s[i-1]);
  }
  max = mmax(max, (x - s[n]) * 2);
  std::cout &amp;lt;&amp;lt; max;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Chip and Ribbon&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有从 1 到 $n$ 共 $n$ 个单元格。每个单元格默认值为 $0$。&lt;/p&gt;
&lt;p&gt;现在 Monocarp 将 chip 放到第一个单元格中，在每回合的结束时 chip 所在的单元格上的数字都会$+1$。除了第一回合，每回合可以对 chip 进行以下一种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 chip 移动到下一个单元格&lt;/li&gt;
&lt;li&gt;将 chip 转送到任意单元格&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给出 $c_i$，要使 $a_i = c_i$，，输出最小传送次数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;每次上升都需要往回传送一次，以把数字大的数字加上去&lt;/p&gt;
&lt;p&gt;只需要逐项作差，统计上升数字的总合即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int n;
  read(n);
  V&amp;lt;int&amp;gt; s(n+1);
  reads(all1(s));
  V&amp;lt;int&amp;gt; p(n+1);
  int ans = 0;
  rep1(i, n){
    p[i] = s[i] - s[i-1];
    ans += p[i] &amp;gt; 0? p[i] : 0;
  }
  std::cout &amp;lt;&amp;lt; ans - 1;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Add, Divide and Floor&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个整数数组 $a_i$。每次操作任选一个整数 $x(0 \le x \le 10^{18})$，并将 $a_i$ 中每个元素替换成 $\lfloor \frac{a_i + x}{2} \rfloor$&lt;/p&gt;
&lt;p&gt;输出最小操作次数，使得数组中所有的元素相等&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;通过把玩样例可知：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果一奇一偶两个数 $2n$ 和 $2n+1$ 两个数，操作的结果是 $\frac{4n + 1}{2}= 2n$; 或者是 $2n-1$ 和 $2n$，结果是 $\frac{4n - 1}{2} = 2n-1$。即如果选择的数 $x$ 比其他数小，总能使其他数减一&lt;/li&gt;
&lt;li&gt;如果要使数 $a$ 变为 $b$（$b &amp;lt; a$），每次操作的能使当前的数字和 $b$ 的差缩小一半&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么只需要统计出数组中的最小值和最大值，操作次数即为 $log_2(max-min) + 1$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int n;
  read(n);
  V&amp;lt;int&amp;gt; s(n+1);
  reads(all1(s));
  if(n == 1){
    std::cout &amp;lt;&amp;lt; 0;
    return;
  }
  auto min = *std::min_element(all1(s));
  auto max = *std::max_element(all1(s));
  if(min == max){
    std::cout &amp;lt;&amp;lt; 0;
    return;
  }
  int x = std::log2(max - min) + 1;
  std::cout &amp;lt;&amp;lt; x;
  if(x &amp;lt;= n){
    std::cout &amp;lt;&amp;lt; &quot;\n&quot;;
    rep(i, x){
      std::cout &amp;lt;&amp;lt; min &amp;lt;&amp;lt; &quot; &quot;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. Yet Another Monster Fight&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有 $i$ 个怪兽，每个怪兽的血量为 $a_i$。Vasya 会对第 $i$ 个怪兽，并施加攻击力为 $x$ 的魔法。魔法将每次攻击一个，总计攻击 $n$ 次怪兽。对于每次攻击，链法将会随机选择一个没有被攻击过且旁边被攻击过的怪兽进行攻击。第一次魔法攻击将造成 $x$伤害，第二次 $x-1$，依次类推&lt;/p&gt;
&lt;p&gt;现在使用一次魔法，使的无论攻击顺序如何都能击杀所有的怪物，且魔法攻击最低，输出 $x$ 的值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;既然不考虑攻击顺序，就一定存在最坏情况。&lt;/p&gt;
&lt;p&gt;如果第一次攻击 $i$，之后选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;右边的 $j$，那么攻击力最大将衰减 $(i - 1) + (j - i) = j - 1$&lt;/li&gt;
&lt;li&gt;左边的 $j$，攻击力最大衰减 $(n - i) + (i - j) = n - j$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很容易就能求出对于每个元素 $j$，如果选择的 $i$ 在它左边时和在右边时的所需攻击力。&lt;/p&gt;
&lt;p&gt;枚举首次攻击的怪兽 $i$，求出其左侧、右侧所需的最大攻击力和自身的最大值，每次取最小即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
template&amp;lt;class R, class A&amp;gt; R mmax(R x, A y){ return std::max(x, (R) y); } template&amp;lt;class R, class A, class... AS&amp;gt; R mmax(R x, A xx, AS... xxs){ return std::max(x, mmax((R)xx, xxs...));  }
template&amp;lt;class R, class A&amp;gt; R mmin(R x, A y){ return std::min(x, (R) y); } template&amp;lt;class R, class A, class... AS&amp;gt; R mmin(R x, A xx, AS... xxs){ return std::min(x, mmin((R)xx, xxs...));  }
int main(){
  #define int long long
  int n;
  std::cin &amp;gt;&amp;gt; n;
  std::vector&amp;lt;int&amp;gt; s(n+2);

  for(int i = 1; i &amp;lt;= n; i++){
    std::cin &amp;gt;&amp;gt; s[i];
  }

  std::vector&amp;lt;int&amp;gt; pre(s.size()), suf(s.size());
  for(int i = 1; i &amp;lt;= n; i++){
    pre[i] = n - i + s[i];
    suf[i] = i - 1 + s[i];
  }
  for(int i = 1; i &amp;lt;= n; i++) pre[i] = std::max(pre[i], pre[i-1]);
  for(int i = n; i &amp;gt;= 1; i--) suf[i] = std::max(suf[i], suf[i+1]);
  int atk = 0x3f3f3f3f;

  for(int i = 1; i &amp;lt;= n; i++){
    atk = mmin(
      atk,
      mmax(
        pre[i-1],
        suf[i+1],
        s[i]
      )
    );
  }
  std::cout &amp;lt;&amp;lt; atk;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&amp;lt;!--&lt;/p&gt;
&lt;h2&gt;E. Compressed Tree&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给一棵由 $n$ 个节点组成的树。节点 $i$ 上有数字 $a_i$&lt;/p&gt;
&lt;p&gt;可以进行下列操作任意次，可以是 0 次&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择一个最多有 1 个相邻边的点，从树中移除&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以删除所有的节点&lt;/p&gt;
&lt;p&gt;在所有操作结束后，对这棵树进行压缩。压缩过程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个顶点有两个相邻的边时，删除顶点，并将其邻边所连节点直接相连。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;值得一提的是如果有多种压缩过程，其结果仍是一致的&lt;/p&gt;
&lt;p&gt;计算在进行上述操作任意次并压缩后所剩余节点的最大和
--&amp;gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><category>Competitive Programming</category><category>Codeforces</category><author>Mslxl</author></item><item><title>MIT6.824 分布式系统 GFS</title><link>https://blog.mslxl.com/posts/proj/gfs/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/proj/gfs/</guid><description>GFS 的运行原理和特点。目前抓包可以看到百度和Mega都在用类似的分布式存储</description><pubDate>Thu, 21 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;GFS （Google File System） 是一种可拓展的分布式文件系统，主要用于大型分布式数据密集型应用。它在廉价的普通硬件上提供了运行时的容错，并为大量客户机提供了聚合性能&lt;/p&gt;
&lt;p&gt;在论文中，Google 介绍了支持分布式应用程序的拓展文件系统接口，并讨论了 GFS 设计，基准测试和实际表现的种种方面&lt;/p&gt;
&lt;h2&gt;介绍&lt;/h2&gt;
&lt;p&gt;GFS 和传统的分布式文件系统在性能，拓展性，稳定性和可用性上有同样的目标，但是传统的分布式文件系统目前存在以下缺点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;组成部分的故障是一个常见的现象。由大量机器组成的系统实际上使的系统的部分故障会是一个非常常见的现象，因此文件系统中必须集成有持续监控，错误检测，容错机制和自动恢复功能&lt;/li&gt;
&lt;li&gt;在传统意义上分布式文件系统上存储的文件一般很大，因此对于 IO操作的设想和块大小需要重新考虑&lt;/li&gt;
&lt;li&gt;大多数文件的操作不是覆写，而是在原有的基础上进行追加。随机写文件在实际操作中也不存在。通常一个文件在被写入后，只会被顺序的反复读取。考虑以上特点，在原子性保证和性能方面应着重考虑文件追加操作。而客户机的缓存数据块没有任何优点&lt;/li&gt;
&lt;li&gt;在设计文件系统的 API 时增加系统的灵活性，可以使的整个系统受益。Google 通过放宽一致性模型极大的简化的文件系统，也不会给应用程序带来沉重的负担&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;设计一览&lt;/h2&gt;
&lt;h3&gt;设想&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;系统运行在常见的商用机上。它必须能&lt;strong&gt;自我监控和检测&lt;/strong&gt;，并在常规基础上检测、容忍组件故障，并迅速从组件故障中恢复。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;系统存储大文件&lt;/strong&gt;。以 GB 为单位的文件是一种常见情况，应该被高效的管理，而小文件不需要优化。&lt;/li&gt;
&lt;li&gt;工作负载主要由两部分组成：&lt;strong&gt;大量的读取流&lt;/strong&gt;和少量的随机读。在读取流中，每次通常读取 $1 MiB +$。同一客户机上的读取通常是一段连续的区域。随机读通常只有几KB，并且每次偏移一定值。故注重性能的应用程序通常对它们的小读取进行批处理和排序，以便在文件中稳定地前进，而不是来回移动。&lt;/li&gt;
&lt;li&gt;工作负载也包含追加文件时的**大量的连续写操作。**通常写的大小和读的大小相似。文件一经写入，很少进行修改。少量的写操作会有，但不需要优化&lt;/li&gt;
&lt;li&gt;系统需要对多客户端并发追加同一个文件具备良好高效的语义定义。文件系统中的文件常作为生产-消费模型中的队列，或者是用于数据合并。运行在不同主机上的生产者可能会同时写一个文件，同时文件可能会同时或稍后被读取，因此需要在少量开销下保证原子性。&lt;/li&gt;
&lt;li&gt;高带宽比低延迟重要。大多数目标应用程序都重视以高速率批量处理数据，而很少有对单个读或写有严格的响应时间要求&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;接口&lt;/h3&gt;
&lt;p&gt;GFS 提供了一些常见的文件系统接口。此外，具有&lt;strong&gt;快照&lt;/strong&gt;和&lt;strong&gt;追加&lt;/strong&gt;操作。快照以较低的成本创建文件或目录树的副本。追加允许多个客户端并发地向同一个文件追加数据，同时保证每个客户端追加的原子性。它对于实现多路合并结果和生产者-消费者队列非常有用，许多客户机可以同时追加到这些队列，而无需额外的锁定。我们发现这些类型的文件在构建大型分布式应用程序时是无价的。&lt;/p&gt;
&lt;h3&gt;架构&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;image-20230921174912019.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;GFS 集群包含可以被客户端访问到的一个 master 的复数个 Chunk Servers。每个都是一个 Linux 主机运行的用户级的程序。&lt;/p&gt;
&lt;p&gt;每个文件被拆分成多个 Chunk，每个 Chunk 一般为 64 MiB 存储在不同的 Chunk Server 中。&lt;/p&gt;
&lt;h2&gt;维护内容&lt;/h2&gt;
&lt;h3&gt;元信息&lt;/h3&gt;
&lt;p&gt;在 master 中维护有以下内容：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文件名与 chunk handle 数组的对应关系&lt;/li&gt;
&lt;li&gt;chunk handle 和 chunk 版本号的对应关系&lt;/li&gt;
&lt;li&gt;chunk handle 和 chunk server 地址、primary chunk server、租约的对应关系&lt;/li&gt;
&lt;li&gt;日志&lt;/li&gt;
&lt;li&gt;检查点&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除第三点外，所有数据均需要进行持久化存储&lt;/p&gt;
&lt;p&gt;Master 不存储 chunk handle 和 chunk server 的对应关系，这些信息只保存在内存当中。Chunk server 会定期通过心跳的方式通知 master 其含有的所有 chunk。Master 根据目前内存中已有的 chunk server 的数量采取相应的行动（复制，删除等）。因为 master 不存储 chunk 中的内容（即 master 不决定 chunk），chunk server 的宕机、数据错误、离线等都需要 master 进行相应的修改，而 master 可能止一个，master 进行主动的修改可能会导致一致性问题，因此 master 不持久化维护对应关系，而是由 chunk server 决定这些内容&lt;/p&gt;
&lt;p&gt;而 chunk 到版本号的关系必须持久化。由于 chunk server 可能会掉线，从而错过某次更新，所以 chunk server 所存储的版本号不一定正确。 master 存储版本号，以需要区分哪一个 chunk server 中的信息是过时的，而哪一个是最新的。&lt;/p&gt;
&lt;p&gt;所有信息的修改均通过操作日志的方式实现。在收到RPC指令后，Master 会将所有的操作记录在日志中，并将日志同步到备份 Master 上，当操作、记录与同步均完成后 Master 才会对 Client 进行回复，任意一个过程的失败均标志着全过程的失败。Master 在重启中恢复时，会通过重放 Log 的方式恢复数据，为了减少重放的负担，Master 会定期对数据建立检查点，每次回放时只需要从最近的检查点开始回放。&lt;/p&gt;
&lt;h3&gt;锁&lt;/h3&gt;
&lt;p&gt;为了保证数据的一致性，确保在并发操作中文件名不会冲突，需要对文件和路径进行加锁，每个文件和目录均有一个读写锁。GFS 会对每个文件和所属目录从根目录开始逐级加锁。&lt;/p&gt;
&lt;h2&gt;读文件&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;sequenceDiagram
    Client-&amp;gt;&amp;gt;+Master: 发送文件名和要读取的位置(Offset)
    Master--&amp;gt;&amp;gt;-Client: 返回 chunk server, handle, 版本号（一般返回3条）
    Client-&amp;gt;&amp;gt;Client: 缓存
    Client-&amp;gt;&amp;gt;+Chunk Server: 读取 Chunk
    Chunk Server-&amp;gt;&amp;gt;Chunk Server: 校验本地版本号和需要是否一致、本地 checksum 和内容是否对应
    Chunk Server--&amp;gt;&amp;gt;Client: 返回 Chunk 内容
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果在读取 Chunk 时，Client 未能正常连接 Chunk Server，或者 Chunk Server 校验失败，那么 Client 会去请求另一个 Chunk Server。&lt;/p&gt;
&lt;p&gt;在读取过程中，如果请求的 Chunk Server 是 Primary，那么数据就是一致的。否则数据有可能就旧的。&lt;/p&gt;
&lt;p&gt;客户端的实现逻辑一般是请求最近的 Chunk Server&lt;/p&gt;
&lt;h2&gt;删除文件&lt;/h2&gt;
&lt;p&gt;GFS 删除文件为惰性删除：当收到删除命令时， Master 会将该文件名后追加时间戳（即变为隐藏文件）。Master 会定期遍利所有的文件名和所有的 Chunk，在遍历文件名时若发现文件已经被标记一段时间后，会从删除自身存储的对应关系; 而在遍历 Chunk 时， 若发现该 Chunk 为孤儿 Chunk（即不存在它的对应关系），那么会对这个 Chunk 进行真正的删除操作&lt;/p&gt;
&lt;h2&gt;写文件&lt;/h2&gt;
&lt;p&gt;在写文件时，Master 会通过租约的方式保证数据一致，并通过流水线技术保证写速度。&lt;/p&gt;
&lt;p&gt;当 Client 试图写文件时，会首先向 Master 请求对应的位置。Master会检查此时该文件是否存在 Primary Chunk Server，它的组约是否过期，如果存在且未过期则返回 Primary Chunk Server 对应的信息和操作标识以及Secondary Chunk Server，否则则进行Primary Chunk Server的分配。Client 拿到信息后，会通过流水线(pipeline) 向服务器发送文件，并在发送完成时向 Primary Chunk Server 发送控制命令，Primary Chunk Server 再分别对所有 Chunk Server 进行操作，所有操作结束后才会对 Client 进行回应。&lt;/p&gt;
&lt;p&gt;其过程如下图&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;flowchart LR
    Client --&amp;gt;|1. 请求写操作| Master
    Master --&amp;gt;|2. 返回信息| Client
    Client ==&amp;gt;|3. 发送 Chunk 数据| NCS[Nearest Chunk Server]
    NCS ==&amp;gt;|3. 同步 Chunk 数据| PCS[Primary Chunk Server]
    PCS ==&amp;gt;|3. 同步 Chunk 数据| SCS[Secondary Chunk Server]
    Client --&amp;gt;|4. 发送写指令| PCS
    PCS --&amp;gt;|5. 发送写指令 | NCS
    PCS --&amp;gt;|5. 发送写指令 | SCS
    NCS --&amp;gt;|6. 返回操作结果| PCS
    SCS --&amp;gt;|6. 返回操作结果| PCS
    PCS --&amp;gt;|7. 返回操作结果| Client
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在操作3中，Chunk 数据的发送与同步并不是等待文件全部接受后再向下一个服务器进行同步，而是一遍接受一遍发送。每个 Chunk Server向其最新的 Chunk Server 发送数据&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;sequenceDiagram
    participant Master
    participant Client
    participant Nearest Chunk Server
    participant Primary Chunk Server
    participant Secondary Chunk Server
    Client -&amp;gt;&amp;gt;+Master: 请求写操作
    Master -&amp;gt;&amp;gt;Master: 查表检查该文件是否存在 Primary Chunk Server，如果不存在进行分配
    Master -&amp;gt;&amp;gt;-Client: 返回 Chunk Server 信息
    par
        Client -&amp;gt;&amp;gt; Nearest Chunk Server:同步 Chunk 数据
    and
        Nearest Chunk Server -&amp;gt;&amp;gt; Primary Chunk Server:同步 Chunk 数据
    and
        Primary Chunk Server -&amp;gt;&amp;gt; Secondary Chunk Server:同步 Chunk 数据
    end
    Client -&amp;gt;&amp;gt; Primary Chunk Server: 发送指令
    par
        Primary Chunk Server -&amp;gt;&amp;gt; Nearest Chunk Server: 发送指令
        Nearest Chunk Server -&amp;gt;&amp;gt; Primary Chunk Server: 返回结果
    and
        Primary Chunk Server -&amp;gt;&amp;gt; Secondary Chunk Server: 发送指令
        Secondary Chunk Server -&amp;gt;&amp;gt; Primary Chunk Server: 返回结果
    end
    Primary Chunk Server -&amp;gt;&amp;gt; Client: 返回结果
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;追加&lt;/h2&gt;
&lt;p&gt;追加在 GFS 中是一个常用的操作。GFS 中的追加不是在文件末尾进行追加，而是在文件后添加一个新的 Chunk。如果原本文件的最后一个 Chunk 未满也不会在后面追加。每次文件的追加都是在写一个全新的 Chunk，GFS 通过这种方式保证了数据的正确&lt;/p&gt;
&lt;p&gt;在一致性模型中，只有追加是定义但不一致的：其原因是如果有 Chunk Server 在追加过程中失败，Client 会重试此操作，在最终成功之前可能会有多次追加操作，会产生很多不一致的数据，但这些数据是无用且不影响的&lt;/p&gt;
&lt;h2&gt;文件快照&lt;/h2&gt;
&lt;p&gt;GFS 通过类似 COW 的方式建立文件的快照，以减少文件的复制操作。其过程如下&lt;/p&gt;
&lt;p&gt;当 Master接收到一个文件快照命令之后，找到该文件包含的所有 chunk，取消所有 Chunk 的租约。之后在元数据中建立新的对应关系，其对应的 chunk 仍为原本的 Chunk。在记录日志之后，所有操作结束&lt;/p&gt;
&lt;p&gt;在后续修改 Chunk 时，Master 会先要求 Chunk Server 建立原 Chunk 的副本，再选择 Primary Chunk Server 进行操作。&lt;/p&gt;
&lt;p&gt;取消租约的原因是防止建立文件快照的过程中对原 Chunk 进行修改，导致快照内容并不是原本的内容&lt;/p&gt;
&lt;h2&gt;Chunk 大小 64MiB?&lt;/h2&gt;
&lt;p&gt;64 MiB 是实验室数据，它是一个平衡点。&lt;/p&gt;
&lt;p&gt;作为一个较大的 Chunk， 其优势是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;减少了客户端与master的交互，即减少了客户端请求master获取filename与chunkserver的对应关系。&lt;/li&gt;
&lt;li&gt;减少了网络开销，因为一个chunk很大，客户端的一次读写可以更加集中在少量的chunkserver上，复用TCP连接。&lt;/li&gt;
&lt;li&gt;减少master管理的元信息的大小。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;但也有劣势&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可能会形成热点，导致大量的客户端请求集中在某几个chunkserver上。（可以通过客户端请求的次数和频率加副本减缓）&lt;/li&gt;
&lt;/ol&gt;
</content:encoded><category>MIT6.824</category><category>分布式系统</category><author>Mslxl</author></item><item><title>MIT6.824 分布式系统 MapReduce</title><link>https://blog.mslxl.com/posts/proj/mr/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/proj/mr/</guid><description>很经典的并行计算模型，MapReduce 也就是 map 和 reduce</description><pubDate>Fri, 15 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;MapReduce 模型&lt;/h2&gt;
&lt;p&gt;MapReduce 是一种编程模型，用于大规模数据集(大于1TB)的并行运算。&lt;/p&gt;
&lt;p&gt;MapReduce 类似函数式语言中的 map 和 reduce ，计算接受一组键值对，并产生一组新的键值对。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Map 接受输入的键值对，并产生新的中间键值对，这些中间产物是分散存储的。这些中间键值对被根据键进行 group 操作，然后传给 Reduce 进一步进行操作&lt;/li&gt;
&lt;li&gt;Reduce 接受中间产物一个键和多个与它对应的值。Reduce 将会把值进行合并，通常合并后的大小会是 1 或者 0。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果用 haskell 的类型签名表示，大概会是这个样子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;map :: (InputKey, InputValue) -&amp;gt; [(IntermediateKey, IntermediateValue)]
reduce :: (IntermediateKey, [IntermediateValue]) -&amp;gt; [Value]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;执行过程&lt;/h3&gt;
&lt;p&gt;&lt;img src=&quot;shot_1694745917.png&quot; alt=&quot;Execution overview&quot; /&gt;&lt;/p&gt;
&lt;p&gt;该计算模型由多个worker组成，其中一个 worker 会作为 Master 运行协调器&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;用户程序将输入数据分割为 $M$ 份，并在 worker 上启动程序的副本&lt;/li&gt;
&lt;li&gt;将其中一个 worker 作为 Master，其他的 worker 负责执行 map 和 reduce 操作。全过程需要指定 $M$ 个 map 任务和 $R$ 个 reduce 任务&lt;/li&gt;
&lt;li&gt;执行 map 的 worker 从读入输入数据的部分文件，并将结果保留在内存中&lt;/li&gt;
&lt;li&gt;worker 周期性将内存中的数据写到本地硬盘中，并将其分为 $R$ 组。输出数据的位置将被传回 Master，Master将数据的位置转发给另一个空闲的 worker（指派 reduce 任务）&lt;/li&gt;
&lt;li&gt;执行 reduce 任务的 worker 通过 RPC从执行 map 的 worker 的本地硬盘中读入数据到缓冲区中。当读入结束后，worker 会对键进行排序，具有相同 key 的将会被分为一组。这个过程有可能要进行外排序&lt;/li&gt;
&lt;li&gt;执行 reduce 任务的 worker 将遍历排序后的中间数据，对于每个唯一的 key，worker 将会对其执行对应的 reduce 操作，操作结果将会被存储在最终文件中。当操作结束后，更改文件名为最终文件名&lt;/li&gt;
&lt;li&gt;当所有的 map 和 reduce 任务结束后，重新唤醒用户程序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用户可以选择的合并$R$份最终结果数据，但大部分不需要合并。&lt;/p&gt;
&lt;p&gt;要保证map 操作和 reduce 操作是 pure，对本地硬盘的操作是原子化的，以便在错误中恢复&lt;/p&gt;
&lt;h3&gt;错误处理&lt;/h3&gt;
&lt;h4&gt;worker 故障&lt;/h4&gt;
&lt;p&gt;master 周期性的检查每个 worker。如果在一段时间中 worker 没有回应，那么 master 将其标记为“故障”。这时 map 或者 reduce 任务和 worker 都会被重置为初始的空闲状态&lt;/p&gt;
&lt;p&gt;因为故障 worker 的本地硬盘无法访问，所以即使 map 任务已经完成，这个任务也要重新执行。但如果 reduce 任务所在的 worker 故障则不需要&lt;/p&gt;
&lt;h4&gt;master 故障&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;方式一： master 周期性的设置检查点，如果 master 故障，新的 master 将从检查点恢复&lt;/li&gt;
&lt;li&gt;方式二：用户程序检查 master，发现故障时整个重新执行&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一般来说 master 的故障比较稀少，所以方式二更常用&lt;/p&gt;
&lt;h3&gt;Master 数据结构&lt;/h3&gt;
&lt;p&gt;Master包含多种数据结构。对于每个 Map 和 Reduce 任务保存它们的状态(空闲，进行中或者是完成)。对于不是空闲状态的任务，保存其执行的 Worker。&lt;/p&gt;
&lt;p&gt;对于每个完成的 Map 任务，Master 会保持$R$个中间产物的位置和大小。更新这些信息将会表明 map task 被完成。这些信息也会被增量的推送到正在进行中的 Reduce 任务&lt;/p&gt;
&lt;h3&gt;备份任务&lt;/h3&gt;
&lt;p&gt;任务执行的总时间受长尾效应的影响，故在任务接近结束时，Master 将仍未完成的任务重复分给第多个其他空闲 Worker，执行同一个任务的 Worker 有一个完成任务，就看作这个任务被完成，不需要在意落后者的执行进度。&lt;/p&gt;
&lt;h2&gt;Lab 结构&lt;/h2&gt;
&lt;p&gt;这一节的 Lab 在 &lt;a href=&quot;http://nil.csail.mit.edu/6.824/2022/labs/lab-mr.html&quot;&gt;6.824 Lab 1: MapReduce&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;目标为实现一个由两个程序组成的分布式 MapReduce，这两个程序分别是 Coordinator 和 Worker。模型中只会有一个 Coordinator，但会有多个 Worker 并行执行。Worker 将会通过 RPC 与 Coordinator 进行通信，获取输入信息，执行任务并将结果输出到一个或多个文件中。如果在规定的时间内（在Lab 中规定为 10 秒）Worker没有完成任务，Coordinator 应当通另一个 Worker 启动相同的任务&lt;/p&gt;
&lt;p&gt;在开始给出的代码中，coordinator 和 worker 将分别用 &lt;code&gt;main/mrcoordinator.go&lt;/code&gt; 和 &lt;code&gt;main/mrworker.go&lt;/code&gt; 中其中，不应该修改这两个文件。MapReduce 应该从 &lt;code&gt;mr/coordinator.go&lt;/code&gt; 、&lt;code&gt;mr/worker.go&lt;/code&gt; 和 &lt;code&gt;mr/rpc.go&lt;/code&gt; 中实现&lt;/p&gt;
&lt;p&gt;如果需要运行统计字数的 MapReduce 任务，首先应该编译 word-count 的插件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go build -race -buildmode=plugin ../mrapps/wc.go
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;main&lt;/code&gt; 目录中运行 coordinator&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ rm mr-out*
$ go run -race mrcoordinator.go pg-*.txt
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;pg-*.txt&lt;/code&gt; 参数作为指明 &lt;code&gt;mrcoordinator.go&lt;/code&gt; 的输入文件，每个文件对应了一个 split，应当作为单独的一个 Map 任务执行&lt;/p&gt;
&lt;p&gt;在其他窗口中运行 worker:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go run -race mrworker.go wc.so
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当 workers 和 coordinator 执行完成后，检查 &lt;code&gt;mr-out-*&lt;/code&gt;的输出，它们应该和串行执行的文件内容一致。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ cat mr-out-* | sort | more
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;项目中还提供了测试脚本 &lt;code&gt;main/test-mr.sh&lt;/code&gt;，这个测试简本会检查 MapReduce 实现的结果的正确性和 worker 故障的情况&lt;/p&gt;
&lt;h3&gt;规则&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;Map 阶段应当把 intermediate keys 分到桶中以备 &lt;code&gt;nReduce&lt;/code&gt; 个reduce个任务。&lt;code&gt;nReduce&lt;/code&gt; 是 &lt;code&gt;main/mrcoordinator.go&lt;/code&gt; 向 &lt;code&gt;MakeCoordinator()&lt;/code&gt; 传递的参数。每个 mapper 需要创建 &lt;code&gt;nReduce&lt;/code&gt; 个中间文件&lt;/li&gt;
&lt;li&gt;在 worker 实现时，第 $N$ 个 Reduce 的输出应该到 &lt;code&gt;mr-out-X&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mr-out-X&lt;/code&gt; 文件应该将 Reduce 函数的每个输出保存在一行中。每一行以 &lt;code&gt;%v %v&lt;/code&gt; 的方式输出。可以参考 &lt;code&gt;main/mrsequential.go&lt;/code&gt; 文件。&lt;/li&gt;
&lt;li&gt;可以修改 &lt;code&gt;mr/worker.go&lt;/code&gt; 、&lt;code&gt;mr/coordinator.go&lt;/code&gt; 和 &lt;code&gt;mr/rpc.go&lt;/code&gt; 文件，可以临时修改其他文件来进行测试，但是最终提交时请保证代码在文件的原始版本可以正常执行&lt;/li&gt;
&lt;li&gt;worker 应该将 Map 输出的临时文件存放在当前目录下，Reduce 之后可以直接收入&lt;/li&gt;
&lt;li&gt;在 MapReduce 工作完全结束后，&lt;code&gt;mr/coordinator.go&lt;/code&gt; 中的 &lt;code&gt;Done()&lt;/code&gt; 方法应该返回 true 给 &lt;code&gt;main/mrcoordinator.go&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;当任务彻底完成后，worker进程应当退出，比较简单的实现方式为使用 &lt;code&gt;call()&lt;/code&gt; 函数的返回值：如果 worker 与 coordinator 通信失败，就可以假定 coordinator 因为工作完成而退出了，所以 worker 进程也可以终止。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;提示&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href=&quot;http://nil.csail.mit.edu/6.824/2022/labs/guidance.html&quot;&gt;Guidance page&lt;/a&gt; 有一些关于开发和调试的建议&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;开始任务的方式之一是修改 &lt;code&gt;mr/worker.go&lt;/code&gt; 的 &lt;code&gt;Worker()&lt;/code&gt; 来向 coordinator 发送 RPC 来请求任务。修改 coordinator 回应未开始的map任务的文件名。然后修改 worker 来读取文件并启动 Map 函数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;应用的 &lt;code&gt;Map&lt;/code&gt; 和 &lt;code&gt;Reduce&lt;/code&gt; 函数由 Go 的 plugin 包在运行时动态加载&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当修改了 &lt;code&gt;mr/&lt;/code&gt; 目录下的文件后，记得用类似 &lt;code&gt;go build -race -buildmode=pugin ../mrapps/wc.go&lt;/code&gt; 的方式重新编译&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;这个 lab 依赖共享文件系统，这直接导致所有的 worker 必须运行在同一台主机上。如果要 worker 运行在不同的主机上，需要像 GFS 这样的全局分布式文件系统&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一个较为合理的中间文件的命名方式为 &lt;code&gt;mr-X-Y&lt;/code&gt;，其中 &lt;code&gt;X&lt;/code&gt; 表示 Map 任务号，&lt;code&gt;Y&lt;/code&gt; 表示 Reduce 任务号&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Worker 的 map 任务需要一种方式来在文件中保存中间产生的键值对，这种方式需要能被 reduce 任务重新正确的读取。一种可行的方式是使用 &lt;code&gt;encoding/json&lt;/code&gt; 包。向一个文件中写出键值对:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;enc := json.NewEncoder(file)
for _, kv := ... {
    err := enc.Encode(&amp;amp;kv)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;将数据读回&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;dec := json.NewDecoder(file)
for {
    var kv KeyValue
    if err:= dec.Decode(&amp;amp;kv); err != nil {
        break
    }
    kva = append(kva, kv)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;worker 的 map 部分可以使用在 &lt;code&gt;worker.go&lt;/code&gt; 中定义的 &lt;code&gt;ihash(key)&lt;/code&gt; 函数来根据给出的键选择对应的 reduce 任务&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可以参考 &lt;code&gt;mrsequential.go&lt;/code&gt; 中的一些读取 Map 输入文件、对中间键值对进行排序、存储Reduce输出的代码&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coordinator 作为 RPC 服务器是并发的，别忘了锁数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;使用&lt;code&gt;go build -race&lt;/code&gt; 和 &lt;code&gt;go run -race&lt;/code&gt; 来运行 Go 的冲突检测器&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Workers 有时需要进行等待，比如当 reduces 直到最后一个 map 任务结束后才能启动。一种可行解为 worker 周期性向 coordinator 进行询问，并在每次询问后使用 &lt;code&gt;time.Sleep()&lt;/code&gt; 进行等待。或者说在相应的 RPC handler 中使用循环+&lt;code&gt;time.Sleep()&lt;/code&gt; + &lt;code&gt;sync.Cond&lt;/code&gt;进行等待。Go语言对每个 RPC 的 handler 都启动一个线程，所以一个 handler 的等待不会影响其他 RPC。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Coordinator 可能无法可靠的区分崩溃的 worker，正在运行但因某种原因停滞的 worker 和运行速度太慢而无用的 worker。Coordinator 所能做的最好的事情是等待一段时间，然后放弃这个 worker 并为此任务指定一个新 worker。对于这个 lab，coordinator 应该等待 10 秒钟，如果10秒钟 worker 未完成，则应该假定 worker 崩溃&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果选择实现&lt;a href=&quot;#%E5%A4%87%E4%BB%BD%E4%BB%BB%E5%8A%A1&quot;&gt;备份任务&lt;/a&gt;，评测机在测试代码在工作线程执行任务而不崩溃时不会安排无关的任务。 所以备份任务只能在相对较长的时间（例如 10 秒）后安排。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了测试错误恢复，可以使用 &lt;code&gt;mrapps/crash.go&lt;/code&gt; 应用插件。它会随机性的退出&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为了确保在发生崩溃时部分写入的错误文件没有被使用，MapReduce 论文提到了使用临时文件并在完全写入后自动重命名的技巧。 可以使用 &lt;code&gt;ioutil.TempFile&lt;/code&gt; 创建临时文件，并使用 &lt;code&gt;os.Rename&lt;/code&gt; 以原子方式重命名它。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Go RPC 仅发送结构体中以大写字母开头的字段&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当通过指针来向 RPC 系统回复信息时，&lt;code&gt;*reply&lt;/code&gt; 所指向的对象应该是 Zero Allocation, RPC 调用的代码应该是这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;reply := SomeType()
call(..., &amp;amp;reply)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在调用之前没有设置任何字段。如果不满足这个要求，则当您将回复字段预先初始化为该数据类型的非默认值，并且执行 RPC 的服务器将该回复字段设置为默认值时，就会出现问题； 您将观察到写入似乎没有生效，并且在调用方，非默认值仍然存在。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;设计思路&lt;/h2&gt;
&lt;h3&gt;结构&lt;/h3&gt;
&lt;p&gt;通过阅读已有的代码，项目中已经存在 RPC 框架和借助 go plugin 加载 MapReduce 用户代码的框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Lab 的核心是 map 和 reduce 任务，这个任务必须记录状态以备安排调度。状态应该有 &lt;code&gt;IDLE&lt;/code&gt;, &lt;code&gt;RUNNING&lt;/code&gt;, &lt;code&gt;COMPETE&lt;/code&gt; 三种。失败的任务可以被重置为 &lt;code&gt;IDLE&lt;/code&gt; 状态来再次执行。&lt;/li&gt;
&lt;li&gt;任务需要有个编号 &lt;code&gt;id&lt;/code&gt; 用来标记任务的输出文件名和调试信息&lt;/li&gt;
&lt;li&gt;因为 reduce 任务的数据需要依赖 map 任务的结果，所有任务必须记录他们的输入数据和返回数据。&lt;/li&gt;
&lt;li&gt;为了区分任务是否失败，需要记录任务启动的时间来判断当前任务执行的时间&lt;/li&gt;
&lt;li&gt;为了方便调试，可能需要记录 Worker 的身份&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;全过程的数据变化如下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20230917013137080.png&quot; alt=&quot;image-20230917013137080&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在一个 map 的 worker 中，不同 key 的 &lt;code&gt;hash % nReduce&lt;/code&gt; 相同的会被分到一组，并存放在一个文件中。另一个 map 中同理。不同 worker 的相同 &lt;code&gt;hash % nReduce&lt;/code&gt; 的值会被送到同一个 reduce 任务中。&lt;/p&gt;
&lt;p&gt;也就是说 map 任务接受一个文件，返回 $nReduce$ 个文件。reduce 任务接受 $len(files)$ 个文件，返回一个文件。&lt;/p&gt;
&lt;p&gt;根据以上信息，我们可以总结出 Map 和 Reduce 两种任务的类型&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type TaskStatus int

const (
    TaskStatus_Idle      TaskStatus = 0
    TaskStatus_Running   TaskStatus = 1
    TaskStatus_Completed TaskStatus = 2
)

type WorkerIdent string

type MapTask struct {
    id            int
    status        TaskStatus
    inputFilename string

    startTime    int64
    worker       WorkerIdent
}

type ReduceTask struct {
    id            int
    status        TaskStatus
    inputFilename []string

    startTime    int64
    worker       WorkerIdent
    resultHandle string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再来设计 Coordinator 的类型。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;因为 Coordinator 需要记录所有的任务，所以肯定需要 &lt;code&gt;[]MapTask&lt;/code&gt; 和 &lt;code&gt;[]ReduceTask&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;记录任务完成的数量：如果 map 任务完成的数量等于 map 任务的数量，那么后续只需要考虑 reduce 任务的分配，而 reduce 任务完成后即可退出&lt;/li&gt;
&lt;li&gt;这是并行服务器，记得加锁&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;type Coordinator struct {
    mapTasks    []MapTask
    reduceTasks []ReduceTask

    completedMapTask    int
    completedReduceTask int
    mu                  sync.Mutex
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么以上就是 Coordinator 内部所需要存储的所有状态。Coordinator 启动时应该初始化所有的 Map 任务，并在 Worker 启动后向其分配任务&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;image-20230917015927203.png&quot; alt=&quot;image-20230917015927203&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const (
    TaskTy_Map    = 1
    TaskTy_Reduce = 2
    TaskTy_None   = 3
)

type GainTaskArgs struct {
    WorkName string
}
type GainTaskReply struct {
    TaskId          int
    TaskTy          TaskType
    ReduceNumber    int
    InputFileHandle []string
}
type SubmitMapTaskArgs struct {
    TaskId           int
    WorkerName       WorkerIdent
    ResultFileHandle []string
}
type SubmitMapTaskReply struct {
    Accept bool
}
type SubmitReduceTaskArgs struct {
    TaskId     int
    WorkerName WorkerIdent
    ResultFile string
}
type SubmitReduceTaskReply struct {
    Accept bool
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;检查失败任务&lt;/h3&gt;
&lt;p&gt;Coordinator 应该检查 Worker 是否失败（故障）。这里使用判断10s 内任务是否结束，如果任务未结束，则表示任务可能停滞（故障），应该将任务标记为 IEDL 状态。&lt;/p&gt;
&lt;p&gt;由于 10s 的判断是实时的，不能在收到 Worker 信息的时候判断，否则如果所有的 Worker 都滞后时 Coordinator 也会滞后。这里采用开启一个线程每隔一段时间对所有的 Task 进行一次检查，并顺手更新所有任务的完成状态。&lt;/p&gt;
&lt;p&gt;记得在检查时加锁&lt;/p&gt;
&lt;h3&gt;备份任务&lt;/h3&gt;
&lt;p&gt;这实际上是一个坑点。由于测试数据中会检测 map 任务的执行数量，使用 Backup Task 可能会导致任务数量执行过多。在该 Lab 中应该按照要求，当任务超过 10s 后才应该启动备份任务，而非立刻执行。&lt;/p&gt;
&lt;h2&gt;完整代码&lt;/h2&gt;
&lt;p&gt;包含 Backup Task，不含挑战&lt;/p&gt;
&lt;h3&gt;coordinator.go&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package mr

import (
    &quot;log&quot;
    &quot;sync&quot;
    &quot;time&quot;
)
import &quot;net&quot;
import &quot;os&quot;
import &quot;net/rpc&quot;
import &quot;net/http&quot;

type TaskStatus int

const (
    TaskStatus_Idle      TaskStatus = 0
    TaskStatus_Running   TaskStatus = 1
    TaskStatus_Completed TaskStatus = 2
)

type WorkerIdent string

type GroupedIntermediaKV []KeyValue

type MapTask struct {
    id            int
    inputFileName string
    status        TaskStatus

    startTime    int64
    worker       WorkerIdent
    resultHandle []GroupedIntermediaKV
}

type ReduceTask struct {
    id            int
    status        TaskStatus
    inputFileName []string

    startTime    int64
    worker       WorkerIdent
    resultHandle string
}

type Coordinator struct {
    mapTasks    []MapTask
    reduceTasks []ReduceTask

    completedMapTask    int
    completedReduceTask int
    mu                  sync.Mutex
}

// start a thread that listens for RPCs from worker.go
func (c *Coordinator) server() {
    rpc.Register(c)
    rpc.HandleHTTP()
    //l, e := net.Listen(&quot;tcp&quot;, &quot;:1234&quot;)
    sockname := coordinatorSock()
    os.Remove(sockname)
    l, e := net.Listen(&quot;unix&quot;, sockname)
    if e != nil {
        log.Fatal(&quot;listen error:&quot;, e)
    }
    go http.Serve(l, nil)
}

func (c *Coordinator) maintainTask() {
    c.mu.Lock()
    currentTime := time.Now().Unix()
    log.Printf(&quot;Check tasks on %d&quot;, currentTime)
    completedMap := 0
    completedReduce := 0

    defer c.mu.Unlock()

    for i := 0; i &amp;lt; len(c.mapTasks); i++ {
        if c.mapTasks[i].status == TaskStatus_Running &amp;amp;&amp;amp; currentTime-c.mapTasks[i].startTime &amp;gt; 10 {
            // mark as failure
            log.Printf(&quot;Mark map task %d fail&quot;, c.mapTasks[i].id, c.mapTasks[i].worker)
            c.mapTasks[i].startTime = 0
            c.mapTasks[i].status = TaskStatus_Idle
        } else if c.mapTasks[i].status == TaskStatus_Completed {
            completedMap++
        }
    }

    for i := 0; i &amp;lt; len(c.reduceTasks); i++ {
        if c.reduceTasks[i].status == TaskStatus_Running &amp;amp;&amp;amp; currentTime-c.reduceTasks[i].startTime &amp;gt; 10 {
            // mark as failure
            log.Printf(&quot;Mark reduce task%d fail&quot;, c.reduceTasks[i].id, c.reduceTasks[i].worker)
            c.reduceTasks[i].startTime = 0
            c.reduceTasks[i].status = TaskStatus_Idle
        } else if c.reduceTasks[i].status == TaskStatus_Completed {
            completedReduce++
        }
    }

    if completedMap != c.completedMapTask {
        c.completedMapTask = completedMap
    }
    if completedReduce != c.completedReduceTask {
        c.completedReduceTask = completedReduce
    }
}

func (c *Coordinator) GainTask(args *GainTaskArgs, reply *GainTaskReply) error {
    c.maintainTask()
    c.mu.Lock()
    defer c.mu.Unlock()

    reply.ReduceNumber = len(c.reduceTasks)
    reply.TaskTy = TaskTy_None

    distributeMapTask := func(task *MapTask) {
        log.Printf(&quot;Distribute map task %d to worker %s&quot;, task.id, args.WorkName)
        reply.TaskTy = TaskTy_Map
        reply.TaskId = task.id
        reply.InputFileHandle = []string{task.inputFileName}

        task.status = TaskStatus_Running
        task.startTime = time.Now().Unix()
        task.worker = WorkerIdent(args.WorkName)
    }
    distributeReduceTask := func(task *ReduceTask) {
        log.Printf(&quot;Distribute reduce task %d to worker %s&quot;, task.id, args.WorkName)
        reply.TaskTy = TaskTy_Reduce
        reply.TaskId = task.id
        reply.InputFileHandle = task.inputFileName

        task.status = TaskStatus_Running
        task.startTime = time.Now().Unix()
        task.worker = WorkerIdent(args.WorkName)
    }

    if c.completedMapTask &amp;lt; len(c.mapTasks) {
        // distribute map task
        for i := range c.mapTasks {
            var task = &amp;amp;c.mapTasks[i]
            if task.status == TaskStatus_Idle {
                distributeMapTask(task)
                return nil
            }
        }
    }
    for c.completedMapTask &amp;lt; len(c.mapTasks) {
        // distribute map task
        currentTime := time.Now().Unix()
        for i := range c.mapTasks {
            var task = &amp;amp;c.mapTasks[i]
            if task.status != TaskStatus_Completed &amp;amp;&amp;amp; currentTime-task.startTime &amp;gt; 10 {
                distributeMapTask(task)
                return nil
            }
        }
        c.mu.Unlock()
        time.Sleep(1 * time.Second)
        c.mu.Lock()
    }

    if c.completedReduceTask &amp;lt; len(c.reduceTasks) {
        // distribute reduce task
        for i := range c.reduceTasks {
            var task = &amp;amp;c.reduceTasks[i]
            if task.status == TaskStatus_Idle {
                distributeReduceTask(task)
                return nil
            }
        }
    }
    for c.completedReduceTask &amp;lt; len(c.reduceTasks) {
        // distribute reduce task
        currentTime := time.Now().Unix()
        for i := range c.reduceTasks {
            var task = &amp;amp;c.reduceTasks[i]
            if task.status != TaskStatus_Completed &amp;amp;&amp;amp; currentTime-task.startTime &amp;gt; 10 {
                distributeReduceTask(task)
                return nil
            }
        }
        c.mu.Unlock()
        time.Sleep(1 * time.Second)
        c.mu.Lock()
    }

    return nil
}

func (c *Coordinator) SubmitMapTask(args *SubmitMapTaskArgs, reply *SubmitMapTaskReply) error {
    c.mu.Lock()
    defer c.mu.Unlock()
    if c.mapTasks[args.TaskId].status != TaskStatus_Completed {
        log.Printf(&quot;Accept map task %d from worker %v&quot;, args.TaskId, args.WorkerName)
        reply.Accept = true
        c.mapTasks[args.TaskId].status = TaskStatus_Completed
        for rid, filename := range args.ResultFileHandle {
            c.reduceTasks[rid].inputFileName = append(c.reduceTasks[rid].inputFileName, filename)
        }
    } else {
        log.Printf(&quot;Refuse map task %d from worker %v&quot;, args.TaskId, args.WorkerName)
        reply.Accept = false
    }

    return nil
}

func (c *Coordinator) SubmitReduceTask(args *SubmitReduceTaskArgs, reply *SubmitReduceTaskReply) error {
    c.mu.Lock()
    defer c.mu.Unlock()
    if c.reduceTasks[args.TaskId].status != TaskStatus_Completed {
        log.Printf(&quot;Accept reduce task %d from worker %v&quot;, args.TaskId, args.WorkerName)
        reply.Accept = true
        c.reduceTasks[args.TaskId].status = TaskStatus_Completed
        c.reduceTasks[args.TaskId].resultHandle = args.ResultFile
    } else {
        log.Printf(&quot;Refuse reduce task %d from worker %v&quot;, args.TaskId, args.WorkerName)
        reply.Accept = false
    }
    return nil
}

// main/mrcoordinator.go calls Done() periodically to find out
// if the entire job has finished.
func (c *Coordinator) Done() bool {
    c.mu.Lock()
    defer c.mu.Unlock()
    return c.completedReduceTask == len(c.reduceTasks)
}

// create a Coordinator.
// main/mrcoordinator.go calls this function.
// nReduce is the number of reduce tasks to use.
func MakeCoordinator(files []string, nReduce int) *Coordinator {
    c := Coordinator{}

    c.reduceTasks = make([]ReduceTask, nReduce)
    for i := 0; i &amp;lt; nReduce; i++ {
        t := &amp;amp;c.reduceTasks[i]
        t.id = i
        t.status = TaskStatus_Idle
    }

    for id, splitFile := range files {
        c.mapTasks = append(c.mapTasks, MapTask{
            id:            id,
            status:        TaskStatus_Idle,
            inputFileName: splitFile,
        })
        log.Printf(&quot;Schedule map task %d from %s&quot;, id, splitFile)
    }
    go func() {
        for {
            c.maintainTask()
            time.Sleep(time.Second)
        }
    }()

    log.Println(&quot;Coordinator tasks init finish&quot;)
    c.server()
    return &amp;amp;c
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;worker.go&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package mr

import (
    &quot;encoding/json&quot;
    &quot;fmt&quot;
    &quot;io&quot;
    &quot;math/rand&quot;
    &quot;os&quot;
    &quot;os/exec&quot;
    &quot;sort&quot;
    &quot;time&quot;
)
import &quot;log&quot;
import &quot;net/rpc&quot;
import &quot;hash/fnv&quot;

// Map functions return a slice of KeyValue.
type KeyValue struct {
    Key   string
    Value string
}

// use ihash(key) % NReduce to choose the reduce
// task number for each KeyValue emitted by Map.
func ihash(key string) int {
    h := fnv.New32a()
    h.Write([]byte(key))
    return int(h.Sum32() &amp;amp; 0x7fffffff)
}

// for sorting by key.
type ByKey []KeyValue

func (a ByKey) Len() int           { return len(a) }
func (a ByKey) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }
func (a ByKey) Less(i, j int) bool { return a[i].Key &amp;lt; a[j].Key }

func ExecuteMap(mapf func(string, string) []KeyValue, taskId int, inputFileHandle string, nReduce int, workerName WorkerIdent) {
    log.Printf(&quot;Start map task %d&quot;, taskId)

    file, err := os.Open(inputFileHandle)
    if err != nil {
        log.Fatal(err)
    }
    content, err := io.ReadAll(file)
    if err != nil {
        log.Fatal(err)
    }
    kv := mapf(inputFileHandle, string(content))

    kva := make(map[int][]KeyValue)
    for _, p := range kv {
        rid := ihash(p.Key) % nReduce
        kva[rid] = append(kva[rid], p)
    }

    params := SubmitMapTaskArgs{TaskId: taskId, ResultFileHandle: make([]string, nReduce), WorkerName: workerName}
    reply := SubmitMapTaskReply{}

    for rid, intermedia := range kva {
        filename := fmt.Sprintf(&quot;mr-%d-%d&quot;, taskId, rid)
        params.ResultFileHandle[rid] = filename

        file, err := os.Create(filename)
        defer file.Close()
        if err != nil {
            log.Fatal(err)
        }
        enc := json.NewEncoder(file)
        for _, kv := range intermedia {
            err := enc.Encode(&amp;amp;kv)
            if err != nil {
                log.Fatal(err)
            }
        }
    }

    if !call(&quot;Coordinator.SubmitMapTask&quot;, &amp;amp;params, &amp;amp;reply) {
        log.Fatal(&quot;Coordinator is down?&quot;)
    }
    if reply.Accept {
        log.Printf(&quot;Map task%d completed&quot;, taskId)
    } else {
        log.Printf(&quot;Map task%d unacceptable&quot;, taskId)
    }
}

func ExecuteReduce(reducef func(string, []string) string, taskId int, inputFileHandles []string, workerName WorkerIdent) {
    log.Printf(&quot;Start reduce task %d&quot;, taskId)

    kva := make([]KeyValue, 0)
    for _, handle := range inputFileHandles {
        if handle == &quot;&quot; {
            continue
        }

        file, err := os.Open(handle)
        if err != nil {
            log.Fatal(err)
        }
        dec := json.NewDecoder(file)
        for {
            var kv KeyValue
            if err := dec.Decode(&amp;amp;kv); err != nil {
                break
            }
            kva = append(kva, kv)
        }
    }

    sort.Sort(ByKey(kva))

    oname := fmt.Sprintf(&quot;mr-out-%d&quot;, taskId)
    ofile, _ := os.CreateTemp(&quot;&quot;, oname+&quot;-*&quot;)

    i := 0
    for i &amp;lt; len(kva) {
        j := i + 1
        for j &amp;lt; len(kva) &amp;amp;&amp;amp; kva[j].Key == kva[i].Key {
            j++
        }
        values := []string{}
        for k := i; k &amp;lt; j; k++ {
            values = append(values, kva[k].Value)
        }
        output := reducef(kva[i].Key, values)

        // this is the correct format for each line of Reduce output.
        fmt.Fprintf(ofile, &quot;%v %v\n&quot;, kva[i].Key, output)
        i = j
    }

    err := os.Rename(ofile.Name(), oname)
    if err != nil {
        log.Fatal(err)
    }
    params := SubmitReduceTaskArgs{
        TaskId:     taskId,
        WorkerName: workerName,
        ResultFile: oname,
    }
    reply := SubmitReduceTaskReply{}
    if !call(&quot;Coordinator.SubmitReduceTask&quot;, &amp;amp;params, &amp;amp;reply) {
        log.Fatal(&quot;Coordinator is down?&quot;)
    }
    if reply.Accept {
        log.Printf(&quot;Reduce task%d completed&quot;, taskId)
    } else {
        log.Printf(&quot;Reduce task%d unacceptable&quot;, taskId)
    }
}

// main/mrworker.go calls this function.
func Worker(mapf func(string, string) []KeyValue,
    reducef func(string, []string) string) {
    rand.Seed(time.Now().UnixNano())
    workerName, err := exec.Command(&quot;uuidgen&quot;).Output()
    if err != nil {
        log.Fatal(err)
    }
    log.Printf(&quot;Worker name: %s\n&quot;, workerName)

    for {
        taskReply := GainTaskReply{}
        call(&quot;Coordinator.GainTask&quot;, GainTaskArgs{WorkName: string(workerName)}, &amp;amp;taskReply)

        if taskReply.TaskTy == TaskTy_Map {
            ExecuteMap(mapf, taskReply.TaskId, taskReply.InputFileHandle[0], taskReply.ReduceNumber, WorkerIdent(workerName))
        } else if taskReply.TaskTy == TaskTy_Reduce {
            ExecuteReduce(reducef, taskReply.TaskId, taskReply.InputFileHandle, WorkerIdent(workerName))
        } else if taskReply.TaskTy == TaskTy_None {
            log.Printf(&quot;Receive exit signal&quot;)
            os.Exit(0)
        } else {
            log.Printf(&quot;Unrecongized task type %d&quot;, taskReply.TaskTy)
        }
    }
}

// send an RPC request to the coordinator, wait for the response.
// usually returns true.
// returns false if something goes wrong.
func call(rpcname string, args interface{}, reply interface{}) bool {
    // c, err := rpc.DialHTTP(&quot;tcp&quot;, &quot;127.0.0.1&quot;+&quot;:1234&quot;)
    sockname := coordinatorSock()
    c, err := rpc.DialHTTP(&quot;unix&quot;, sockname)
    if err != nil {
        log.Fatal(&quot;dialing:&quot;, err)
    }
    defer c.Close()

    err = c.Call(rpcname, args, reply)
    if err == nil {
        return true
    }

    fmt.Println(err)
    return false
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;rpc.go&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package mr

//
// RPC definitions.
//
// remember to capitalize all names.
//

import &quot;os&quot;
import &quot;strconv&quot;

type TaskType int

const (
    TaskTy_Map    = 1
    TaskTy_Reduce = 2
    TaskTy_None   = 3
)

type GainTaskArgs struct {
    WorkName string
}
type GainTaskReply struct {
    TaskId          int
    TaskTy          TaskType
    ReduceNumber    int
    InputFileHandle []string
}

type SubmitMapTaskArgs struct {
    TaskId           int
    WorkerName       WorkerIdent
    ResultFileHandle []string
}
type SubmitMapTaskReply struct {
    Accept bool
}
type SubmitReduceTaskArgs struct {
    TaskId     int
    WorkerName WorkerIdent
    ResultFile string
}
type SubmitReduceTaskReply struct {
    Accept bool
}

// Cook up a unique-ish UNIX-domain socket name
// in /var/tmp, for the coordinator.
// Can&apos;t use the current directory since
// Athena AFS doesn&apos;t support UNIX-domain sockets.
func coordinatorSock() string {
    s := &quot;/var/tmp/824-mr-&quot;
    s += strconv.Itoa(os.Getuid())
    return s
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>MIT6.824</category><category>分布式系统</category><author>Mslxl</author></item><item><title>皈依 NixOS</title><link>https://blog.mslxl.com/posts/os/convert-nix/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/os/convert-nix/</guid><pubDate>Thu, 14 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;用了几天时间折腾 NixOS，现在大概是能满足日常日常使用了，几天使用下来体验还算不错。这也不是我第一次使用 Linux 发行版了，但如果不是因为事先了解，初次使用肯定也是发愣的。&lt;/p&gt;
&lt;p&gt;不同于其他 Linux 发行版，NixOS 并没有遵守 FHS 标准，也就是说其他发行版的经验很难在 NixOS 同用。在刚安装时最明显的特点有两个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统配置目录（&lt;code&gt;/etc&lt;/code&gt;）下在文件都是只读的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/bin/sh&lt;/code&gt; 目录只有 &lt;code&gt;sh&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;NixOS 几乎将所有的文件存储在 &lt;code&gt;/nix/store&lt;/code&gt; 下，而后通过链接的方式放到对应的文件夹下，而 &lt;code&gt;/nix/store&lt;/code&gt; 又是通过 &lt;code&gt;/etc/nixos/configuration.nix&lt;/code&gt; 配置获得的。用户也是通过修改 &lt;code&gt;configuration.nix&lt;/code&gt; 文件来修改系统配置甚至是单个用户的配置，在修改后使用 &lt;code&gt;nixos-rebuild switch&lt;/code&gt; 命令应用新配置。这条命令实际上重新“构建“了一个新生代的系统，但之前的老年代并不会删除，用户仍然可以随时切换到之前配置的系统。因此 NixOS 也被称为滚不挂的系统（不作死的情况）。&lt;/p&gt;
&lt;p&gt;实际上 NixOS 经常被人诟病占用硬盘，上手难度高，软件打包困难等。这些问题确实存在，可能这也是 NixOS 使用人数少的原因。另一方面 NixOS 的配置非常依赖于查阅文档，但官方 Wiki 的部分条目其实是过时的，有时候不得不去一些论坛或者 Issue 去找解决方案。&lt;/p&gt;
&lt;p&gt;NixOS 的优点主要就是集中在可重复性和软件隔离上。可重复性即如果 &lt;code&gt;configuratoin.nix&lt;/code&gt; 中的内容是相同的且为 pure 的，那么同一份配置文件会产生完全一样的系统。而软件隔离则是因为 NixOS 将几乎所有的软件都存放在 &lt;code&gt;/etc/nixos&lt;/code&gt;中，这些软件可能是同一个程序的不同版本，他们可以在系统中同时存在，同时选择地依赖其他软件的某个特定版本，不会像其他系统一样发生冲突。&lt;/p&gt;
&lt;h2&gt;Nix&lt;/h2&gt;
&lt;p&gt;配置 NixOS 使用的是 Nix 语言，这是一个函数式脚本语言，NixOS 上手难度高的原因主要来自于此。&lt;/p&gt;
&lt;p&gt;就我个人的感觉来说，Nix 语言更像是围绕 attributes set 的一种配置文件，只是这种配置文件可以以代码的方式执行&lt;/p&gt;
&lt;p&gt;它的画风大部分是这样：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;imports =
    [
      # Include the results of the hardware scan.
      ../../modules/system.nix
      ./hardware.nix
    ];

  # for Nvidia GPU
  services.xserver.videoDrivers = [ &quot;nvidia&quot; ];
  hardware.opengl.enable = true;
  hardware.nvidia = {
    package = config.boot.kernelPackages.nvidiaPackages.stable;
    modesetting.enable = true;
  };

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;有时候是这样:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;args:
# execute and import all overlay files in the current directory with the given args
builtins.map
  (f: (import (./. + &quot;/${f}&quot;) args)) # execute and import the overlay file
  (builtins.filter # find all overlay files in the current directory
    (f:
    f != &quot;default.nix&quot; # ignore default.nix
      &amp;amp;&amp;amp; f != &quot;README.md&quot;  # ignore README.md
    )
    (builtins.attrNames (builtins.readDir ./.)))

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;除了学习成本较高和社区较小之外，书写体验还算不错，这里留下一个比较不错的学习资料: &lt;a href=&quot;https://thiscute.world/posts/nixos-and-flake-basics/&quot;&gt;This cute world&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;nixpkgs&lt;/h2&gt;
&lt;p&gt;&lt;s&gt;原来一个软件库可以这么复杂&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;这个是 NixOS 的官方软件库，除此之外还有由用户维护的类似 AUR 的 NUR。这个软件库的设计比较 magic。&lt;/p&gt;
&lt;p&gt;nixpkgs 的实现依赖 Nix 中的 derivation，在安装软件的时候可以很方便的在配置中进行安装，或者通过 override 来替换某个软件的依赖项。这是因为 nixpkgs 中的软件包实际上是一个返回 derivation 的函数，那么只需要修改这个 derivation 就可以对软件包进行魔改了。&lt;/p&gt;
&lt;p&gt;值得一提的是，由于 NixOS 并没有遵守 FHS，其他发行版中的软件要通过 patchelf 才能正常的运行，一般来说我们会通过打包的方式来进行自动安装和 patch。不过在进行本地构建时，全过程默认是运行在沙箱中，不能连接到互联网，也就是说在打包前需要将所有需要的文件全部准备好。&lt;/p&gt;
&lt;p&gt;以下是 typora 的 derivation&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{stdenv,
 dpkg,
 wrapGAppsHook,
 fetchurl,

 lib,
 glib,
 electron,
 gsettings-desktop-schemas,
 makeWrapper,
 gtk3,
 withPandoc ? true,
 pandoc}:
let
  version = &quot;1.7.4&quot;;
in stdenv.mkDerivation  {
  name = &quot;typora-${version}&quot;;
  system = &quot;x86_64-linux&quot;;

  nativeBuildInputs = [
    wrapGAppsHook
    dpkg
  ];
  src = fetchurl {
    url = &quot;https://download.typora.io/linux/typora_1.7.4_amd64.deb&quot;;
    hash = &quot;sha256-ugBRijuXh4YHQeoPxGx0OrmsaoK7kAKKCKRNrvi63tc=&quot;;
  };
  buildInputs = [
    makeWrapper
    glib
    gsettings-desktop-schemas
    gtk3
  ];
  unpackPhase = &apos;&apos;
    ar x $src
    tar xf data.tar.xz
  &apos;&apos;;

  # Extract and copy executable in $out/bin
  installPhase = &apos;&apos;
    runHook preInstall
    mkdir -p $out/bin $out/share
    {
      cd usr
      mv share/typora/resources $out/share/typora
      mv share/{applications,icons,doc} $out/share/
    }
    runHook postInstall
  &apos;&apos;;

  postFixup = &apos;&apos;
    makeWrapper ${electron}/bin/electron $out/bin/typora \
        --add-flags $out/share/typora/app.asar \
        &quot;&apos;&apos;${gappsWrapperArgs[@]}&quot; \
        ${lib.optionalString withPandoc &apos;&apos;--prefix PATH : &quot;${lib.makeBinPath [ pandoc ]}&quot;&apos;&apos;} \
        --prefix LD_LIBRARY_PATH : &quot;${lib.makeLibraryPath [ stdenv.cc.cc ]}&quot;
  &apos;&apos;;

  meta = with lib; {
    description = &quot;Typora&quot;;
    homepage = https://typora.io;
    # license = licenses.unfree;
    maintainers = with stdenv.lib.maintainers; [ ];
    platforms = [ &quot;x86_64-linux&quot; ];
  };
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;nix-shell&lt;/h2&gt;
&lt;p&gt;这是一种类似 Python 的 virtualenv 的沙箱，但它做的更彻底一点。nix-shell 会将环境需要的软件和 native library 放在 &lt;code&gt;/nix/store/&lt;/code&gt; 中，然后通过 &lt;code&gt;PATH&lt;/code&gt; 等方式指过去。由于 &lt;code&gt;/nix/store&lt;/code&gt; 本身是只读，所以不同的环境之间是不会相互影响。同时由于 nix-shell 会管理所有的依赖，而不是像 virtualenv 一样只隔离 python，这使的它的环境更加的稳定。&lt;/p&gt;
&lt;p&gt;如果借助 direnv，就可以在 shell 进入目录时自动应用环境。&lt;/p&gt;
&lt;p&gt;以隔离的 GO 语言环境为例， 在 &lt;code&gt;.direnv&lt;/code&gt; 写入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use flake
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;flake.nix&lt;/code&gt; 文件:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;{
  description = &quot;A Nix-flake-based Go 1.17 development environment&quot;;
  inputs.nixpkgs.url = &quot;github:NixOS/nixpkgs/nixpkgs-unstable&quot;;
  outputs = { self, nixpkgs }:
    let
      goVersion = 20; # Change this to update the whole stack
      overlays = [ (final: prev: { go = prev.&quot;go_1_${toString goVersion}&quot;; }) ];
      supportedSystems = [ &quot;x86_64-linux&quot; &quot;aarch64-linux&quot; &quot;x86_64-darwin&quot; &quot;aarch64-darwin&quot; ];
      forEachSupportedSystem = f: nixpkgs.lib.genAttrs supportedSystems (system: f {
        pkgs = import nixpkgs { inherit overlays system; };
      });
    in
    {
      devShells = forEachSupportedSystem ({ pkgs }: {
        default = pkgs.mkShell {
          packages = with pkgs; [
            # go 1.20 (specified by overlay)
            go
            # goimports, godoc, etc.
            gotools
            # https://github.com/golangci/golangci-lint
            golangci-lint
          ];
        };
      });
    };
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;每次在进入这个环境时都会自动应用 go1.20 的环境，而退出时会自动卸载环境，全过程十分的方便&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;shot_1694711757.png&quot; alt=&quot;shot_1694711757&quot; /&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;我的个人电脑的桌面环境是使用了 Hyprland + Waybar，配置借助了 Flake 和 Homemanager。目前所有的配置文件进行了一些模块化，但稍微有点野路子的味道，可能以后会参考 &lt;a href=&quot;https://github.com/Misterio77/nix-starter-configs&quot;&gt;Misterio77/nix-starter-configs&lt;/a&gt; 重构一下代码&lt;/p&gt;
&lt;p&gt;配置文件在这: &lt;a href=&quot;https://github.com/mslxl/.dotfile&quot;&gt;mslxl/.dotfile&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;shot_1694708389.png&quot; alt=&quot;Whole&quot; /&gt;&lt;/p&gt;
&lt;p&gt;配置过程时，软件的主要从 &lt;a href=&quot;https://nixos.org/nixos/packages.html?channel=nixos-20.03&quot;&gt;NixOS Package Search&lt;/a&gt; 中查询，部分与系统关系比较密切的通过 &lt;a href=&quot;https://search.nixos.org/options&quot;&gt;Option&lt;/a&gt; 开启&lt;/p&gt;
&lt;p&gt;使用中 NixOS 还是比较舒爽的，以安装 atuin 为例，如果是其他发行版安装可能还需要手动修改 &lt;code&gt;.zshrc&lt;/code&gt; 文件，而 nix 只需要简单的添加 4 行配置，其他过程由 nix 自动完成。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt; programs.atuin = {
    enable = true;
    enableBashIntegration = true;
    enableZshIntegration = true;
  };
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;先说这些，如果以后在使用时需要什么问题再做补充&lt;/p&gt;
</content:encoded><category>Linux</category><category>NixOS</category><author>Mslxl</author></item><item><title>Codeforces Round 897 (Div. 2)</title><link>https://blog.mslxl.com/posts/cp/cf1867/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/cf1867/</guid><pubDate>Tue, 12 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;s&gt;打了一半困了，提前下班了&lt;/s&gt;&lt;/p&gt;
&lt;h2&gt;A. green_gold_dog, array and permutation&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给一个长度为 $n$ 的数组 $a$，找到一个长度为 $n$ 的排列 $b$，使之 $a_i - b_i$ 的值不同的数量最大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;离散化&lt;/code&gt; &lt;code&gt;贪心&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看样例大胆猜测将数组中第 $k$ 大的元素和排列中的 $n-k$ 放在一起，可以使 $a_i - b_i$ 的值不同的数量最大&lt;/p&gt;
&lt;p&gt;如果用最大的数减去最小的数，第二大的数减去第二小的数，依次类推，所获得的值应该是依次递减的&lt;/p&gt;
&lt;p&gt;因为 $a_1 \ge a_2 \ge a_3 \ge \ldots \ge a_n$ ，而 $b_1 &amp;lt; b_2 &amp;lt; \ldots &amp;lt; b_n$，则 $-b_1 &amp;gt; -b_2 &amp;gt; \ldots &amp;gt; -b_n$，最终结果 $a_1 - b_1 &amp;gt; a_2 - b_2 &amp;gt; \ldots &amp;gt; a_n - b_n$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Pair struct {
    a, b int
}
type Pairs []Pair

func (arr Pairs) Less(i, j int) bool {
    return arr[i].a &amp;gt; arr[j].a
}
func (arr Pairs) Swap(i, j int) {
    arr[i], arr[j] = arr[j], arr[i]
}
func (arr Pairs) Len() int {
    return len(arr)
}

func solve(in *bufio.Reader) {
    readInt(in)
    a := readArrInt(in)
    b := make(Pairs, len(a))
    for i, v := range a {
        b[i].a = v
        b[i].b = i
    }
    sort.Sort(b)
    for i, v := range b {
        a[v.b] = i
    }
    for _, v := range a {
        fmt.Printf(&quot;%d &quot;, v+1)
    }
    fmt.Println()
}

func main() {
    in := bufio.NewReader(os.Stdin)
    T := readInt(in)
    for i := 0; i &amp;lt; T; i++ {
        solve(in)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. XOR Palindormes&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给一个长度为 $n$ 的 01 串$s$。定义数字 $x$ 是好的，当且仅当存在一个长度为 $n$ 的 01 串$l$包含 $x$ 个1，且 $c = l \oplus s$ 的结果是回文串&lt;/p&gt;
&lt;p&gt;输出答案长度为 $n+1$序列 $a$，当数字 $x$ 是好的，令 $a_x = 1$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;贪心&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当 $l$ 中的某一位为 $1$时，$l \oplus s$ 的结果会使 $s$ 中的某位反转，即$l$ 中包含 1 的数量 $x$ 为反转 $s$ 的位数&lt;/p&gt;
&lt;p&gt;当 $n &amp;gt; 2 $ 时且 $n$ 为偶数时，如果可以通过反转 $k$ 位$s$中的内容，使的结果是回文串，那么反转 $k+2$ 位的结果一定也是回文串（反转任意两个对称的位置）&lt;/p&gt;
&lt;p&gt;当 $n &amp;gt; 2$ 且 $n$ 为奇数时，反转 $k+2$ 的结果也是回文串（反转任意两个对称位置），反转 $k + 1$ 的结果也是回文串（反转串 $s$ 的中心位置）&lt;/p&gt;
&lt;p&gt;特判 $n=2$ 的情况&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func solve(in *bufio.Reader) {
    n := readInt(in)
    s, _ := in.ReadString(&apos;\n&apos;)
    s = strings.Trim(s, &quot; \r\n\t&quot;)

    cnt := 0
    for i := 0; i &amp;lt; len(s)/2; i++ {
        if i == n-1-i {
            break
        }
        if s[i] != s[n-1-i] {
            cnt++
        }
    }
    for i := 0; i &amp;lt; cnt; i++ {
        fmt.Print(&quot;0&quot;)
    }
    if n%2 == 0 {
        for i := cnt; i &amp;lt;= n-cnt; i++ {
            if (i-cnt)%2 == 0 {
                fmt.Print(&quot;1&quot;)
            } else {
                fmt.Print(&quot;0&quot;)
            }
        }
    } else {
        for i := cnt; i &amp;lt;= n-cnt; i++ {
            fmt.Print(&quot;1&quot;)
        }
    }
    for i := n - cnt + 1; i &amp;lt; n+1; i++ {
        fmt.Print(&quot;0&quot;)
    }
    fmt.Println()
}

func main() {
    in := bufio.NewReader(os.Stdin)
    T := readInt(in)
    for i := 0; i &amp;lt; T; i++ {
        solve(in)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Salyg1n and the MEX Game&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;交互题&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;有一个集合 $S$ 包含 $n$ 个不同的数字 $s_1, s_2, \ldots,s_n$，Alice 和 Bob 玩游戏，规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;玩家轮流行动，Alice 先手&lt;/li&gt;
&lt;li&gt;Alice 的一次行动可以向 $S$ 中添加一个数字 $x$，在这之前 $x \not{\in} S$&lt;/li&gt;
&lt;li&gt;Bob 的一次行动可以从 $S$ 中删除一个数字 $y$，删除的数字 $y$ 必须存在与 $S$ 且&lt;strong&gt;严格小于&lt;/strong&gt;上次 Alice 添加 $x$&lt;/li&gt;
&lt;li&gt;游戏将在 $2\cdot n + 1$ 回合后（Alice 最后行动），或者是 Bob 无法行动时停止&lt;/li&gt;
&lt;li&gt;游戏的最终结果为 $MEX(S)$&lt;/li&gt;
&lt;li&gt;Alice 的目标为最大化结果，Bob 要最小化结果&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;交互&lt;/code&gt; &lt;code&gt;贪心&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;除非 Bob 无法行动，否则无论 Alice 在前一步做何决策，Bob 总可以使游戏的结果变为 $0$（即Bob移除0）。而无论 Bob 做什么行动，下一轮中 Alice 总可以抵消掉 Bob 的行动（即将删除的数重新添加）&lt;/p&gt;
&lt;p&gt;也就是说在前 $2\cdot n$ 中，Alice 只能维持游戏的结果不减小，而 Bob 什么也做不到。行动策略不论 Bob 删除什么数， Alice 只需要每次添加集合中不存在的最小的数，那么游戏的结果将不会减小&lt;/p&gt;
&lt;p&gt;糊个堆贪心即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import (
    &quot;bufio&quot;
    &quot;container/heap&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;strings&quot;
)

func FPrintln(v interface{}) {
    _, _ = fmt.Fprintln(os.Stdout, v)
}

type hp []int

func (h hp) Len() int           { return len(h) }
func (h hp) Less(i, j int) bool { return h[i] &amp;lt; h[j] }
func (h hp) Swap(i, j int)      { h[i], h[j] = h[j], h[i] }
func (h *hp) Push(v any)        { *h = append(*h, v.(int)) }
func (h *hp) Pop() any          { a := *h; v := a[len(a)-1]; *h = a[:len(a)-1]; return v }
func (h *hp) push(v int)        { heap.Push(h, v) }
func (h *hp) pop() int          { return heap.Pop(h).(int) }

func solve(in *bufio.Reader) {
    n := readInt(in)
    s := make(map[int]bool)
    seq := readArrInt(in)
    for _, x := range seq {
        s[x] = true
    }
    mex := make(hp, 0)
    for i := 0; i &amp;lt;= n+1; i++ {
        if _, exists := s[i]; !exists {
            mex.push(i)
        }
    }

    stop := true
    for round := 0; round &amp;lt; 2*n+1 &amp;amp;&amp;amp; stop; round++ {
        v := mex.pop()
        FPrintln(v)

        y := readInt(in)
        if y == -1 {
            stop = false
        } else {
            delete(s, y)
            mex.push(y)
        }
    }
}

func main() {
    in := bufio.NewReader(os.Stdin)
    T := readInt(in)
    for i := 0; i &amp;lt; T; i++ {
        solve(in)
    }
}

&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Codeforces</category><category>Competitive Programming</category><author>Mslxl</author></item><item><title>速通 Go 语言基础</title><link>https://blog.mslxl.com/posts/others/go-speedrun/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/go-speedrun/</guid><pubDate>Fri, 08 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;马上就退役了，要为下一步做点准备了。先速通一下 GO 语言基础，本文章参考了 GO TOUR 和字节的青训营课程，通过列出一些代码来快速上手 GO 语言。&lt;/p&gt;
&lt;p&gt;阅读可能要需要具有其他语言的编程经验&lt;/p&gt;
&lt;h2&gt;语法&lt;/h2&gt;
&lt;h3&gt;hello,world&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;hello, world&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;程序总是从 main 包下的 main 函数开始执行&lt;/p&gt;
&lt;p&gt;import 语句可以导入包，除了使用 &lt;code&gt;import&lt;/code&gt; 语言单个单个导入外，还可以使用分组导入&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import (
    &quot;fmt&quot;
    &quot;math&quot;
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;函数&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;func add(x int, y int) int {
    return x + y
}
// 缩写
func minus(x, y int) int {
    return x - y
}

// 多值返回
func swap(x, y string) (string, string) {
    return y, x
}
// 具名返回
func split10(sum int) (x, y int) {
    x = sum / 10
    y = sum % 10
    return
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;变量&lt;/h3&gt;
&lt;p&gt;基本类型有&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;string&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int&lt;/code&gt; &lt;code&gt;int8&lt;/code&gt; &lt;code&gt;int16&lt;/code&gt; &lt;code&gt;int32&lt;/code&gt; &lt;code&gt;int64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;uint&lt;/code&gt; &lt;code&gt;uint8&lt;/code&gt; &lt;code&gt;uint16&lt;/code&gt; &lt;code&gt;uint32&lt;/code&gt; &lt;code&gt;uint64&lt;/code&gt; &lt;code&gt;uintptr&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;byte&lt;/code&gt; (&lt;code&gt;uint8&lt;/code&gt; 的别名)&lt;/li&gt;
&lt;li&gt;&lt;code&gt;rune&lt;/code&gt; （&lt;code&gt;int32&lt;/code&gt; 的别名，表示一个 Unicode 码点）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;float32&lt;/code&gt; &lt;code&gt;float64&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;complex64&lt;/code&gt; &lt;code&gt;complex128&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;int&lt;/code&gt;, &lt;code&gt;uint&lt;/code&gt; 和 &lt;code&gt;uintptr&lt;/code&gt; 在 32 位系统上通常为 32 位宽，在 64 位系统上则为 64 位宽&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package mainjj
import &quot;math&quot;
func main(){
    var value int
    var pi float64
    // 声明并赋值
    e := 2.71828

    sqrt2 := math.Sqrt(float64(sqrt()))

    var g complex64 = 3 + 2i;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;常量&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;const (
    Big = 1 &amp;lt;&amp;lt; 100
    Small = Big &amp;gt;&amp;gt; 9
)
func main(){
    const Pi = 3.14
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;控制流&lt;/h3&gt;
&lt;h4&gt;判断&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package main
func main(){

    if x &amp;gt; 10 {}

    if x &amp;gt; 10 {}
    else {}

    if x &amp;gt; 10 {}
    else if x &amp;lt; 10 {}
    else {}

    // 使用简短语句
    if v:= LoadSth(); v &amp;gt; 10 {

    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;分支&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package main
func main(){
    value := 10
    switch 30 {
    case value :
        DoSth()
    case value + 1:
        DoSth()
    default:
        DoNothing()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;不带条件的 switch&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main
func main(){
    value := 10
    switch {
    case value &amp;gt; 10:
        DoSth()
    case value &amp;lt; 10:
        DoSth()
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;循环&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;package main
import &quot;fmt&quot;
func main(){
    for i:= 0; i &amp;lt; 10; i++ {
        fmt.Println(i)
    }
    // 相当于 C/C++ 中的 while
    for false {
        fmt.Println(&quot;Unreachable&quot;)
    }

    // 相当于 C/C++ 中的 while true
    for {
        fmt.Println(&quot;Unstopable&quot;)
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;推迟&lt;/h4&gt;
&lt;p&gt;使用 &lt;code&gt;defer&lt;/code&gt; 会将后面的语句放在当前作用域结束时执行&lt;/p&gt;
&lt;p&gt;执行顺序如栈，总是先进后执行&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main
import &quot;fmt&quot;
func main(){
    defer fmt.Println(&quot;1&quot;)
    defer fmt.Println(&quot;2&quot;)
    defer fmt.Println(&quot;3&quot;)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;输出信息&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;3&lt;/p&gt;
&lt;p&gt;2&lt;/p&gt;
&lt;p&gt;1&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;指针&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main
import &quot;fmt&quot;
func main(){
    var p *int // 指向 int 的指针 *int

    num := 42
    ptr := &amp;amp;num // 通过 &amp;amp; 计算地址

    fmt.Println(*ptr)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;结构体&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;type Vertex struct {
    X int
    Y int
}

var (
    v1 = Vertex{1, 2}

    p = &amp;amp;Vertex{1, 2} // 这是一个指针
)
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;数组&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var a [10] int
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;切片&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var a [10]int
var s []int = a[1:4] //行为像 python 中的切片

r := []bool{true, false, true, true, false, true}
s := []struct {
        i int
        b bool
    }{
        {2, true},
        {3, false},
        {5, true},
        {7, true},
        {11, false},
        {13, true},
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;容量与长度&lt;/h4&gt;
&lt;p&gt;切片的长度就是它所包含的元素个数。&lt;/p&gt;
&lt;p&gt;切片的容量是从它的第一个元素开始数，到其底层数组元素末尾的个数。&lt;/p&gt;
&lt;p&gt;切片 &lt;code&gt;s&lt;/code&gt; 的长度和容量可通过表达式 &lt;code&gt;len(s)&lt;/code&gt; 和 &lt;code&gt;cap(s)&lt;/code&gt; 来获取。&lt;/p&gt;
&lt;p&gt;切片的零值是 &lt;code&gt;nil&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;nil 切片的长度和容量为 0 且没有底层数组&lt;/p&gt;
&lt;h4&gt;用 make 创建切片&lt;/h4&gt;
&lt;p&gt;切片可以用内建函数 &lt;code&gt;make&lt;/code&gt; 来创建，这也是你创建动态数组的方式。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;make&lt;/code&gt; 函数会分配一个元素为零值的数组并返回一个引用了它的切片：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;a := make([]int, 5)  // len(a)=5
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;要指定它的容量，需向 &lt;code&gt;make&lt;/code&gt; 传入第三个参数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;b := make([]int, 0, 5) // len(b)=0, cap(b)=5

b = b[:cap(b)]         // len(b)=5, cap(b)=5
b = b[1:]              // len(b)=4, cap(b)=4
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;操作&lt;/h4&gt;
&lt;h5&gt;append&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;func append(s []T, vs ...T) []T
&lt;/code&gt;&lt;/pre&gt;
&lt;h5&gt;range&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;for i, v := range pow {
        fmt.Printf(&quot;index %d value %d&quot;, i, v)
}
// 忽略下标
for _, v := range pow {
        fmt.Printf(&quot;value %d&quot;, v)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;映射&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;var m map[string]Vertex

var m = map[string]Vertex{
    &quot;Bell Labs&quot;: Vertex{
        40.68433, -74.39967,
    },
    &quot;Google&quot;: { // 若顶级类型只是一个类型名，你可以在文法的元素中省略它
        37.42202, -122.08408,
    },
}

&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;删除元素：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;delete(m, key)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过双赋值检测某个键是否存在：&lt;/p&gt;
&lt;p&gt;若 &lt;code&gt;key&lt;/code&gt; 在 &lt;code&gt;m&lt;/code&gt; 中，&lt;code&gt;ok&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt; ；否则，&lt;code&gt;ok&lt;/code&gt; 为 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;elem, ok = m[key]
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;方法&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;type Vertex struct {
    X, Y float64
}

func (v Vertex) Abs() float64 {
    return math.Sqrt(v.X*v.X + v.Y*v.Y)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;指针接收者的方法可以修改接收者指向的值（就像 &lt;code&gt;Scale&lt;/code&gt; 在这做的）。由于方法经常需要修改它的接收者，指针接收者比值接收者更常用。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func (v *Vertex) Scale(f float64) {
    v.X = v.X * f
    v.Y = v.Y * f
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;接口&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;type Abser interface {
    Abs() float64
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;类型通过实现一个接口的所有方法来实现该接口。既然无需专门显式声明，也就没有“implements”关键字。&lt;/p&gt;
&lt;p&gt;隐式接口从接口的实现中解耦了定义，这样接口的实现可以出现在任何包中，无需提前准备。&lt;/p&gt;
&lt;h4&gt;空接口&lt;/h4&gt;
&lt;p&gt;指定了零个方法的接口值被称为 &lt;em&gt;空接口：&lt;/em&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;interface{}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;空接口可保存任何类型的值。（因为每个类型都至少实现了零个方法。）&lt;/p&gt;
&lt;p&gt;空接口被用来处理未知类型的值。&lt;/p&gt;
&lt;h4&gt;类型断言&lt;/h4&gt;
&lt;p&gt;类型断言提供了访问接口值底层具体值的方式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t := i.(T)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若 &lt;code&gt;i&lt;/code&gt; 并未保存 &lt;code&gt;T&lt;/code&gt; 类型的值，该语句就会触发一个恐慌。&lt;/p&gt;
&lt;p&gt;为了判断一个接口值是否保存了一个特定的类型，类型断言可返回两个值：其底层值以及一个报告断言是否成功的布尔值。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;t, ok := i.(T)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;若 &lt;code&gt;i&lt;/code&gt; 保存了一个 &lt;code&gt;T&lt;/code&gt;，那么 &lt;code&gt;t&lt;/code&gt; 将会是其底层值，而 &lt;code&gt;ok&lt;/code&gt; 为 &lt;code&gt;true&lt;/code&gt;。&lt;/p&gt;
&lt;h4&gt;类型选择&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;switch v := i.(type) {
case T:
    // v 的类型为 T
case S:
    // v 的类型为 S
default:
    // 没有匹配，v 与 i 的类型相同
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;Stringer&lt;/h4&gt;
&lt;p&gt;同 ToString()&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Stringer interface {
    String() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;error&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;type error interface {
    Error() string
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;泛型&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;type Slice[T int|float32|float64 ] []T

type WowStruct[T int | float32, S []T] struct {
    Data     S
    MaxValue T
    MinValue T
}

type NewType[T interface{*int}] []T //通过 interface 消歧义
type NewType2[T interface{*int|*float64}] []T

func Add[T int | float32 | float64](a T, b T) T {
    return a + b
}
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;var a Slice[int] = []int{1, 2, 3}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;匿名结构体不支持泛型&lt;/p&gt;
&lt;h3&gt;接口组合&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;type Int interface {
    int | int8 | int16 | int32 | int64
}

type Uint interface {
    uint | uint8 | uint16 | uint32
}

type Float interface {
    float32 | float64
}

type Slice[T Int | Uint | Float] []T  // 使用 &apos;|&apos; 将多个接口类型组合
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;底层类型&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;~&lt;/code&gt; 标明&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Int interface {
    ~int | ~int8 | ~int16 | ~int32 | ~int64
}

type Uint interface {
    ~uint | ~uint8 | ~uint16 | ~uint32
}
type Float interface {
    ~float32 | ~float64
}

type Slice[T Int | Uint | Float] []T

type MyInt int
var s2 Slice[MyInt]  // MyInt 底层类型是 int，所以可以用于实例化

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;并发&lt;/h2&gt;
&lt;h3&gt;启动协程&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;package main
import &quot;fmt&quot;
func print(){
    for i := 0; i &amp;lt; 100; i++{
        fmt.Println(i)
    }
}
func main(){
    for i := 0; i &amp;lt; 10; i++{
        go print
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Channel&lt;/h3&gt;
&lt;p&gt;Channel 本身是并发安全的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main
func main(){
    ch = make(chan int)
    go func(){
        x &amp;lt;- ch
    }()
    x &amp;lt;- 3
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;带缓冲&lt;/h4&gt;
&lt;p&gt;如果 Channel 没用缓冲，那么在 Channel 放入数据后，下一次读取线，放入数据是堵塞的&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main
func main(){
    ch = make(chan int, 5)
    ch &amp;lt;- 1
    ch &amp;lt;- 2
    go func(){
        x &amp;lt;- ch
    }()
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;close&lt;/h4&gt;
&lt;p&gt;发送者可通过 &lt;code&gt;close&lt;/code&gt; 关闭一个信道来表示没有需要发送的值了。接收者可以通过为接收表达式分配第二个参数来测试信道是否被关闭：若没有值可以接收且信道已被关闭，那么在执行完&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;v, ok := &amp;lt;-ch
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;之后 &lt;code&gt;ok&lt;/code&gt; 会被设置为 &lt;code&gt;false&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;只有发送者才能关闭 Channel，关闭后将不可再发送数据。Channel 一般情况下不需要关闭&lt;/p&gt;
&lt;h4&gt;range&lt;/h4&gt;
&lt;p&gt;循环 &lt;code&gt;for i := range c&lt;/code&gt; 会不断从信道接收值，直到它被关闭。&lt;/p&gt;
&lt;h3&gt;select&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt; 语句使一个 Go 程可以等待多个通信操作。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;select&lt;/code&gt; 会阻塞到某个分支可以继续执行为止，这时就会执行该分支。当多个分支都准备好时会随机选择一个执行。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;select&lt;/code&gt; 中的其它分支都没有准备好时，&lt;code&gt;default&lt;/code&gt; 分支就会执行。为了在尝试发送或者接收时不发生阻塞，可使用 &lt;code&gt;default&lt;/code&gt; 分支：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func fibonacci(c, quit chan int) {
    x, y := 0, 1
    for {
        select {
        case c &amp;lt;- x:
            x, y = y, x+y
        case &amp;lt;-quit:
            fmt.Println(&quot;quit&quot;)
            return
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h3&gt;Mutex&lt;/h3&gt;
&lt;p&gt;Go 标准库中提供了 &lt;a href=&quot;https://go-zh.org/pkg/sync/#Mutex&quot;&gt;&lt;code&gt;sync.Mutex&lt;/code&gt;&lt;/a&gt; 互斥锁类型及其两个方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;Lock&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Unlock&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;WaitGroup&lt;/h3&gt;
&lt;p&gt;WaitGroup 可以通过&lt;code&gt;Add(int)&lt;/code&gt; 的方式添加任务，在所有任务调用 &lt;code&gt;Done()&lt;/code&gt;之前，调用 &lt;code&gt;Wait()&lt;/code&gt; 函数都会导致堵塞&lt;/p&gt;
&lt;h2&gt;依赖管理&lt;/h2&gt;
&lt;p&gt;目标：不同环境项目的依赖库版本不同，需要控制依赖库的版本&lt;/p&gt;
&lt;h3&gt;$GOPATH （过时）&lt;/h3&gt;
&lt;p&gt;即环境变量 &lt;code&gt;$GOPATH&lt;/code&gt;。 在该情况下项目将直接依赖 &lt;code&gt;$GOPATH/src&lt;/code&gt; 下的代码&lt;/p&gt;
&lt;p&gt;在该 &lt;code&gt;PATH&lt;/code&gt; 下的文件结构如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2023-09-08-09-41-01-image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;其中项目代码和项目依赖代代码都将存放在 &lt;code&gt;$GOPATH/src&lt;/code&gt; 目录下&lt;/p&gt;
&lt;p&gt;通过 &lt;code&gt;go get&lt;/code&gt; 可以将最新版本的依赖代码下载到 &lt;code&gt;src&lt;/code&gt; 下&lt;/p&gt;
&lt;h4&gt;缺点&lt;/h4&gt;
&lt;p&gt;无法实现多版本控制，即出现项目A和项目B分别依赖Pkg的不同版本时无法进行控制，即使这两个项目毫无关系&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2023-09-08-09-46-51-image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Vendor （过时）&lt;/h3&gt;
&lt;p&gt;在项目目录下增加 &lt;code&gt;vendor&lt;/code&gt; 文件夹，所有的依赖包以&lt;code&gt;源码&lt;/code&gt;副本的形式存储在 &lt;code&gt;vendor&lt;/code&gt;下。通过为每个项目引入一份依赖的副本，解决了多个项目需要同一个 package 不同版本依赖的冲突问题&lt;/p&gt;
&lt;p&gt;编译器在 solve deps 时会首先寻找 &lt;code&gt;vendor&lt;/code&gt; 目录，在不存在的情况下再去查找 &lt;code&gt;$GOPATH&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;缺点&lt;/h4&gt;
&lt;p&gt;由于本质上仍是依赖源码，在存储源码副本时如果项目依赖同一个包的不同的版本号，仍然可能会导致编译出错&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2023-09-08-10-27-28-image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;Go Module&lt;/h3&gt;
&lt;p&gt;自 1.16 版本开始默认开启&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;go.mod&lt;/code&gt; 文件管理依赖包&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;通过 &lt;code&gt;go get/go mod&lt;/code&gt; 指令工具管理依赖包&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;go.mod&lt;/code&gt; 文件并不是在项目中唯一。如果一个包需要被单独引用，它就应该创建一个 &lt;code&gt;go.mod&lt;/code&gt; 文件。其内容如下&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;module example/project/app

go 1.16

require(
    example/lib1 v1.0.2
    example/lib2 v1.0.0 // indirect

    example/lib/lib3/v3 v3.0.2
    example/lib/lib4 v3.0.2+incompatible
)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对于 require 中的内容应该包含包路径和版本号&lt;/p&gt;
&lt;p&gt;如果版本号的 MARJOR 大于等于2，那么路径中应该增加&lt;code&gt;/vN&lt;/code&gt;后缀&lt;/p&gt;
&lt;p&gt;如果没有 &lt;code&gt;go.mod&lt;/code&gt; 文件且 MARJOR 大于等于2，则需要标记为 &lt;code&gt;+incompatible&lt;/code&gt;&lt;/p&gt;
&lt;h4&gt;版本号&lt;/h4&gt;
&lt;p&gt;版本号可以有两种填写方式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语义化版本： &lt;strong&gt;${MARJOR}.${MINOR}.${PATCH}&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;基于 commit ：&lt;strong&gt;vx.0.0-yyyymmddhhmmss-c38fb59326b7&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;基与 commit 的版本号在每次提交时都会自动生成版本号&lt;/p&gt;
&lt;h4&gt;直接依赖/间接依赖&lt;/h4&gt;
&lt;p&gt;如果不是直接依赖的包，GO 语言会通过 &lt;code&gt;// indirect&lt;/code&gt; 标记为间接依赖&lt;/p&gt;
&lt;h4&gt;依赖选择规则&lt;/h4&gt;
&lt;p&gt;GO 语言会选择满足项目要求的最低的兼容版本&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2023-09-08-11-12-19-image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如图，最终编译时选择的 C 版本将为 1.4。以为 C1.3和C1.4的MARJOR版本相同，认为这两个版本兼容&lt;/p&gt;
&lt;h4&gt;依赖分发&lt;/h4&gt;
&lt;p&gt;GO 语言的依赖并不是从 GitHub 等站点直接下载，而是采用了一种类似适配器模式的设计&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2023-09-08-11-20-09-image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;对 Proxy 的选择可以设置 &lt;code&gt;GOPROXY&lt;/code&gt; 环境变量，本质是URL列表，以逗号分隔。其中 &lt;code&gt;direct&lt;/code&gt; 表示源站（Github,SVN 等）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export GOPROXY=&quot;https://proxy1.cn, https://proxy2.cn, proxy&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在查找时会依次从第一项开始查询&lt;/p&gt;
&lt;h4&gt;go mod 工具&lt;/h4&gt;
&lt;p&gt;&lt;img src=&quot;2023-09-08-11-24-08-image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2023-09-08-11-25-31-image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;h2&gt;单元测试&lt;/h2&gt;
&lt;p&gt;测试文件以 &lt;code&gt;_test.go&lt;/code&gt; 结尾，函数声明类似 &lt;code&gt;func TestABC(*testing.T)&lt;/code&gt;。对于所有测试的资源初始化和释放放在 &lt;code&gt;TestMain&lt;/code&gt; 中&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import &quot;githhub.com/stretchr/testify/assert&quot;

func TestMain(m *testing.M){
    // load resource
    code := m.Run()
    // release resource
    os.Exit(code)
}

func TestFeatureA(t *testing.T){
    t.Errorf(&quot;Expected %s dot not match actual %s&quot;, expectOutput, output)
    // 或者使用一些开源 assert 库
    assert.Equal(t, expectOutput, output)
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过 &lt;code&gt;go test [flag] [package]&lt;/code&gt; 可以执行所有单元测试&lt;/p&gt;
&lt;p&gt;覆盖率可通过提供 &lt;code&gt;--cover&lt;/code&gt; flag 计算&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go test
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;基准测试&lt;/h2&gt;
&lt;pre&gt;&lt;code&gt;func BenchmarkSelect(b *testing.B){
    // load resource
    b.ResetTimer() // 重置定时器重新计时（因为加载资源可能会消耗时间）
    for i:= 0; i &amp;lt; b.N; i++{
        Select()
    }
}

// 并行基准测试
func BenchmarkSelectParallel(b *testing.B){
    b.ResetTimer()
    b.RunParallel(func(pb *testing.PB) {
        for pb.Next() {
            Select()
        }
    })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;运行方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;$ go test -bench=.
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Go</category><author>Mslxl</author></item><item><title>Pinely Round 2 (Div. 1 + Div. 2) A-E</title><link>https://blog.mslxl.com/posts/cp/cf1863/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/cf1863/</guid><pubDate>Thu, 31 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;A. Channel&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有 $n$ 个人订阅了一个频道，当前在线 $a$ 人，收到了 $q$ 个上/下线通知&lt;/p&gt;
&lt;p&gt;上下线通知不包含上线的用户信息。在最开始的时候 Petya 发了一个视频，请判断是否所有的订阅用户都能看到这个视频&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;模拟&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果所有的人在同一时刻在线，那么所有用户都能看到&lt;/p&gt;
&lt;p&gt;如果在线人数和收到上线通知的次数和大于等于 $n$，则可能都能看见&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int n, a, q;
  read(n, a, q);
  std::string s;
  std::cin &amp;gt;&amp;gt; s;
  if(a == n){
    std::cout &amp;lt;&amp;lt; &quot;YES&quot;;
    return;
  }
  int online = a;
  for(int i = 0; i &amp;lt; q; i++){
    if(s[i] == &apos;+&apos;){
      online++;
    }else{
      online--;
    }
    if(online == n){
      std::cout &amp;lt;&amp;lt; &quot;YES&quot;;
      return;
    }
  }
  int pos = std::count(all(s), &apos;+&apos;);
  if(pos + a &amp;gt;= n){
    std::cout &amp;lt;&amp;lt; &quot;MAYBE&quot;;
    return;
  }
  std::cout &amp;lt;&amp;lt; &quot;NO&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Split Sort&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有 $n$ 个数组成一个排列 $p$，现在要通过特定操作进行排序&lt;/p&gt;
&lt;p&gt;每次只能选择一个数 $x \in p$，并将小于 $x$ 的数按照原来的相对顺序放在前面，大于等于原来的放在后面&lt;/p&gt;
&lt;p&gt;输出最小操作次数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;从小到大&lt;/strong&gt;选择数字$a_i$，如果$a_i &amp;gt; a_j$，且 $i &amp;lt; j$ ，则需要令 $x = a_i$ 进行操作&lt;/p&gt;
&lt;p&gt;用 $O(n)$ 的操作从头到尾扫一遍，即可获得答案&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
    int n;
    read(n);
    V&amp;lt;int&amp;gt; s(n+1);
    rep(i, n){
        int v;
        read(v);
        s[v] = i;
    }
    int ans = 0;
    for(int i = 2; i &amp;lt;= n; i++){
        ans += (s[i] &amp;lt; s[i-1]);
    }
     std::cout &amp;lt;&amp;lt; ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Mex Repetition&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给出一个序列 $a$，序列中的元素两两互不相同&lt;/p&gt;
&lt;p&gt;定义某操作为：从头到尾依次选择序列中的 $a_i$ ，并将 $a_i$ 替换为 $MEX(a_1, a_2, \ldots, a_n)$&lt;/p&gt;
&lt;p&gt;将这个操作重复 $k$ 次，输出最终结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;MEX&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;玩过博弈论SG函数的应该都见过这个规律&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;将 MEX 的结果放到序列结尾，那么每次操作都是对序列的旋转操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int mex(const V&amp;lt;int&amp;gt;&amp;amp; v){
  std::set&amp;lt;int&amp;gt; vis(all(v));
  for(int i = 0; ;i++){
    if(!vis.count(i)) return i;
  }
}
void solve() {
  int n, k;
  read(n, k);
  k %= (n+1);
  V&amp;lt;int&amp;gt; s(n);
  reads(all(s));
  s.pb(mex(s));
  std::rotate(s.begin(), s.begin()+(n-k)+1, s.end());
  rep(i, n){
    std::cout &amp;lt;&amp;lt; s[i] &amp;lt;&amp;lt; &quot; &quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. Two-Colored Dominoes&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有 $n\times m$ 大小的一个单元格组成的板子，在板子上有一些牌，每个牌覆盖两个相邻的单元格，并且没有牌重叠&lt;/p&gt;
&lt;p&gt;对所有的牌进行上色，要求满足：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;对于所有的牌，它所在的一个单元格被涂为黑色，另一个涂为白色&lt;/li&gt;
&lt;li&gt;每一行中黑色单元格个个数等于白色的个数&lt;/li&gt;
&lt;li&gt;每一列中黑色的个数等于白色的个数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出涂色方案，或者输出不可能(&lt;code&gt;-1&lt;/code&gt;)&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;构造&lt;/code&gt; &lt;code&gt;贪心&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果牌是横着放的，那么这一行中黑色和白色的个数都会+1，只需要考虑竖着的排的上色方案&lt;/p&gt;
&lt;p&gt;首先扫描每一行的U的数量，并为其分配颜色，在分配颜色时给下一行对应的 D 也分配一个相反的颜色&lt;/p&gt;
&lt;p&gt;然后看第二行，先统计出这一行中的 D 的颜色，然后再次分配 U 的颜色和下一行 D 的颜色，重复此过程&lt;/p&gt;
&lt;p&gt;对所有行都操作结束后，再对每一列也进行相同的操作&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
  V&amp;lt;std::string&amp;gt; mp(n);
  for (auto &amp;amp;s : mp) cin &amp;gt;&amp;gt; s;
  V&amp;lt;i64&amp;gt; row(n), col(m);
  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; m; j++) {
      if (mp[i][j] == &apos;L&apos;) {
        col[j]++;
      }
      if (mp[i][j] == &apos;U&apos;) {
        row[i]++;
      }
    }
  }
  bool pos = true;
  for (auto &amp;amp;i : row) {
    if (i &amp;amp; 1) pos = false;
    i /= 2;
  }
  for (auto &amp;amp;i : col) {
    if (i &amp;amp; 1) pos = false;
    i /=2;
  }
  if (!pos) {
    cout &amp;lt;&amp;lt; &quot;-1\n&quot;;
    return;
  }
  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; m; j++) {
      if (mp[i][j] == &apos;L&apos;) {
        if (col[j]) {
          mp[i][j] = &apos;W&apos;;
          mp[i][j + 1] = &apos;B&apos;;
          col[j]--;
        } else {
          mp[i][j] = &apos;B&apos;;
          mp[i][j + 1] = &apos;W&apos;;
        }
      }
      else if (mp[i][j] == &apos;U&apos;) {
        if (row[i]) {
          mp[i][j] = &apos;W&apos;;
          mp[i + 1][j] = &apos;B&apos;;
          row[i]--;
        } else {
          mp[i][j] = &apos;B&apos;;
          mp[i + 1][j] = &apos;W&apos;;
        }
      }
    }
  }
  for (auto s : mp) cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;E. Speed Run&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;一个游戏日有 $k$ 小时，当一天过去后，另一天马上开始。现在有 $n$ 个任务，每个任务必须在游戏日的第 $h_j$ 小时才能完成。同时任务之间有依赖关系，若要完成任务 $b_i$，则必须先完成任务 $a_i$。&lt;/p&gt;
&lt;p&gt;保证任务之间没有环状依赖，且任务完成不需要时间（即使两个任务之间存在依赖关系）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;拓扑排序&lt;/code&gt; &lt;code&gt;线性DP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先看到题目考虑搜索，由于任务之间存在依赖关系，单纯的搜索需要确定任务的完成顺序，可以先对其进行拓扑排序。拓扑排序后即可以拿到合法的任务执行顺序&lt;/p&gt;
&lt;p&gt;但是由于这个执行顺序是一个线性结构，如果写搜索的话不如DP递推实现难度低，于是考虑DP的写法。&lt;/p&gt;
&lt;p&gt;易得完成第 $i$ 个任务所需要的时间为 $f[i] = \max_{j\in dep[i]}(f[i], f[j] + (h[i] - h[j] + k) %k )$&lt;/p&gt;
&lt;p&gt;接下来枚举开始第一个任务，但由于我们统计的 $f[i]$ 表示从任务 $i$ 开始完成后续所有任务所需的时间，他们的起点不一致，直接比较很困难，因此我们可以将将 $f[i] + h[i]$，让起点为每天的起点。&lt;/p&gt;
&lt;p&gt;枚举任务$i$为起点所用的时间时，如果$i$ 之前的任务完成时刻比$i$要小，那么 $i$ 之前的任务必须放到 $i$ 之后的一天完成，完成用时增加了1天时间($k$ 小时)。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int maxn = 2e5 + 17;
struct Edge {
  int to, next;
} e[maxn];
int head[maxn], eid = -1;
int inde[maxn];
int h[maxn];
V&amp;lt;int&amp;gt; topo_seq;
void clear() {
  // std::memset(head, -1, sizeof(head));
  eid = -1;
  // std::memset(inde, 0, sizeof(inde));
  // topo_seq.clear();
}
void add_edge(int u, int v) {
  eid++;
  e[eid].to = v;
  e[eid].next = head[u];
  head[u] = eid;
  inde[v]++;
}

void solve() {
  clear();
  int n, m, k;
  read(n, m, k);
  rep(i, n) read(h[i]);
  std::memset(head, -1, sizeof(int) * n);
  std::memset(inde, 0, sizeof(int) * n);
  rep(i, m) {
    int u, v;
    read(u, v);
    u--, v--;
    add_edge(u, v);
  }

  std::queue&amp;lt;int&amp;gt; q;
  rep(i, n) if (inde[i] == 0) { q.push(i); }
  topo_seq.clear();
  topo_seq.reserve(n);
  while (!q.empty()) {
    topo_seq.push_back(q.front());
    auto u = q.front();
    q.pop();

    for (int i = head[u]; ~i; i = e[i].next) {
      const int v = e[i].to;
      inde[v]--;
      if (inde[v] == 0) {
        q.push(v);
      }
    }
  }

  V&amp;lt;int&amp;gt; f(n);
  for (int i = n - 1; i &amp;gt;= 0; i--) {
    int x = topo_seq[i];
    for (int eid = head[x]; ~eid; eid = e[eid].next) {
      const int v = e[eid].to;
      f[x] = mmax(f[x], f[v] + (h[v] - h[x] + k) % k);
    }
  }

  for (int i = 0; i &amp;lt; n; i++) {
    f[i] += h[i];
  }

  int ans = maxnum(int);
  int res = *std::max_element(all(f));

  V&amp;lt;int&amp;gt; p(n);
  std::iota(all(p), 0);
  std::sort(all(p), [&amp;amp;](const int l, const int r){
      return h[l] &amp;lt; h[r];
  });

  debug(p);
  for(auto i: p){
    ans = mmin(ans, res - h[i]);
    res = mmax(res, f[i] + k);
  }
  std::cout &amp;lt;&amp;lt; ans;

}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Codeforces</category><category>Competitive Programming</category><author>Mslxl</author></item><item><title>Game tag 板刷网瘾记录</title><link>https://blog.mslxl.com/posts/cp/games-logs1/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/games-logs1/</guid><pubDate>Wed, 30 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;CF1844A. Subtraction Game&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入两个数组 $a,b$&lt;/p&gt;
&lt;p&gt;两个玩家将一摞$n$个石子堆上进行游戏，玩家一轮可以从石堆中移除 $a$ 个石子或 $b$ 个石子，不能行动的玩家输。&lt;/p&gt;
&lt;p&gt;寻找石子堆的石子数量 $n$，使得无论第一个玩家如何行动，第二个玩家总能获胜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;*800&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;只要一共有 $a+b$ 个石子，那么先手必输&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  i32 a, b;
  read(a, b);
  std::cout &amp;lt;&amp;lt; a+b;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;CF1842A. Tenzing and Tsondu&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Tsondu 和 Tenzing 正在玩纸牌游戏。Tsondu 有 $n$ 个能量为 $a_1, a_2, \ldots,a_n$ 怪物，Tenzing 有 $m$ 个能量为 $b_1, b_2, \ldots, b_m$的怪物&lt;/p&gt;
&lt;p&gt;Tsondu 和 Tenzing 轮流行动，Tsondu 先手。当能量为 $x$ 的怪物选择攻击能量为 $y$ 的怪物时，两个怪物的能量变为 $x-y$和$y-x$，当能量小于 0 时怪物死亡&lt;/p&gt;
&lt;p&gt;怪物全部死亡的一方输。问 Tsondu 和 Tenzing 在最优决策下谁获胜（或平局）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;*800&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;考虑攻击时存在怪物死亡时会出现伤害溢出的情况，x和y的变化等价于 $x - \min(x,y)$， $y - min(x,y)$&lt;/p&gt;
&lt;p&gt;所以只需要比较 $\sum a$ 和 $\sum b$ 即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int n, m;
  read(n, m);
  std::vector&amp;lt;int&amp;gt; a(n), b(m);
  reads(all(a)); reads(all(b));

  int sa = std::accumulate(all(a), 0LL);
  int sb = std::accumulate(all(b), 0LL);

  if(sa &amp;gt; sb) std::cout &amp;lt;&amp;lt; &quot;Tsondu&quot;;
  else if(sa &amp;lt; sb) std::cout &amp;lt;&amp;lt; &quot;Tenzing&quot;;
  else std::cout &amp;lt;&amp;lt; &quot;Draw&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;CF1841A. Game with Board&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;黑板上有 $n$ 个数字 $1$，Alice 和 Bob 轮流从黑板上选择大于等于 $2$ 个元素进行合并（相加）&lt;/p&gt;
&lt;p&gt;Alice 先手，双方轮流行动，不能行动的人输。假设两人行动最优，输出最终谁获胜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;*800&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当数量小于等于 $4$ 时，无论 Alice 如何行动， Bob 总能获胜&lt;/p&gt;
&lt;p&gt;当数量大于等于 $5$ 时， Alice 总可以选择 $n-2$ 个元素合并，使 Bob 选择剩下的 $2$ 个元素。Alice 总能获胜&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Control.Monad

calc :: Int -&amp;gt; String
calc x | x &amp;lt; 5 = &quot;Bob&quot;
       | otherwise = &quot;Alice&quot;

main :: IO()
main = (read &amp;lt;$&amp;gt; getLine) &amp;gt;&amp;gt;= ((flip replicateM_) solve)
  where
    solve = (calc . read &amp;lt;$&amp;gt; getLine) &amp;gt;&amp;gt;= putStrLn
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;CF1834C. Game with Revesing&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Alice 和 Bob 正在玩游戏，他们共有两个长度为 $n$ 的由小写字母组成的字符串 $S$ 和 $T$。Alice 和 Bob 轮流行动。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Alice 每回合选择 $i \in [1,n]$ 和一个字符串 $S$ 或 $T$ 和一个小写字母 $c$，并将选择的字符串中第 $i$ 个符号替换成 $c$&lt;/li&gt;
&lt;li&gt;Bob 选择一个字符串 $S$ 或 $T$，并将其反转&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;游戏将进行到 $S = T$为止。&lt;/p&gt;
&lt;p&gt;定义游戏的持续时间为 Alice 和 Bob 行动的总次数。Alice 想最小化游戏时间，但 Bob 要最大化时间。当双方都最优行动时，游戏将在多少回合后结束&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;*1200&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;对于 Bob而言，他的反转操作几乎无用，无论反转谁反转两次操作都等于没有反转，而 Alice 可以将 c 变为 c 来跳过1回合来让 Bob 使字符串反转&lt;/p&gt;
&lt;p&gt;分别统计在开始反转和没反转下 Alice 需要操作的次数（即 Alice 第一回合是否跳过），最后算出操作次数取 min 即可。&lt;/p&gt;
&lt;p&gt;如果 Alice 第一回合没有跳过，那么游戏一共进行了 $cnt + cnt - (cnt \mod 2)$ 次&lt;/p&gt;
&lt;p&gt;如果跳过了第一回合，那么一共进行了 $cnt + cnt - (1 - cnt \mod 2)$（加上跳过一回合的操作）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int n;
  std::cin &amp;gt;&amp;gt; n;
  std::string s, t1, t2;
  std::cin &amp;gt;&amp;gt; s &amp;gt;&amp;gt; t1;
  t2 = t1;
  std::reverse(all(t2));
  if (s == t1) {
    std::cout &amp;lt;&amp;lt; 0;
    return;
  } else if (s == t2) {
    std::cout &amp;lt;&amp;lt; 2;
    return;
  }
  int diff1 = 0, diff2 = 0;
  for (int i = 0; i &amp;lt; n; i++) {
    diff1 += s[i] != t1[i];
    diff2 += s[i] != t2[i];
  }

  std::cout &amp;lt;&amp;lt; std::min(diff1 * 2 - diff1 % 2, diff2 * 2 - (diff2 % 2 == 0));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;CF768E. Game of Stones&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Sam 教 Jon 打游戏。游戏规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;游戏从 $n$ 推石子堆开始，编号 $1$ 到 $n$。第 $i$ 堆石子包含 $s_i$ 个石子&lt;/li&gt;
&lt;li&gt;玩家轮流行动。每次行动必须从石子中移除到一些石子($&amp;gt;0$)&lt;/li&gt;
&lt;li&gt;不能行动的人输&lt;/li&gt;
&lt;li&gt;在每堆石子上移除的石子数量不能重复&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Sam 先手。请判断如果双方都最优决策，Jon 是否可以获胜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;SG&lt;/code&gt; &lt;code&gt;Nim-Game&lt;/code&gt; &lt;code&gt;*2100&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;SG 函数为 &lt;code&gt;0 1 1 2 2 2 3 3 3 3...&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;鉴定为找规律后组合游戏求和&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;import Data.Bits
import Control.Monad

mex:: Integer -&amp;gt; Integer
mex 0 = 0
mex x = iter x 1 2 1
    where
        iter i l r row | l &amp;lt;= i &amp;amp;&amp;amp; i &amp;lt;= r = row
                       | otherwise = iter i (r + 1) (r + 2 + (r - l)) (row + 1)

solve:: [Integer] -&amp;gt; Bool
solve = (==) 0 . foldl1 xor . map mex

main = do
    n &amp;lt;- read &amp;lt;$&amp;gt; getLine
    nums &amp;lt;- replicateM n (read &amp;lt;$&amp;gt; getLine)
    answer $ solve nums
    where
        answer True = putStrLn &quot;YES&quot;
        answer False = putStrLn &quot;NO&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另外 &lt;a href=&quot;https://github.com/LionelMessiYoung10&quot;&gt;LionelMessiYoung10&lt;/a&gt;指出&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2023-08-31-00-25-14-image.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

int main(){
  std::cin.tie(0)-&amp;gt;sync_with_stdio(false);
  int n;
  std::cin &amp;gt;&amp;gt; n;
  int sg = 0;
  for(int i = 0; i &amp;lt; n; i++){
    int x;
    std::cin &amp;gt;&amp;gt; x;
    for(int j = 1; ; j++){
      x -= j;
      if(x - (j+1) &amp;lt; 0){
        sg ^= j;
        break;
      }
    }
  }
  if(sg == 0){
    std::cout &amp;lt;&amp;lt; &quot;YES&quot;;
  }else{
    std::cout &amp;lt;&amp;lt; &quot;NO&quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;CF197A. Plate Games&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;两个玩家在一个长 $a$ 宽 $b$ 的桌子上轮流摆放半径为 $r$ 的盘子。盘子之间不能重叠，不能超过桌子边界。不能行动的人输&lt;/p&gt;
&lt;p&gt;回答先手获胜或者后手获胜&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;对称博弈&lt;/code&gt; &lt;code&gt;*1600&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当先手能放置盘子时放在中间，后手无论选择哪个位置，下一次行动先手总能在对称位置放置盘子，直到后手不能放置&lt;/p&gt;
&lt;p&gt;即当先手能行动时，先手必胜&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;main :: IO()
main = do
  [a, b, r] &amp;lt;- map read &amp;lt;$&amp;gt; words &amp;lt;$&amp;gt; getLne
  if 2 * r &amp;gt; min a b
  then putStr &quot;Second&quot;
  else putStr &quot;First&quot;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;ACM-ICPC 2017 Asia Nanning Rake It In&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;对抗搜索&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;注意到 $1 \le k \le 3$ ，直接暴搜&lt;/p&gt;
&lt;p&gt;要卡常，注意常数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int k;

  V&amp;lt;V&amp;lt;int&amp;gt;&amp;gt; m(4, V&amp;lt;int&amp;gt;(4));
  auto query = [&amp;amp;m](int i, int j) -&amp;gt; int {
    assert(i &amp;lt; 4 &amp;amp;&amp;amp; j &amp;lt; 4);
    return m[i][j] + m[i + 1][j] + m[i][j + 1] + m[i + 1][j + 1];
  };

  auto fwd = [&amp;amp;m](int i, int j) {
    assert(i &amp;lt; 3 &amp;amp;&amp;amp; j &amp;lt; 3);
    int tmp =m[i][j];
    m[i][j] = m[i][j+1];
    m[i][j+1] = m[i + 1][j + 1];
    m[i + 1][j + 1] = m[i+1][j];
    m[i+1][j] = tmp;
  };

  auto bck = [&amp;amp;m](int i, int j){
    int tmp = m[i][j];
    m[i][j] = m[i+1][j];
    m[i+1][j] = m[i+1][j+1];
    m[i+1][j+1] = m[i][j+1];
    m[i][j+1] = tmp;
  };

  std::function&amp;lt;int(int)&amp;gt; dfs =
      [&amp;amp;](int cnt) -&amp;gt; int {
    if (cnt &amp;gt; 2 * k) return 0;
    if (cnt % 2 == 1) {
      // Alice
      int ans = 0;
      rep(i, 3) {
        rep(j, 3) {
          fwd(i, j);
          ans = mmax(ans, query(i, j) + dfs(cnt + 1));
          bck(i, j);
        }
      }
      return ans;
    } else {
      // Bob
      int ans = maxnum(int);
      rep(i, 3) {
        rep(j, 3) {
          fwd(i, j);
          ans = mmin(ans, query(i, j) + dfs(cnt + 1));
          bck(i, j);
        }
      }
      return ans;
    }
  };

  read(k);
  rep(i, 4) {
    rep(j, 4) { read(m[i][j]); }
  }
  std::cout &amp;lt;&amp;lt; dfs(1);
}

&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>Codeforces</category><author>Mslxl</author></item><item><title>Harbour.Space Scholarship Contest 2023-2024 (Div. 1 + Div. 2) A-E 二进制拆分 组合数学</title><link>https://blog.mslxl.com/posts/cp/cf1864/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/cf1864/</guid><pubDate>Sun, 27 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;A.Increasing and Decreasing&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;制造一个序列，序列从 $x$ 开始，到 $y$ 结束，一共 $n$ 个数。满足&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;序列是严格递增的&lt;/li&gt;
&lt;li&gt;序列相邻两项的值是严格递减的&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;构造&lt;/code&gt; &lt;code&gt;*579&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;直接从 $y$ 开始构造一个倒序构造一个递减序列，使每次减少的值在不重复的情况下尽可能小&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve(){
    int x, y, n;
    read(x, y, n);

    std::vector&amp;lt;int&amp;gt; d(n);
    d[n-1] = y;
    for(int i = 2; i &amp;lt;= d.size(); i++){
        d[d.size() - i] = d[d.size() - i + 1] - (i - 1);
    }
    if(x &amp;gt; d[0]){
        std::cout &amp;lt;&amp;lt; -1;
        return;
    }
    std::cout &amp;lt;&amp;lt; x;
    for(int i = 1; i &amp;lt; n; i++) std::cout &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; d[i];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Swap and Reverse&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个长度为 $n$ 的字符串 $s$，可以进行以下任一操作无限次:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;交换相隔一位的字符，即交换 $s_i$ 和 $s_{i+2}$ 的字符&lt;/li&gt;
&lt;li&gt;反转一段长度为 $k$ 的区间&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;输出通过上述操作所能获得的最小字典序的字符串&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt; &lt;code&gt;*1067&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果只考虑操作 1，那么我们可以将字符串的奇数位和偶数位上字符分别排序&lt;/p&gt;
&lt;p&gt;如果使整个字符串的字典序最小，只需要判断能否将奇数位上的字符和偶数位上的自符交换位置即可。&lt;/p&gt;
&lt;p&gt;判断 $k$ 的奇偶性，当 $k$ 为奇数时无法通过反转来将奇数位上的字符和偶数位上的自符交换位置，那么答案为对原字符串奇数位上的字符和偶数位上的字符分别排序。当 $k$ 为偶数时，将整个字符串进行排序即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
 int n, k;
 std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
 std::string line;
 std::cin &amp;gt;&amp;gt; line;

 if (k % 2 == 0) {
   std::sort(all(line));
   std::cout &amp;lt;&amp;lt; line;
 } else {
   std::string o, e;
   for (int i = 0; i &amp;lt; n; i++) {
     if (i % 2 == 0) o += line[i];
     else e += line[i];
   }
   std::sort(all(o));
   std::sort(all(e));
   for (int i = 0; i &amp;lt; n; i++) {
     if (i % 2 == 0) std::cout &amp;lt;&amp;lt; o[i / 2];
     else std::cout &amp;lt;&amp;lt; e[i / 2];
   }
 }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Divisor Chain&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给一个数 $x$，通过下列操作将 $x$ 变为 $1$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择一个数 $d$ 满足 $d$ 是 $x$ 的因数，令 $x = x - d$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意不能使用同一个 $d$ 多于两次&lt;/p&gt;
&lt;p&gt;输出操作中的中间过程&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;二进制拆分&lt;/code&gt; &lt;code&gt;*1294&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;开始对着最大质因数想了至少1小时&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;因为 x 的 lowbit 总是 x 的因数，且二进制中的每一位只需要操作一次，所以可以&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 $lowbit(x) \ne x$，令 $x \leftarrow x - lowbit(x)$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 $lowbit(x) = x$，令 $x \leftarrow x - \frac{x}{2}$，直到 $x = 1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;import Data.Bits
import Control.Monad

lowbit :: Integer -&amp;gt; Integer
lowbit x = (.&amp;amp;.) (-x) x

calc :: Integer -&amp;gt; [Integer]
calc 1 = [1]
calc x | lowbit x == x = x : (calc $ x `div` 2)
       | otherwise = x : (calc $ x - lowbit x)

solve x = (putStrLn $ show $ length ans) &amp;gt;&amp;gt; (putStrLn $ unwords $ map show $ calc x)
  where ans = calc x

main :: IO()
main = (read &amp;lt;$&amp;gt; getLine) &amp;gt;&amp;gt;= (flip replicateM_ $ ((read &amp;lt;$&amp;gt; getLine) &amp;gt;&amp;gt;= solve))
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. Matrix Cascade&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有一个大小为 $n \times m$ 的01矩阵。将矩阵中所有的元素变为 0。每次操作可以将 $(i, j)$ 和 $(x, y) \quad x &amp;gt; i, x - i \ge\mid y - j\mid$ 中的元素反转&lt;/p&gt;
&lt;p&gt;输入一个矩阵，问最小需要操作几次才能将矩阵变为全 $0$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;二维差分&lt;/code&gt; &lt;code&gt;1620&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果要反转某个位置，那么反转的区间就是从这个点开始向下的三角形&lt;/p&gt;
&lt;p&gt;最小操作次数的解肯定是唯一的，求解的重点在于如何快速去操作这个三角形&lt;/p&gt;
&lt;p&gt;记原来的矩阵是 $a[i][j]$，之前的操作对 $(i,j)$ 的影响为 $b[i][j]$&lt;/p&gt;
&lt;p&gt;遍历每个点 $(i,j)$，对每个点都需要判断：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果 $b[i][j] = 1$，则说明之前有个反转操作对 $(i, j)$ 有影响，需要将 $a[i][j]$ 进行反转&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果现在 $a[i][j] = 1$，则我们还说明需要进行一次反转 $ans \leftarrow ans + 1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;之后需要判断当前位置对之后的影响&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果当前位置 $(i,j)$ 存在影响（$d[i][j] = 1$）时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 $a[i][j] = 1$ 时，由于需要进行一次反转使 $a[i][j]=0$，因此也会使 $d[i][j]=0$&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当 $a[i][j] = 0$ 时，$d[i][j]$保持不边，仍为 $1$&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果当前位置 $(i,j)$ 不存在影响 ($d[i][j] = 0$) 时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 $a[i][j] = 1$时，由于需要进行一次反转使 $a[i][j] = 0$，因此 $d[i][j] = 1$&lt;/li&gt;
&lt;li&gt;当 $a[i][j] = 0$ 时， $d[i][j] = 0$ 保持不变&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很容易发现这可以通过 $d[i][j] \leftarrow d[i][j] \oplus a[i][j]$&lt;/p&gt;
&lt;p&gt;然后下传标记，当 $d[i][j] = 1$ 时需要下传标记。如果直接传递影响可能会难以统计，可以采用传递影响和直接操作两种方式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;D.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;因为只有影响向下传递，而操作并不会，这样简化了传递时的操作&lt;/p&gt;
&lt;p&gt;需要注意，像上图中橙色部分会被左右两个各传递一次，因此我们还需要再进行一次传递（黑色箭头），使$d[i+2][j]$变成奇数次操作&lt;/p&gt;
&lt;p&gt;另外像下图情况&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;D2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果有黑色箭头的传递，那么橙色部分被更新了 2 次，所以还需要判断如果当前 $(i,j)$ 位置，如果 $(i+1, j+1)$ 或者 $(i+1, j-1)$ 超过了边界，就不需要用黑色箭头对橙色块进行传递（或者再进行一次传递抵消掉）&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int n;
  read(n);
  V&amp;lt;V&amp;lt;int&amp;gt;&amp;gt; a(n + 1, V&amp;lt;int&amp;gt;(n + 1)), b(n + 1, V&amp;lt;int&amp;gt;(n + 1));
  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; n; j++) {
      char ch;
      std::cin &amp;gt;&amp;gt; ch;
      a[i][j] = ch - &apos;0&apos;;
    }
  }
  int ans = 0;
  for (int i = 0; i &amp;lt; n; i++) {
    for (int j = 0; j &amp;lt; n; j++) {
      a[i][j] ^= b[i][j];
      ans += a[i][j];
      b[i][j] ^= a[i][j];

      a[i][j] ^= b[i][j];
      if (i + 1 &amp;lt; n) {
        a[i + 1][j] ^= b[i][j];
        if (j - 1 &amp;gt;= 0) {
          b[i + 1][j - 1] ^= b[i][j];
        } else if (i + 2 &amp;lt; n) {
          b[i + 2][j] ^= b[i][j];
        }
        if (j + 1 &amp;lt; n) {
          b[i + 1][j + 1] ^= b[i][j];
        } else if (i + 2 &amp;lt; n) {
          b[i + 2][j] ^= b[i][j];
        }
        if (i + 2 &amp;lt; n) {
          b[i + 2][j] ^= b[i][j];
        }
      }
    }
  }
  std::cout &amp;lt;&amp;lt; ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;E. Guess Game&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Carol 有一个由非负整数组成的序列 $s$，她要和 Alice 和 Bob 玩 Guess Game&lt;/p&gt;
&lt;p&gt;在游戏中，Carol 将随机选两个下标 $i_a$ 和 $i_b$，并令 $a = s_{i_a}$, $b = s_{i_b}$，$i_a$ 和 $i_b$ 可能重合&lt;/p&gt;
&lt;p&gt;Carol 将：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;告诉 Alice $a$ 的值&lt;/li&gt;
&lt;li&gt;告诉 Bob $b$ 的值&lt;/li&gt;
&lt;li&gt;告诉 Alice 和 Bob $a \mid b$ 的值，其中 &lt;code&gt;|&lt;/code&gt;是位或运算&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Carol 不会告诉 Alice 和 Bob 任何有关 $s$ 的信息&lt;/p&gt;
&lt;p&gt;游戏开始后，Alice 和 Bob 轮流进行猜测。Alice 先手。他们的目标都是找到 $a &amp;lt; b, a &amp;gt; b$ 或 $a=b$ 公式哪个是正确的&lt;/p&gt;
&lt;p&gt;在每轮猜测中，每个玩家可以进行以下一种操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;回答 &lt;code&gt;不知道&lt;/code&gt;，然后下一个玩家继续游戏&lt;/li&gt;
&lt;li&gt;回答 &lt;code&gt;知道&lt;/code&gt;, 并给出游戏的答案(&lt;code&gt;a&amp;lt;b&lt;/code&gt;, &lt;code&gt;a&amp;gt;b&lt;/code&gt; 或者 &lt;code&gt;a=b&lt;/code&gt;)，游戏结束&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Alice 和 Bob 都能听到对方的回答，并根据回答作出自己的判断。Alice 和 Bob 足够聪明，且只会在完全确定答案的时候回答 &lt;code&gt;知道&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;要求计算游戏所进行回合数的期望值，输出答案对 &lt;code&gt;998244353&lt;/code&gt; 取模&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;*2113&lt;/code&gt; &lt;code&gt;二进制拆分&lt;/code&gt; &lt;code&gt;分治&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很奇妙的一道题&lt;/p&gt;
&lt;p&gt;先来看样例的几种情况&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$A$&lt;/th&gt;
&lt;th&gt;$A \mid B$&lt;/th&gt;
&lt;th&gt;$B$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IDK&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;A 的最高位是 $1$，B 的最高位也是 $1$。第二位小，所以 $A &amp;gt; B$&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;$A$&lt;/th&gt;
&lt;th&gt;$A \mid B$&lt;/th&gt;
&lt;th&gt;$B$&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;IDK&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;A 的最高位是 $1$，B 的最高位也是 $1$。B 的次高位仍是 $1$，不能判断大小关系, IDK&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B 的最高位和次高位都是 $1$，因此 $A=B$&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;也就是说如果先手具有最高位，它就无法判断大小关系（因为他无法判断对方最高位是否为 $1$），这时候先手回答 &lt;code&gt;不知道&lt;/code&gt;。后手如果这一位是 &lt;code&gt;0&lt;/code&gt;，则大小关系可判断。如果这一位是1，可以先把先手和后手的最高位都删掉，交换先后手重新判断。&lt;/p&gt;
&lt;p&gt;这样我们就获得一个 $O(\log 31)$ 的计算轮数的方式&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;unsigned int highbit(unsigned int x) { return (1u &amp;lt;&amp;lt; (31 - __builtin_clz(x))); }
int pk(int a, int b, int round = 1) {
  int x = a | b;
  if (a == 0) return round;
  if (highbit(a) != highbit(x)) return round;
  if (b == 0) return round + 1;
  if (highbit(b) != highbit(x)) return round + 1;
  return pk(b &amp;amp; (highbit(x) - 1), a &amp;amp; (highbit(x) - 1), round + 1);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;但是如果要判断一个序列中轮数的期望，仍然需要 $O(n^2)$ 次判断，对于这个题是数据范围来说是 Unacceptable 的，因此还需要从数据特征进一步分析&lt;/p&gt;
&lt;p&gt;因为轮数和两个数的高位有关，可以考虑将这个序列根据最高位的位置分为 31 ，同一组中最高位的位置相同。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;对于不同组之间选两个数，那么他们由于最高位不同，只需要 $2+1$ 轮即可结束（高位先手和低位先手）。对于所有元素来说就是 $(cnt[a] * (num - cnt[a])) * (2 + 1)$ 轮&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;对于同一组中选两个数，由于最高位相同，所以需要去掉最高位再进行判断。可以根据次高位的位置，重新将其分组，并计算选择不同组和同组的轮数进行相加，直到一组中全为 0&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;#pragma GCC optimize(2)
// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using i16 = short; using i32 = int; using i64 = long long; using u16= unsigned short; using u32 = unsigned int; using u64 = unsigned long long;using f32 = float; using f64 = double; using f128 = long double;
using pii = std::pair&amp;lt;i32, i32&amp;gt;; using pll = std::pair&amp;lt;i64, i64&amp;gt;; using pil = std::pair&amp;lt;i32, i64&amp;gt;; using pli = std::pair&amp;lt;i64, i32&amp;gt;;
template&amp;lt;class T&amp;gt; using V = std::vector&amp;lt;T&amp;gt;;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); } template &amp;lt;typename T&amp;gt; inline void reads(T begin, T end){ while(begin != end) { read(*begin); begin++; } }
void solve(); void init();
int TESTCASE = 1; int main() { init(); for(int i = 1; i &amp;lt;= TESTCASE; i++){ solve(); if(i != TESTCASE) std::cout &amp;lt;&amp;lt; &quot;\n&quot;; } return 0;}
template&amp;lt;class T&amp;gt; T fstTrue(T l, T r, std::function&amp;lt;bool(T)&amp;gt; check){ assert(l &amp;lt;= r); while(l &amp;lt; r){ T mid = l + (r - l) / 2; if(check(mid)) r = mid; else l = mid + 1; } return r; }
template&amp;lt;class T&amp;gt; T lstTrue(T l, T r, std::function&amp;lt;bool(T)&amp;gt; check){ assert(l &amp;lt;= r); while(l &amp;lt; r){ T mid = l + (r - l + 1)/2; if(check(mid)) l = mid; else r = mid - 1; } return l; }
template&amp;lt;class T&amp;gt; T gcd(T a, T b) { return std::__gcd(a, b); }
template&amp;lt;class T&amp;gt; T lcm(T a, T b) { return a / gcd(a, b) * b; };
template&amp;lt;const int T&amp;gt; struct MInt { const static int mod = T; int x; MInt(int x = 0) : x(x % mod) {} MInt(long long x) : x(int(x % mod)) {} int val() { return x; } MInt operator + (const MInt &amp;amp;a) const { int x0 = x + a.x; return MInt(x0 &amp;lt; mod ? x0 : x0 - mod); } MInt operator - (const MInt &amp;amp;a) const { int x0 = x - a.x; return MInt(x0 &amp;lt; 0 ? x0 + mod : x0); } MInt operator * (const MInt &amp;amp;a) const { return MInt(1LL * x * a.x % mod); } MInt operator / (const MInt &amp;amp;a) const { return *this * a.inv(); } bool operator == (const MInt &amp;amp;a) const { return x == a.x; }; bool operator != (const MInt &amp;amp;a) const { return x != a.x; }; void operator += (const MInt &amp;amp;a) { x += a.x; if (x &amp;gt;= mod) x -= mod; } void operator -= (const MInt &amp;amp;a) { x -= a.x; if (x &amp;lt; 0) x += mod; } void operator *= (const MInt &amp;amp;a) { x = 1LL * x * a.x % mod; } void operator /= (const MInt &amp;amp;a) { *this = *this / a; } friend MInt operator + (int y, const MInt &amp;amp;a){ int x0 = y + a.x; return MInt(x0 &amp;lt; mod ? x0 : x0 - mod); } friend MInt operator - (int y, const MInt &amp;amp;a){ int x0 = y - a.x; return MInt(x0 &amp;lt; 0 ? x0 + mod : x0); } friend MInt operator * (int y, const MInt &amp;amp;a){ return MInt(1LL * y * a.x % mod);} friend MInt operator / (int y, const MInt &amp;amp;a){ return MInt(y) / a;} friend std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const MInt &amp;amp;a) { return os &amp;lt;&amp;lt; a.x;} friend std::istream &amp;amp;operator&amp;gt;&amp;gt;(std::istream &amp;amp;is, MInt &amp;amp;t){return is &amp;gt;&amp;gt; t.x;} MInt pow(int64_t n) const { MInt res(1), mul(x); while(n){ if (n &amp;amp; 1) res *= mul; mul *= mul; n &amp;gt;&amp;gt;= 1; } return res; } MInt inv() const { int a = x, b = mod, u = 1, v = 0; while (b) { int t = a / b; a -= t * b; std::swap(a, b); u -= t * v; std::swap(u, v); } if (u &amp;lt; 0) u += mod; return u; } };
#define debug(...) debug_do std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)
#define maxnum(type) std::numeric_limits&amp;lt;type&amp;gt;::max()
#define minnum(type) std::numeric_limits&amp;lt;type&amp;gt;::min()
#define pb push_back
#define pf push_front
#define all(x) (x).begin(), (x).end()
#define rall(x) (x).rbegin(), (x).rend()
#define all1(x) ++(x).begin(), (x).end()
#define rall1(x) (x).rbegin(), --(x).rend()
#define rep(i, n) for(int i = 0; i &amp;lt; n; i++)
#define rep1(i, n) for(int i = 1; i &amp;lt;= n; i++)
template&amp;lt;class R, class A&amp;gt; R mmax(R x, A y){ return std::max(x, (R) y); } template&amp;lt;class R, class A, class... AS&amp;gt; R mmax(R x, A xx, AS... xxs){ return std::max(x, mmax((R)xx, xxs...));  }
template&amp;lt;class R, class A&amp;gt; R mmin(R x, A y){ return std::min(x, (R) y); } template&amp;lt;class R, class A, class... AS&amp;gt; R mmin(R x, A xx, AS... xxs){ return std::min(x, mmin((R)xx, xxs...));  }
using std::cout; using std::cin; using std::endl;
#define endl &quot;\n&quot;
// clang-format on

// using i128 = __int128;
void init() {
  read(TESTCASE);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr);
  // std::cout.tie(nullptr); std::cin &amp;gt;&amp;gt; TESTCASE;
}
using Z = MInt&amp;lt;998244353&amp;gt;;
void solve() {
  int n;
  read(n);
  V&amp;lt;int&amp;gt; s(n);
  reads(all(s));
  auto highpos = [](unsigned x) {
    if (x == 0) return 0;
    return 32 - __builtin_clz(x);
  };
  auto highbit = [&amp;amp;highpos](unsigned x) {
    if (x == 0) return x;
    return 1u &amp;lt;&amp;lt; (highpos(x) - 1);
  };

  std::function&amp;lt;Z(V&amp;lt;int&amp;gt; &amp;amp;, int)&amp;gt; divide = [&amp;amp;](V&amp;lt;int&amp;gt; &amp;amp;seq, int round) {
    std::array&amp;lt;V&amp;lt;int&amp;gt;, 32&amp;gt; group;
    int num = seq.size();
    Z ans = 0;
    debug(seq);
    for (auto i : seq) {
      group[highpos(i)].pb(i);
    }

    for (int i = 0; i &amp;lt; 32; i++) {
      auto g = group[i];
      if (g.size() == 0) continue;

      ans += (int)(g.size() * (num - g.size())) *
             (2 * round + 1);  // 不同组之间选数

      if (i != 0) {
        for (auto &amp;amp;b : g) b -= highbit(b);  // 同组间选数，删除最高位
        ans += divide(g, round + 1);
      } else {
        // 一组中全是 0 了，组内选数直接是 1 轮结束

        ans += (int)(g.size() * g.size() * (1 * round));
      }

      num -= g.size(); // 防止选重复，组间选数只选择当前组和该组之后的组
    }
    return ans;
  };

  std::cout &amp;lt;&amp;lt; (divide(s, 1) / n / n);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>Codeforces</category><author>Mslxl</author></item><item><title>Codeforces Round 894 (Div. 3) A-G</title><link>https://blog.mslxl.com/posts/cp/cf1862/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/cf1862/</guid><pubDate>Fri, 25 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;A. Gift Carpet&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个 $n$ 行 $m$ 列的字符矩阵，判断矩阵中从前往后的列中能不能找到特定的字符组成 &lt;strong&gt;vika&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;暴力&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;直接旋转矩阵然后暴力判断 :)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;T = int(input())

def solve():
  r, c = list(map(int, input().split()))
  s = [input() for i in range(r)]
  s[::] = [[row[i] for row in s[::-1]] for i in range(len(s[0]))]
  s = [&quot;&quot;.join(i) for i in s]
  v, vi, vik, vika = [False, False, False, False]

  for line in s:
    if vik and &apos;a&apos; in line:
      vika = True
    if vi and &apos;k&apos; in line:
      vik = True
    if v and &apos;i&apos; in line:
      vi = True
    if &apos;v&apos; in line:
      v = True

  print(&quot;YES&quot; if vika else &quot;NO&quot;)
while T != 0:
  T -= 1
  solve()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Sequence Game&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;已知 $a$ 序列可以通过特定的规则变化成 $b$ 序列，规则如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将 $a_1$ 加入序列 $b$&lt;/li&gt;
&lt;li&gt;当 $a_i \ge a_{i-1}\quad(2 \le i \le m)$ 时，将 $a_i$ 加入序列 $b$&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比如 $[4,3,2,6,3,3]$ 变化为 $[4,6,3]$&lt;/p&gt;
&lt;p&gt;现给出长度为 $n$ 的序列 $b$ ，请构造出符合上述条件的序列 $a$，长度不能超过 $2n$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;构造&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;题目要进行一个逆向恢复的过程，由于题目要求构造的序列长度不能超过 $2n$，先粗略考虑将 $b$ 中的每 $1$ 个元素变成 $a$ 中的 $2$ 个元素。当构造的两个元素相同时，后一个元素$a_j$一定会被添加到 $b$，而前一个元素当大于等于前一个元素时也可能会被添加到 $b$ 中。出现第二种情况时，$a_j$ 就没有必要了。&lt;/p&gt;
&lt;p&gt;因此我们可以整理出以下思路：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;若 $b_i \ge last(a)$ 或 $a$ 为空 ，将一个 $b_i$ 添加到 $a$ 中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;若 $b_i &amp;lt; last(a)$，则将两个 $b_i$ 添加到 $a$ 中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;T = int(input())

def solve():
  n = int(input())
  b = list(map(int, input().split()))
  a = []
  for i in range(n):
    if i == 0 or b[i] &amp;gt;= b[i-1]:
      a.append(b[i])
    else:
      a.extend([b[i], b[i]])
  print(len(a))
  print(&quot; &quot;.join(map(str, a)))

while T != 0:
  T -= 1
  solve()
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Flower City Fence&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入 $n$ 个数 $a$，每个 $a_i$ 表示高度，$n$ 表示宽度，形成一个类似条形图的图形。&lt;/p&gt;
&lt;p&gt;问该图形是否沿直线 $x=y$ 对称&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://espresso.codeforces.com/52f502884300425d70ef4fcbf2b54308a7189932.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;暴力&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;不太清楚为什么 CF 的标签上会有二分和排序&lt;/p&gt;
&lt;p&gt;实际上只需要遍历每个块，判断第 $i$ 个块是否满足第 $i$ 个块的高度$a[i]$与 $j$ 相等（其中 $j$ 为第一个 $a[j] &amp;gt;= i$ 的值）&lt;/p&gt;
&lt;p&gt;&lt;s&gt;写 GO 语言不用读入优化会 TLE on 6&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;狗都不写 GO&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;package main

import (
    &quot;bufio&quot;
    &quot;fmt&quot;
    &quot;os&quot;
    &quot;strconv&quot;
    &quot;strings&quot;
)

func solve(in *bufio.Reader) {
    n := readInt(in)
    a := readArrInt(in)
    alen := n
    for i := 0; i &amp;lt; n; i++ {
        for alen &amp;gt; 0 &amp;amp;&amp;amp; a[alen-1] &amp;lt;= i {
            alen--
        }
        if a[i] != alen {
            fmt.Println(&quot;NO&quot;)
            return
        }
    }
    fmt.Println(&quot;YES&quot;)
}
func main() {
    in := bufio.NewReader(os.Stdin)
    T := readInt(in)

    for i:= 0; i &amp;lt; T; i++ {
        solve(in)
    }
}

func readInt(in *bufio.Reader) int {
    nStr, _ := in.ReadString(&apos;\n&apos;)
    nStr = strings.ReplaceAll(nStr, &quot;\r&quot;, &quot;&quot;)
    nStr = strings.ReplaceAll(nStr, &quot;\n&quot;, &quot;&quot;)
    n, _ := strconv.Atoi(nStr)
    return n
}

func readLineNumbs(in *bufio.Reader) []string {
    line, _ := in.ReadString(&apos;\n&apos;)
    line = strings.ReplaceAll(line, &quot;\r&quot;, &quot;&quot;)
    line = strings.ReplaceAll(line, &quot;\n&quot;, &quot;&quot;)
    numbs := strings.Split(line, &quot; &quot;)
    return numbs
}

func readArrInt(in *bufio.Reader) []int {
    numbs := readLineNumbs(in)
    arr := make([]int, len(numbs))
    for i, n := range numbs {
        val, _ := strconv.Atoi(n)
        arr[i] = val
    }
    return arr
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. Ice Cream Balls&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Tema 正在制作双球冰激凌。现在要制作 $m$ 种不同的冰激凌，最少需要几个球？球的种类可以不同，并且有无限多种&lt;/p&gt;
&lt;p&gt;注意：不同种类球的放置顺序与产物的种类无关，即$\{1,2\}= \{2,1\}$，但 $\{1,1\} \ne \{1, 2\}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;组合数学&lt;/code&gt; &lt;code&gt;二分答案&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;极限情况下，可以每个雪糕球的种类都不相同，这样每取两个就可以形成一种冰激凌，可以保证取到的双球冰激凌种类最多。在这种情况下，每添加一个雪糕球之前已经存在过，那么双球冰激凌种类就会加一。&lt;/p&gt;
&lt;p&gt;那么我们可以二分雪糕球的种类 $k$，每次 check $k$ 种雪糕球能形成的双球冰激凌的种类 $\frac{C_n^2 C_{n-2}^2C_{n-4}^2 \ldots C^2_2}{A^\frac{n}{2}_\frac{n}{2}}=C_n^2$和$m$ 的关系，保证 $C_n^2 \le m$ ，最终答案即为 $n + (m - C^2_n)$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int C2(int n){
  return (n * (n-1))/2;
}

void solve() {
  int n;
  read(n);
  int L = 1, R = 2648956421;
  while(L &amp;lt; R){
    int mid = L + (R - L + 1) / 2;
    if(C2(mid) &amp;lt;= n) L = mid;
    else R = mid - 1;
  }
  std::cout &amp;lt;&amp;lt; L + (n - C2(L));
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;根据此其实可以给出一个非二分的写法&lt;/p&gt;
&lt;p&gt;若最终有 $m$ 种，则在最优情况下应该是使用了都不相同的雪糕球时 $C_n^2 = \frac{n(n-1)}{2} = m$&lt;/p&gt;
&lt;p&gt;那么 $n-1 \le \sqrt{2m} \le n$&lt;/p&gt;
&lt;p&gt;令 $i = \sqrt{2m}$，我们只需要尽可能的使 $i \to n$，也就是满足 $i(i-1) &amp;lt;= 2n$ 时尽可能大&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;use std::io;

fn solve() {
    let mut input = String::new();
    io::stdin().read_line(&amp;amp;mut input).unwrap();
    let n: i64 = input.trim().parse().unwrap();

    let mut i = ((2 * n) as f64).sqrt() as i64;
    while i * (i - 1) &amp;lt;= 2 * n {
        i += 1;
    }
    if i * (i - 1) &amp;gt; 2 * n {
        i -= 1;
    }
    print!(&quot;{}\n&quot;, i + (n - i * (i - 1)/ 2));
}

fn main() {
    let mut input = String::new();
    io::stdin().read_line(&amp;amp;mut input).unwrap();
    let t: i64 = input.trim().parse().unwrap();
    for _ in 0..t {
        solve();
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;E. Kolya and Movie Theatre&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;影院在 $n$ 天中每天放一部新电影。每部电影都有一个价值 $a_i$&lt;/p&gt;
&lt;p&gt;当 Kolya 不去看某电影时，下一部电影的价值将下降 $d \cdot cnt$，其中 $d$ 代表预定值，$cnt$ 表示距离上次看电影过了几天。&lt;/p&gt;
&lt;p&gt;Kolya 最多只能看 $m$ 次电影，制定一个计划，使 Kolya 的观影价值最大&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;贪心&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果我们选择 $1,3$ 的电影，答案为$a_1 - (1-0)d + a_3 - (3-1)d = a_1 +a_3 - 3d$&lt;/p&gt;
&lt;p&gt;如果我们选择 $1,2,4$ 的电影，答案为 $a_1 - (1-0)d + a_2 - (2-1)d + a_4 - (4-2)d = a_1 + a_2 + a_4 + 4d$&lt;/p&gt;
&lt;p&gt;也就是说无论 Kolya 选择看哪几天的电影，只要最后选择第 $k$ 天的电影，那么价值下降的总和都是 $kd$，完整的答案为&lt;/p&gt;
&lt;p&gt;$$
\sum_{i \in S} a_i - \max_{i \in S}(i)\times d
$$&lt;/p&gt;
&lt;p&gt;用优先队列去枚举最大的 $S$ 集合即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int n, m, d;
  read(n, m, d);
  std::vector&amp;lt;int&amp;gt; a(n+1);
  reads(all1(a));

  int max = 0;
  int ans = 0;
  std::priority_queue&amp;lt;int, std::vector&amp;lt;int&amp;gt;, std::greater&amp;lt;&amp;gt;&amp;gt; q;

  for(int i = 1; i &amp;lt;= n; i++){
    if(a[i] &amp;lt; 0) continue;
    ans += a[i];
    q.push(a[i]);
    if(q.size() &amp;gt; m){
      ans -= q.top();
      q.pop();
    }
    max = std::max(max, ans - i * d);
  }
  std::cout &amp;lt;&amp;lt; max;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;F. Magic Will Save the World&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Vika 有水魔法和火魔法，每秒钟 Vika 可以产生 $w$ 单位水魔力和 $f$ 单位火魔力。施展魔法需要魔力，而刚开始 Vika 没有任何魔力。&lt;/p&gt;
&lt;p&gt;现在有 $n$ 只怪物，击败每个怪物需要使用消耗 $s_i$ 魔力的魔法。&lt;/p&gt;
&lt;p&gt;Vika 可以在一秒中内无限使用魔法，请求出消灭所有怪物至少需要多少秒&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;子集枚举&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;看到这个问题首先想到的是 dp&lt;/p&gt;
&lt;p&gt;$$
f[i][j][k] = max(f[i-1][j][k] , f[i-1][j-s[i]][k] + 1, f[i-1][j][k-s[i]]+1)
$$&lt;/p&gt;
&lt;p&gt;但是受限于数据范围 $1 \le w, f \le 10^9$ 这样肯定不可行&lt;/p&gt;
&lt;p&gt;考虑列出所有怪物血量可组成的集合的子集，枚举子集 $i$ ，计算使用火魔法消灭 $i$ 使用水魔法消灭 $sum - i$ 所需要的时间，统计最小值&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int maxs = 1e4 * 100 + 17;
void solve() {
  int w, f, n;
  read(w, f, n);
  std::vector&amp;lt;int&amp;gt; s(n + 1);
  reads(all1(s));

  std::bitset&amp;lt;maxs&amp;gt; dp;
  dp[0] = 1;
  int sum = 0;
  for (int i = 1; i &amp;lt;= n; i++) {
    dp |= dp &amp;lt;&amp;lt; s[i];
    sum += s[i];
  }

  int ans = 1e9;
  for (int i = 0; i &amp;lt;= sum; i++) {
    if (dp[i]) {
      int t = std::max(std::ceil(1.0 * i / w), std::ceil(1.0 * (sum - i) / f));
      ans = std::min(ans, t);
    }
  }
  std::cout &amp;lt;&amp;lt; ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;G. The Great Equalizer&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;现有一均衡器设备接受数组 $a$ 作为输入。均衡器将会：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;升序排序并去重&lt;/li&gt;
&lt;li&gt;如果当前数组的长度为$1$ ，均衡器将停止工作，并将数组中唯一的元素作为设备输出&lt;/li&gt;
&lt;li&gt;在数组中的每个元素加上等差数列 $\{n - 0, n - 1, n -2, \ldots, 1\}$ 中对应的元素，其中 $n$ 表示数组长度。即索引从 $0$ 开始时，令第 $i$ 个元素为 $a[i] + (n-i)$&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了测试设备，将一个数组 $a$ 作为输入，并进行 $q$ 次操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将 $x$ 赋值给指定元素 $a_i$&lt;/li&gt;
&lt;li&gt;将数组 $a$ 作为设备的输入，并记录设备的输出。&lt;strong&gt;数组 $a$ 在设备运行中保持不变&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;找出设备每次操作后的输出值&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;稍微玩一玩样例，可以发现每次操作都可以将两个相邻的两个数的差减小$1$。也就是说将数组变为相同的一个数需要$t=\max_{2 \le i\le n}(a[i] - a[i-1])$ 次操作。最终剩余的数一定是最大的数 $a[n] + t$&lt;/p&gt;
&lt;p&gt;比如 $[1,6,10]$，相邻的两个数最大差 $6-1=5$，答案即为 $10 + 5 = 15$&lt;/p&gt;
&lt;p&gt;直接白嫖 &lt;code&gt;std::multiset&lt;/code&gt; 维护集合和相邻两个数的差，每次维护操作复杂度 $O(\log n)$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
    int n;
    std::cin &amp;gt;&amp;gt; n;

    std::vector&amp;lt;int&amp;gt; a(n);
    for (int i = 0; i &amp;lt; n; i++) {
        std::cin &amp;gt;&amp;gt; a[i];
    }

    std::multiset&amp;lt;int&amp;gt; s, d{0};

    auto add = [&amp;amp;](int x) {
        auto it = s.insert(x);
        auto r = std::next(it);
        if (it != s.begin()) {
            d.insert(x - *std::prev(it));
        }
        if (r != s.end()) {
            d.insert(*r - x);
        }
        if (it != s.begin() &amp;amp;&amp;amp; r != s.end()) {
            d.extract(*r - *std::prev(it));
        }
    };

    auto del = [&amp;amp;](int x) {
        auto it = s.find(x);
        auto r = std::next(it);
        if (it != s.begin()) {
            d.extract(x - *std::prev(it));
        }
        if (r != s.end()) {
            d.extract(*r - x);
        }
        if (it != s.begin() &amp;amp;&amp;amp; r != s.end()) {
            d.insert(*r - *std::prev(it));
        }
        s.erase(it);
    };

    for (int i = 0; i &amp;lt; n; i++) {
        add(a[i]);
    }

    int q;
    std::cin &amp;gt;&amp;gt; q;
    for (int i = 0; i &amp;lt; q; i++) {
        int x, y;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        x--;
        del(a[x]);
        a[x] = y;
        add(a[x]);
        int ans = *s.rbegin() + *d.rbegin();
        std::cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &quot; &quot;[i == q - 1];
    }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>Codeforces</category><author>Mslxl</author></item><item><title>LeetCode 周赛 359</title><link>https://blog.mslxl.com/posts/cp/leetcode-wc359/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/leetcode-wc359/</guid><pubDate>Mon, 21 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;A. 判别首字母缩略词&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个字符串数组 words 和一个字符串 s ，请你判断 s 是不是 words 的 首字母缩略词 。&lt;/p&gt;
&lt;p&gt;如果可以按顺序串联 words 中每个字符串的第一个字符形成字符串 s ，则认为 s 是 words 的首字母缩略词。
例如，&quot;ab&quot; 可以由 [&quot;apple&quot;, &quot;banana&quot;] 形成，但是无法从 [&quot;bear&quot;, &quot;aardvark&quot;] 形成。&lt;/p&gt;
&lt;p&gt;如果 s 是 words 的首字母缩略词，返回 true ；否则，返回 false 。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;模拟&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
public:
    bool isAcronym(vector&amp;lt;string&amp;gt;&amp;amp; words, string s) {
        std::string ans;
        for(auto s: words) ans += s[0];
        return ans == s;
    }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. k-avoiding 数组的最小总和&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你两个整数 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;对于一个由 &lt;strong&gt;不同&lt;/strong&gt; 正整数组成的数组，如果其中不存在任何求和等于 k 的不同元素对，则称其为 &lt;strong&gt;k-avoiding&lt;/strong&gt; 数组。&lt;/p&gt;
&lt;p&gt;返回长度为 &lt;code&gt;n&lt;/code&gt; 的 &lt;strong&gt;k-avoiding&lt;/strong&gt; 数组的可能的最小总和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;贪心&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;贪心，向集合中放尽可能少的数。&lt;/p&gt;
&lt;p&gt;从小到大考虑数字 $i$ ，如果 $k-i$ 存在于集合中，则说明数字 $i$ 不可选。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
 public:
  int minimumSum(int n, int k) {
    std::set&amp;lt;int&amp;gt; sum;
    for (int i = 1; sum.size() &amp;lt; n; i++) {
      if (i &amp;gt;= k) {
        sum.insert(i);
      } else {
        if (sum.count(k - i)) {
          continue;
        }
        sum.insert(i);
      }
    }

    int ansSum = 0;
    for (auto i : sum) {
      ansSum += i;
    }
    return ansSum;
  }
};
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. 销售利润最大化&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt; 表示数轴上的房屋数量，编号从 &lt;code&gt;0&lt;/code&gt; 到 &lt;code&gt;n - 1&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;另给你一个二维整数数组 &lt;code&gt;offers&lt;/code&gt; ，其中 &lt;code&gt;offers[i] = [starti, endi, goldi]&lt;/code&gt; 表示第 &lt;code&gt;i&lt;/code&gt; 个买家想要以
 &lt;code&gt;goldi&lt;/code&gt; 枚金币的价格购买从 &lt;code&gt;starti&lt;/code&gt; 到 &lt;code&gt;endi&lt;/code&gt; 的所有房屋。&lt;/p&gt;
&lt;p&gt;作为一名销售，你需要有策略地选择并销售房屋使自己的收入最大化。&lt;/p&gt;
&lt;p&gt;返回你可以赚取的金币的最大数目。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意&lt;/strong&gt; 同一所房屋不能卖给不同的买家，并且允许保留一些房屋不进行出售。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;线性 DP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;枚举 end 状态，设当前状态为 $i$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$dp[i] = dp[i-1]$ 不买这个位置的房&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$dp[i] = dp[u-1] + w$ 买这段上的房&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;由于题目都是从 &lt;code&gt;0&lt;/code&gt; 开始，减1容易越界，因此可以将 start 和 end 加一。答案取 max 即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;class Solution {
 public:
  int maximizeTheProfit(int n, vector&amp;lt;vector&amp;lt;int&amp;gt;&amp;gt;&amp;amp; offers) {
    std::map&amp;lt;int, std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt;&amp;gt; mp;
    for (auto&amp;amp; item : offers) {
      mp[item[1] + 1].push_back({item[0] + 1, item[2]});
    }
    std::vector&amp;lt;int&amp;gt; dp(n + 1);
    for (int i = 1; i &amp;lt;= n; i++) {
      dp[i] = dp[i - 1];
      for (auto&amp;amp; [u, w] : mp[i]) {
        dp[i] = std::max(dp[i], dp[u - 1] + w);
      }
    }
    return dp[n];
  }
};

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;找出最长等值子数组&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一个下标从 &lt;strong&gt;0&lt;/strong&gt; 开始的整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数 &lt;code&gt;k&lt;/code&gt; 。&lt;/p&gt;
&lt;p&gt;如果子数组中所有元素都相等，则认为子数组是一个 &lt;strong&gt;等值子数组&lt;/strong&gt; 。注意，空数组是 &lt;strong&gt;等值子数组&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;从 &lt;code&gt;nums&lt;/code&gt; 中删除最多 &lt;code&gt;k&lt;/code&gt; 个元素后，返回可能的最长等值子数组的长度。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;子数组&lt;/strong&gt; 是数组中一个连续且可能为空的元素序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;分组&lt;/code&gt; &lt;code&gt;双指针&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;题目要求从一段子区间中删除不大于 $k$ 个数，使得子区间中剩余的数字相同&lt;/p&gt;
&lt;p&gt;选择子区间中相同的数比较麻烦，我们可以直接将相同的数分为一组，将下标保存在数组中。&lt;/p&gt;
&lt;p&gt;剩下的问题就是在所有组中找到一个区间，他们的下标中相隔的数字的数量不超过$k$。可以使用前缀和，
区间$[l,r]$中需要删除的数字数量为 $pos[r] - pos[l] + (r-l)$。也可以直接算 $(pos[r] - pos[l]) - (r-l)$（区间的总长度减去不需要删除的数字数量）&lt;/p&gt;
&lt;p&gt;写写 GO 玩玩&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;func longestEqualSubarray(nums []int, k int) int {
    maxValue := 0
    for _, v := range nums {
        maxValue = max(maxValue, v)
    }
    pos := make([][]int, maxValue+1)
    for i, v := range nums {
        pos[v] = append(pos[v], i)
    }

    ans := 0
    for _, ps := range pos {
        left := 0
        for right, p := range ps {
            for p-ps[left]-(right-left) &amp;gt; k { //删除的数字数量大于了 k
                left++
            }
            ans = max(ans, right-left+1)
        }
    }
    return ans
}

func max(a, b int) int {
    if a &amp;gt; b {
        return a
    }
    return b
}

&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>LeetCode</category><author>Mslxl</author></item><item><title>Educational Codeforces Round 153 A-E (博弈论 DP 拆点)</title><link>https://blog.mslxl.com/posts/cp/cf1860/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/cf1860/</guid><pubDate>Fri, 18 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;A. Not a Substring&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给一个仅由 &lt;code&gt;(&lt;/code&gt; 和 &lt;code&gt;)&lt;/code&gt; 组成的字符串$a$，它的长度为 $n$。要求构造一个长度为 $2n$ 的新字符串 $b$，且 $a$ 不是 $b$ 的连续子串。输出新字符串 $b$。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;构造&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很明显一个字符串如果是 &lt;code&gt;(((())))&lt;/code&gt; 的子字符串，那它一定不是 &lt;code&gt;()()()()&lt;/code&gt; 的子字符串。因此只需要构造出两个字符串进行判断即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  std::string s;
  std::cin &amp;gt;&amp;gt; s;
  std::string s1, s2;
  rep(i, s.size()) {
    s1 += &quot;()&quot;;
    s2 += &quot;(&quot;;
  }
  rep(i, s.size()) { s2 += &quot;)&quot;; }

  if (s1.find(s) == std::string::npos) {
    std::cout &amp;lt;&amp;lt; &quot;YES\n&quot; &amp;lt;&amp;lt; s1;
  } else if (s2.find(s) == std::string::npos) {
    std::cout &amp;lt;&amp;lt; &quot;YES\n&quot; &amp;lt;&amp;lt; s2;
  } else {
    std::cout &amp;lt;&amp;lt; &quot;NO&quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Fancy Coins&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Monocarp 要进行一项价值 $m$ 的支出。他现在有两种价值的硬币:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;价值为 $1$ 的普通硬币 $a_1$ 枚和同价值的花式硬币无限枚&lt;/li&gt;
&lt;li&gt;价值为 $k$ 的普通硬币 $a_k$ 枚和同价值的花式硬币无限枚&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Monocarp想要恰巧支付 $m$ 并花费尽可能少的花式硬币。输出消耗的花式硬币的数量。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;贪心&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很明显我们要尽可能使用价值为 $k$ 的硬币，少量价值为 $1$ 的硬币只是拿来凑零的。我们可以将 $k$ 枚价值为 $1$ 的普通硬币看作 $1$ 枚价值为 $k$ 的普通硬币，接下来只需要花费 $\lfloor m / k\rfloor$ 枚价值为 $k$ 的硬币和 $m\mod k$ 枚价值为 $1$的硬币，简单的进行减法即可得到答案。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  int m, k, a, b;
  cin &amp;gt;&amp;gt; m &amp;gt;&amp;gt; k &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;

  int mk = m % k;
  int m_k = m / k;
  if (a &amp;gt;= mk) {
    a -= mk;
    b += a / k;
    cout &amp;lt;&amp;lt; std::max(0, m_k - b);
  } else {
    cout &amp;lt;&amp;lt; std::max(0, m_k - b) + mk - a;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Game on Permutation&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Alice 和 Bob 正在玩一个游戏。&lt;/p&gt;
&lt;p&gt;游戏进行在一个大小为 $n$ 的排列上。两人轮流在序列上选数，选择的数必须满足其大小的下标都小于上一个人选择的数的大小和下标，最后不能行动的人赢。&lt;/p&gt;
&lt;p&gt;Alice 先手。问 Alice 先选择哪个数，后续一定存在必胜。输出这种数的数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;博弈论&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很明显这是一个 Anti-Game。由 SJ 定理可知，这个游戏的 PN 态等价于它的相反游戏（即不能行动的人输）。我们只需要获取排列中原游戏每个数的 PN 态，最后统计 P 态的数量即可。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C1.png&quot; alt=&quot;C1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;对于样例1，当选择 $2$ 和 $1$后，下一个人均不能行动，因此为 &lt;em&gt;N&lt;/em&gt; 态，而 $3$ 只能转移到 $2$ 或者 $1$ 这两个 &lt;em&gt;N&lt;/em&gt; 态，因此为 $3$ 为 &lt;em&gt;P&lt;/em&gt; 态。最终答案为 1&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;C3.png&quot; alt=&quot;C3&quot; /&gt;&lt;/p&gt;
&lt;p&gt;对于第三个样例同理，由于 $3$ 和 $4$ 只能转移到 $2$ 和 $1$，因此答案为 $2$&lt;/p&gt;
&lt;p&gt;在实现时，只需要从头开始遍例第 $i$ 个数，判断前面比 $a_i$ 小的数中是否存在 &lt;em&gt;P&lt;/em&gt; 态，如果存在则 $i$ 为 &lt;em&gt;N&lt;/em&gt; 态，否则为 $P$ 态。这可以使用树态数组实现，这里白嫖一下 pbds。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;ext/pb_ds/tree_policy.hpp&amp;gt;
#include&amp;lt;ext/pb_ds/assoc_container.hpp&amp;gt;
void solve() {
  int n;
  read(n);
  std::vector&amp;lt;int&amp;gt; s(n);
  reads(all(s));

  using namespace __gnu_pbds;
  tree&amp;lt;int, null_type, std::less&amp;lt;int&amp;gt;, splay_tree_tag,
       tree_order_statistics_node_update&amp;gt; N, P;

  for (int i = 0; i &amp;lt; s.size(); i++) {
    int nNum = N.order_of_key(s[i]); // 比 s[i] 小的数中有几个 N 态
    if (nNum == 0) {
      // 刚开始第一个数
      N.insert(s[i]);
    } else if (N.size() + (P.size() - P.order_of_key(s[i])) == i) {
      // N 态的数量加上能不能转移到的 P 态的数量等于当前下标
      // 即不能转移到 P 态
      P.insert(s[i]);
    } else {
      N.insert(s[i]);
    }
  }
  std::cout &amp;lt;&amp;lt; P.size();
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. Balanced String&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一个 01 串 $s$，进行尽可能少的交换其中的 &lt;code&gt;0&lt;/code&gt; 和 &lt;code&gt;1&lt;/code&gt;，使交换后新字符串中的子串 &lt;code&gt;01&lt;/code&gt; 和 &lt;code&gt;10&lt;/code&gt; 的数量相同。&lt;/p&gt;
&lt;p&gt;输出最少的交换次数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;DP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;参考了 jiangly 的代码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;考虑使用 DP 时依次向第 $i$ 位放置 &lt;code&gt;0&lt;/code&gt; 或者 &lt;code&gt;1&lt;/code&gt;，因此我们需要两个状态表示当前位数和放了多少 &lt;code&gt;1&lt;/code&gt;。由于最终答案是最少的交换次数，目标是使 &lt;code&gt;01&lt;/code&gt;和&lt;code&gt;10&lt;/code&gt;串的数量相等，所以我们还需要一个状态去表示 &lt;code&gt;01&lt;/code&gt; 串的数量，但由于在放 &lt;code&gt;1&lt;/code&gt;的过程中除了形成 &lt;code&gt;01&lt;/code&gt; 串还会形成 &lt;code&gt;11&lt;/code&gt; 串，这在 DP 时难以记录，因此可以直接去表示 &lt;code&gt;01&lt;/code&gt; 和 &lt;code&gt;11&lt;/code&gt; 的数量。最终我们将状态定义为&lt;/p&gt;
&lt;p&gt;$$
dp[i][j][k]
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$i$ 表示当前位数&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$j$ 表示当前放 &lt;code&gt;1&lt;/code&gt; 的数量&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$k$ 表示当前 &lt;code&gt;01&lt;/code&gt; 串和 &lt;code&gt;11&lt;/code&gt; 串的数量&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;他们之间的状态转移可以是:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;$dp[i][j][k] = dp[i-1][j][k]$ : 当前位置放 0&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$dp[i][j][k] = dp[i-1][j-1][k-i]$ ：当前位置放 1，原字符串位置为 1，不需要交换&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;$dp[i][j][k] = dp[i-1][j-1][k-i] + 1$： 当前位置放 $1$ ，原字符串位置为 1，需要进行交换&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出这个状态转移非常像 01背包，因此我们可以采用相同的方式进行去掉 $i$ 这一维。&lt;/p&gt;
&lt;p&gt;但要进行 DP，我们还需要得知最终 &lt;code&gt;01 &lt;/code&gt;和&lt;code&gt;11&lt;/code&gt; 串的数量，即 $k$ 的上限。&lt;/p&gt;
&lt;p&gt;考虑原字符串中的子串有 &lt;code&gt;01&lt;/code&gt;,&lt;code&gt;10&lt;/code&gt;,&lt;code&gt;11&lt;/code&gt;和&lt;code&gt;00&lt;/code&gt; 四种，其中&lt;code&gt;00&lt;/code&gt;和&lt;code&gt;11&lt;/code&gt;无论怎么交换数量都不会变。因此我们可以统计出 $s$ 中 &lt;code&gt;1&lt;/code&gt;和&lt;code&gt;0&lt;/code&gt; 的数量，算出 &lt;code&gt;00&lt;/code&gt; 和&lt;code&gt;11&lt;/code&gt;的数量。&lt;/p&gt;
&lt;p&gt;对于最终交换成的新字符串 &lt;code&gt;01&lt;/code&gt; 串的数量和 &lt;code&gt;10&lt;/code&gt; 串的数量是相同的，因此可以算出最终字符串中 &lt;code&gt;01&lt;/code&gt; 串和 &lt;code&gt;10&lt;/code&gt; 串的数量，进而可以算出 &lt;code&gt;01&lt;/code&gt; 和 &lt;code&gt;11&lt;/code&gt; 的数量为 $\frac{\text{四种串的总数量} - \text{00串的数量} + \text{11串的数量} }{2}$&lt;/p&gt;
&lt;p&gt;那么现在可以实现代码了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int maxn = 117;
int dp[maxn][maxn * maxn / 2];
void solve() {
  std::string s;
  std::cin &amp;gt;&amp;gt; s;
  int c = s.size();
  int c1 = std::count(all(s), &apos;1&apos;), c0 = std::count(all(s), &apos;0&apos;);
  int need = (c * (c - 1) / 2 - c0 * (c0 - 1) / 2 + c1 * (c1 - 1) / 2) / 2;
  std::memset(dp, 0x3f, sizeof(dp));
  dp[0][0] = 0;
  for (int i = 0; i &amp;lt; c; i++) {
    for (int j = std::min(c1, i+1); j &amp;gt;= 1; j--) {
      for (int k = i; k &amp;lt;= need; k++) {
        dp[j][k] = std::min(
          dp[j][k],
          dp[j - 1][k - i] + (s[i] == &apos;0&apos;)
        );
      }
    }
  }
  std::cout &amp;lt;&amp;lt; dp[c1][need];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;E. Fast Travel Text Editor&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给一串仅由小写字母组成的字符串 $s$。现在在两个字符中间有一个光标，光标不会出现在字符串的最左侧或者最右侧。&lt;/p&gt;
&lt;p&gt;光标可以进行两种操作&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;左移/右移一位，代价为 1&lt;/li&gt;
&lt;li&gt;跳转到其他左右字符相同的位置，代价也为 1&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有 $q$ 次询问，每次询问从光标从第 $f$ 个位置到第 $t$ 的位置最小的代码&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;图论&lt;/code&gt; &lt;code&gt;拆点&lt;/code&gt; &lt;code&gt;01最短路&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;首先第一反应是建图bfs&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;如果朴素建图，最坏情况下 $s$ 可能全是一样的字符，时间复杂度 $O(|s|^2)$，这显然是不可接受的。但是由于光标可以跳转到和其他所有左右字符相同的位置，可以进行拆点操作。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;E.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;拆点方式如图，对于左右两字符相同的地点，建立一个中转点，入边边权为 $1$，出边为 $0$。建图后进行 $01$ 最短路即可。&lt;/p&gt;
&lt;p&gt;对于每次从$f$ 到 $t$，它如果经过中转点，那么距离一定是 $|\text{中转点到 f 的距离} + \text{中传点到 t 的距离}|$。如果它不经过中传点，那么距离是 $|f-t|$。通过这种方式可以有效减少 BFS 的次数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int N = 5e4+5;
const int M = 28;

int id[M][M][2]; // 中转点的编号
std::vector&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; G[N*2+17];

std::vector&amp;lt;int&amp;gt; dis[M][M];
std::deque&amp;lt;int&amp;gt; q;

void add_edge(int u,int v,int w){
    G[u].push_back({v,w});
    G[v].push_back({u,w});
}

int main(){
    std::string s;
    std::cin &amp;gt;&amp;gt; s;
    int n= s.size();
    for(int i=0;i&amp;lt;n;i++)s[i]-=&apos;a&apos;;

    // 建立所有的中转点
    int cnt=n-1;
    for(int a=0;a&amp;lt;26;a++){
        for(int b=0;b&amp;lt;26;b++){
            id[a][b][0] = cnt++;
            id[a][b][1] = cnt++;
            G[cnt-2].push_back({cnt-1,1});
        }
    }
    for(int i=0;i&amp;lt;n-2;i++){
        add_edge(i,i+1,1);
    }
    for(int i=0;i&amp;lt;n-1;i++){
        G[i].push_back({id[s[i]][s[i+1]][0],0});
        G[id[s[i]][s[i+1]][1]].push_back({i,0});
    }

    for(int a=0;a&amp;lt;26;a++){
        for(int b=0;b&amp;lt;26;b++){
            // 从中转点的出点开始 0-1 BFS
            dis[a][b] = vector&amp;lt;int&amp;gt;(cnt,1e9);

            auto&amp;amp; d = dis[a][b];
            int st = id[a][b][1];
            d[st]=0;
            q.push_back(st);

            while(q.size()){
                int u=q.front();q.pop_front();
                for(auto [v,w]:G[u]){
                    if(d[u]+w&amp;lt;d[v]){
                        d[v]=d[u]+w;
                        if(w==0) q.push_front(v);
                        else q.push_back(v);
                    }
                }
            }
        }
    }

    int query;
    read(query);
    while(query--){
        int l,r;
        read(l, r);
        l--,r--;
        int ans = abs(r-l);

        for(int i=0;i&amp;lt;26;i++){
            for(int j=0;j&amp;lt;26;j++){
                ans = min(ans,dis[i][j][l]+dis[i][j][r]+1);
            }
        }
        std::cout &amp;lt;&amp;lt; ans;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>Codeforces</category><author>Mslxl</author></item><item><title>Codeforces Round 891 (Div. 3) A-G</title><link>https://blog.mslxl.com/posts/cp/cf1853/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/cf1853/</guid><pubDate>Tue, 08 Aug 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;A. Array Coloring&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给一个长度为 $n$ 的数组，判断数组能否分为两组元素的加和的奇偶性相同的两组&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;考虑数组中奇数的数量，由于&lt;code&gt;奇数 + 奇数 = 偶数&lt;/code&gt;，&lt;code&gt;奇数 + 偶数 = 奇数&lt;/code&gt;，如果有偶数个奇数，我们可以将奇数其平分到两个数组中，否则无论如何都无法满足条件&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve(const std::size_t testcase) {
  multitest{
    std::vector&amp;lt;i32&amp;gt; s(n);
    reads(all(s));
    int odd = 0;
    for(auto i : s)
      if(i % 2 != 0)
        odd++;
    std::cout &amp;lt;&amp;lt; (odd % 2 == 0 ? &quot;YES&quot;: &quot;NO&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;B. Maximum Rounding&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;四舍五入到某一位置，使的数字最大。该操作可以执行多次，输出最大的数字&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;高精&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;直接模仿高精度，从最低位开始判断&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  multitest {
    std::string a;
    std::cin &amp;gt;&amp;gt; a;
    a = &quot;0&quot; + a;
    std::vector&amp;lt;int&amp;gt; s(a.size());
    std::vector&amp;lt;int&amp;gt; mask(a.size());
    for (int i = 0; i &amp;lt; a.size(); i++) s[i] = a[i] - &apos;0&apos;;

    for (int i = s.size() - 1; i &amp;gt; 0; i--) {
      if (s[i] &amp;gt;= 5) {
        s[i - 1]++;
        mask[i] = 1;
      }
    }

    bool flag = false;
    for (int i = 0; i &amp;lt; s.size(); i++) {
      if (i == 0 &amp;amp;&amp;amp; s[i] == 0) continue;
      flag = flag || mask[i];
      if (flag) std::cout &amp;lt;&amp;lt; 0;
      else std::cout &amp;lt;&amp;lt; s[i];
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;C. Assembly via Minimums&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;长度为 $n$ 的序列 a 可以通过特定规则变化成长度为 $\frac{n(n-1)}{2}$ 的序列 b，现在输入一个序列 b，输出任意一种能变换成 b 的序列 a。&lt;/p&gt;
&lt;p&gt;变化规则是：$b = \{ min(a_i, a_j) \mid i \in [1, norm(a)] \land i \in [1, norm(a)] \land i \ne j \}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;手玩样例可以发现，如果一个数在 b 中出现了 $m$ 次，那么它在 a 中一定有 $m$ 个比它大的数，由于题目保证一定有解，因此可以对 b 序列排序后直接输出&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  mtt {
    i32 n;
    read(n);
    i32 m = n * (n - 1) / 2;
    std::vector&amp;lt;int&amp;gt; s(m);
    reads(all(s));

    std::sort(all(s));
    for(int i = 0; i &amp;lt; m; i+=--n){
      std::cout &amp;lt;&amp;lt; s[i] &amp;lt;&amp;lt; &apos; &apos;;
    }
    std::cout &amp;lt;&amp;lt; *std::max_element(all(s));
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D. Strong Vertices&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入两个数组 a 和 b。构造一个有向图，如果 $a_u - a_v \ge b_u - b_v(u \ne v)$， 那么 $u$ 到 $v$ 就有一条边。&lt;/p&gt;
&lt;p&gt;输出有多少个顶点可以直接到达其他所有顶点&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;式子变形成 $a_u - b_u \ge a_v - b_v$，然后只需要统计满足 $\forall v ,a_u - b_u \ge a_v - b_v$ 的数量即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using pii = std::pair&amp;lt;int, int&amp;gt;;
void solve(const std::size_t testcase) {
  mtt {
    int n;
    read(n);
    std::vector&amp;lt;int&amp;gt; a(n), b(n);
    reads(all(a)); reads(all(b));

    std::vector&amp;lt;pii&amp;gt; ans(n);
    rep(i, n){
      ans[i].first = a[i] - b[i];
      ans[i].second = i+1;
    }
    std::sort(rall(ans));

    std::vector&amp;lt;int&amp;gt; real;
    real.pb(ans[0].second);
    for(int i = 1; i &amp;lt; ans.size(); i++)
      if(ans[i].first == ans[0].first)
        real.pb(ans[i].second);

    std::sort(all(real));

    std::cout &amp;lt;&amp;lt; real.size() &amp;lt;&amp;lt; &quot;\n&quot;;
    for(auto i : real) std::cout &amp;lt;&amp;lt; i &amp;lt;&amp;lt; &quot; &quot;;
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;E. Power of Points&lt;/h2&gt;
&lt;p&gt;玩样例可以发现 $\sum f_i$ 实际上是区间的长度，因此答案可以所以一个前缀和和后缀和求解答&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve() {
  mtt {
    int n;
    std::cin &amp;gt;&amp;gt; n;
    long long s1 = 0, s2 = 0;
    for (int i = 1; i &amp;lt;= n; i++) {
      std::cin &amp;gt;&amp;gt; x[i].first;
      x[i].second = i;
      s2 += x[i].first;
    }
    sort(x + 1, x + n + 1);
    for (int i = 1; i &amp;lt;= n; i++) {
      s2 -= x[i].first;
      s1 += x[i].first;
      a[x[i].second] = n + 1ll * x[i].first * (2 * i - n) - s1 + s2;
    }
    for (int i = 1; i &amp;lt;= n; i++) std::cout &amp;lt;&amp;lt; a[i] &amp;lt;&amp;lt; &quot; &quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;F. Sum and Product&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;解方程, 统计满足下式的解的数量&lt;/p&gt;
&lt;p&gt;$$
\begin{cases}
a_i a_j = x \\
a_i + a_j = y
\end{cases}
$$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;数学&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;解一元二次方程&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;void solve(const std::size_t testcase) {
  mtt {
    int n;
    read(n);
    std::map&amp;lt;int, int&amp;gt; cnt;
    rep(i, n) {
      int s;
      read(s);
      cnt[s]++;
    }

    int q;
    read(q);
    while (q--) {
      int a, b;
      read(a, b);
      i64 x = (a - sqrt(a * a - 4 * b)) / 2, y = (a + sqrt(a * a - 4 * b)) / 2;

      if (!(x + y != a || x * y != b) &amp;amp;&amp;amp; x == y) {
        std::cout &amp;lt;&amp;lt; cnt[x] * (cnt[y] - 1) / 2 &amp;lt;&amp;lt; &quot; &quot;;
      } else if (!(x + y != a || x * y != b)) {
        std::cout &amp;lt;&amp;lt; cnt[x] * cnt[y] &amp;lt;&amp;lt; &quot; &quot;;
      } else {
        std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &quot; &quot;;
      }
    }
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;G. Counting Graphs&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;输入一棵有 $n$ 个顶点的最小生成树，每一条边权为 $w_i$。统计有多少中加边方案使得满足以下条件&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;无重边，自环&lt;/li&gt;
&lt;li&gt;所有边权不超过 $S$&lt;/li&gt;
&lt;li&gt;加边之后的产生的图的最小生成树唯一&lt;/li&gt;
&lt;li&gt;最小生成树是最初时给出的树&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;答案 mod $998244353$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;最小生成树&lt;/code&gt; &lt;code&gt;组合数学&lt;/code&gt; &lt;code&gt;思维&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const int maxn = 2e5 + 17;
const int modd = 998244353;

int fa[maxn], sz[maxn], rk[maxn];

struct edge {
  i64 u, v, w;
  bool operator&amp;lt;(const edge &amp;amp;rhs) const { return w &amp;lt; rhs.w; }
};

int find(int x) {
  while (fa[x] != x) x = fa[x];
  return x;
}
void join(int x, int y) {
  x = find(x);
  y = find(y);
  if(x == y) return;
  if(rk[x] &amp;gt; rk[y]){
    fa[y] = x;
    sz[x] += sz[y];
  }else if(rk[x] &amp;lt; rk[y]){
    fa[x] = y;
    sz[y] += sz[x];
  }else{
    fa[x] = y;
    rk[y]++;
    sz[y]+=sz[x];
  }
}

template &amp;lt;typename A, typename BaseT&amp;gt;
typename std::enable_if&amp;lt;std::is_integral&amp;lt;BaseT&amp;gt;::value, A&amp;gt;::type qpow(
    A a, BaseT n, BaseT modd) {
  decltype(a) ans = 1;
  while (n) {
    if (n &amp;amp; 1) ans = (ans * a) % modd;
    n &amp;gt;&amp;gt;= 1;
    a = (a * a) % modd;
  }
  return ans % modd;
}

void solve() {
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr);
  // std::cout.tie(nullptr);
  mtt {
    int n, S;
    read(n, S);
    for (int i = 0; i &amp;lt;= n; i++) {
      fa[i] = i;
      sz[i] = 1;
    }
    std::vector&amp;lt;edge&amp;gt; a(n - 1);
    for (int i = 0; i &amp;lt; n - 1; i++) {
      std::cin &amp;gt;&amp;gt; a[i].u &amp;gt;&amp;gt; a[i].v &amp;gt;&amp;gt; a[i].w;
    }
    i64 ans = 1;
    std::sort(a.begin(), a.end());
    for (int i = 0; i &amp;lt; n - 1; i++) {
      i64 szu = sz[find(a[i].u)];
      i64 szv = sz[find(a[i].v)];

      ans = ans * qpow(S - a[i].w + 1, szu * szv - 1, modd) % modd;
      join(a[i].u, a[i].v);
    }
    std::cout &amp;lt;&amp;lt; ans;
  }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>Codeforces</category><author>Mslxl</author></item><item><title>2023 SDCPC 赛后回顾</title><link>https://blog.mslxl.com/posts/cp/2023sdcpc/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/2023sdcpc/</guid><pubDate>Mon, 05 Jun 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;周围的人都写了篇小作文, 那我也跟按照圈子里的惯例写个小流水帐吧,文笔不好,算给日后的自己留个纪念吧&lt;/p&gt;
&lt;p&gt;首先恭喜我校2银3铜, 听说是校史上就牌子数量的的最好成绩. 其次恭喜我自己终于拿到了XCPC上的第一块牌子(算是弥补了去年打铁的遗憾, RK55 也算是一个好开始吧).&lt;/p&gt;
&lt;p&gt;这次的队伍算是重组后的队伍, 前前后后自行进行了几场训练, 也参加了几场学校里的自行组织的几场训练, 现在回想起来这些确实给我们队伍的合作提供了很大的帮助. 十分感谢学校提供的训练场地(尽管有点难以描述)和 yrh lmy 等人的帮助. 不同于 lmy 的队伍, 我们队其实是到学校统一组织训练的时候才知道出题人是 SUA 并开始专门挑 SUA 的题目训练, 如果不是因为 lmy 的消息和 yrh 及学校老师组织的训练, 我们队伍这次比赛大概并不会这么轻松愉快.&lt;/p&gt;
&lt;p&gt;day(-9) 突然抗原阳了,在此之前我还没阳过, 在家里烧了4天, 说实话这一周都过的有点浑浑噩噩的, 阳康后已经 day(-3) 了, 赛前稍微怀着愧疚的心理看了看半平面交, 这段时间说实话感觉精神还不太对, 没办法集中注意力太长时间, 心里已经准备者打铁争铜了,不过当时还有一点希望万一队友能带我飞呢(划去)&lt;/p&gt;
&lt;p&gt;day0 热身赛前我和队内的佬 mhy 乘大巴到了 QLU, 中午在和队友一起逛 QLU 校园, 围着校园走了一圈,深刻认识到了我财专计科输输输. 绕学校一圈差不多走了 1 小时, 回到艺体中心的时候差点没瘫到座位上. 热身赛题目发现来一眼往年原题(但是已经忘了当初训练谁写的了). 感觉签的挺慢的, 不过都是一遍过. 签完后玩了差不多1小时,稍微测了下评测机后给QLU OJ贡献了差不多70发D题, 说实话感觉评测机挺拉的. 离结束还剩半小时的时候在草稿纸记了记次日需要改的电脑配置, 主要就是交换键盘 ESC 和 CapsLk, 启用 VSCode 的 vim 和 cph 插件, 改字号为 28, 打开 Natrual Scrolling. 打完笔记完后和队长 gjh , 巨佬mhy 一起去&quot;老胖烧烤&quot;吃了一顿. (还没给队长烧烤钱呢, 希望队长看不到这段话)(笑)&lt;/p&gt;
&lt;p&gt;晚上有点怕第二天晕车, 直接在长清找了个旅馆住下了. 值得一提的是晚上 gjh 直接上门交流, 然后回去抄了张二分的板子&lt;/p&gt;
&lt;p&gt;day1 正式赛. 我先按照热身赛记的笔记修改比赛机配置, 队友 gjh 和 mhy 开始开题. 事后听闻 gjh 一下开到了 H 题无人区(笑), 有时候不得不感慨太巧了. 改完配置后我按着顺序开了 A 题, 读了 3 行发现是签到, 8分钟时间一遍过. 之后 gjh 给我喂了 I 题的题意, 15分钟提交一遍过. 之后我和 mhy 去开了 G 题, 巨佬 mhy 给喂了一个关键的公式变形, 我自己按着这个变形稍微改了改一遍过. 在这之后 gjh 提出 D 题是二分. 队里没人会二分, 但昨晚某先知刚抄了二分板子. gjh 接过电脑后一遍过 D 题. 这时候我们罚时才 167, 没有榜能跟了, 因为我们就是领榜的人 ,这也给我们痛失金牌做了不少铺垫(之前没遇到过这种情况).&lt;/p&gt;
&lt;p&gt;因为之前我对计算几何比较熟悉, 我直接去开了 M 题, mhy 和 gjh 去开了 E. 这时候就稍微有点卡题, gjh 过来看了一眼 M, 一会又给我喂了一个三分的思路. 这时候 M 题已经可以说是过了. 但是我没带零点三角切分有向面积的板子, 只依稀记得公式的样子和它的推导巨长. 我推了一段时间后发现推不出来, 因此按照三分的思路换了双指针的写法, 计算面积的时候选择 b - 1 作为基, 特判了 k = 1 的情况, 没想到 WA 了一发. 一时半会没思路就把电脑让给 mhy 写 E 题了, 我在纸上找错误. 当时 mhy 提出了使用费马小定理做 E, 不过当时没人会, 就稍微写了点暴力. 当时想的是万一打个表能找到规律呢, 本地跑的挺快, 结果大胆一交 WA 了. 这时候我大概找到了 M 错误的原因, 接过电脑又改了改, 结果造错了样例浪费 20 分钟. 在这段时间队长 gjh 证明了 E 的正确性, mhy 开始改E. E 改完后mhy佬不太敢交, 我稍微改了改M题后发现交不上去, 大概找了四五分钟的原因. mhy 大胆交了一发E 后 AC 了, 我们就猜测 M 题文件名有空格导致提交失败, 修改文件名后提交就 AC了. 此时刚封榜, 还有 1 小时时间&lt;/p&gt;
&lt;p&gt;这时候之前积累的隐患就出现, 我们没有看榜单去开了 B 题, 由于代码量过大 gjh 实现不来, 而我被喂了两三遍题意才懂, 结果最后也没写完. 此时我们也没有看榜, 算着自己应该是金尾银首.直到滚榜的时候我们才发现 M 题是个金牌题, 而 L 题作为铜牌题我们甚至都没人去读. 最后草草结果以 RK 55 基本上算银首收场.&lt;/p&gt;
&lt;p&gt;说多了都是泪, 如果我带了计算几何的板子就可以高速收掉 M 去做其他题, 或者说如果有人在卡题的时候去看了 L 题, 可能就是 7 题金了. 但是叉吸劈吸没有如果, 银了就是银, 只能以后的赛事中吸取教训了.&lt;/p&gt;
&lt;p&gt;回顾往年, 大一的时候我还是对算法一无所知, 和 lmy 说的功利性不同, 我来打 XCPC 大概只是为了弥补高中时候的遗憾吧, 高中的时候我是有心去参加 oi 的, 但是苦于没有教练, 学校也不支持, 只能做罢. 而大学加入 ACM 学社只是因为热爱和高中留下的遗憾. 不知道能读到这里的人有多少, 我和其他人对 ACM 的观点不太一样, ACM 现在是比较知名的高投入低回报比赛, 而我校作为一个弱校, 训练困难, 鼓励政策也不大, 甚至可以说没有. 在这种情况下用一种功利的心态去打比赛, 我个人认为它回报很难能达到一种能令人满意的程度. 如果只是单纯为了一块牌子, 不如早早收手. 毕竟在现在的这个互联网寒冬中,过去一块牌子乱杀的时代已经一去不复返了&lt;/p&gt;
&lt;p&gt;对于我个人而言, 去年SDCPC打铁, 区域赛又铁, 现在终于能算出了点成果了. 正如蒋莉所说的, 没有什么是加训解决不了的, 如果有, 那就 all in. 这个比赛很累, 准备时间也很长, 但是如果只要网瘾程度够大, 那这个比赛还是很快乐的. 过去一年队伍聚聚散散, 干过与队友熬夜做题, 早起训练, 也试过晚上独自留在教学楼中熬夜打 cf(值得一提的是打完后给lmy发消息吐槽, 结果发现他也在熬夜打), 现在回味起来还是充满乐趣的. 到现在我也算经历了不少比赛, 感受过天赋性选手, 也在榜单上见过奋斗形选手, 被高中生吊打过, 但也曾吊打过其他大学生(虽然是在很水的赛事上). 我比较认可在我算法模板上的一句话, 但他的来源我已经找不到了: &quot;在没有结束之前, 总要做很多没有意义的事情, 这样才可以在某一天, 用这些无意义的事情去堵住那些讨厌的缺口&quot;. 可能现在我所做的是无意义的, 但总有一天它能发挥它的作用. 希望我校那些真正热爱的人能吸取我们队的教训, 做好重视平时的训练和积累, 加训, 加训, 注意练习中积累一套自己的模板和经验, 别人的模板自己用起来终究不是那么熟练.&lt;/p&gt;
&lt;p&gt;最后写点可能看起来有点像八股的话吧. 感谢现在的队长 gjh 在大一的时候作为我领路人, 感谢 h5 对我平时问题的解答, 感谢大一辅导员任楠开明的态度. 还有与我一起训练的朋友能在我心态爆炸的时候能一同吹水, lmy, xzy 和 yrh 的恶意出题让我见到世界的开阔与变化. 感谢之前一年班长 shy 的陪伴(虽然他现在已经放弃了 xcpc 而转头去做了 semantic seg 的研究). 感谢我的队友和社团成员的陪伴, 希望接下来的大学生活中大家能一同走向辉煌.&lt;/p&gt;
&lt;p&gt;比赛没拍照, 偷一张学校的宣传图. 先沉淀一个月准备期末考试, 如果网络赛能抢到名额的话, 接下来区域赛再见了.&lt;/p&gt;
&lt;p&gt;Good luck, and farewell.&lt;/p&gt;
</content:encoded><category>随笔</category><category>Competitive Programming</category><category>ICPC</category><author>Mslxl</author></item><item><title>2021 Shandong Provincial Collegiate Programming Contest</title><link>https://blog.mslxl.com/posts/cp/2021-shandong-provincial-collegiate-programming-contest/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/2021-shandong-provincial-collegiate-programming-contest/</guid><pubDate>Sat, 04 Mar 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/gym/103118&quot;&gt;比赛链接&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;C - Cat virus&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;对于一颗树, 它的节点可以被染为黑色或者白色. 如果一个节点是白色,那么她的子节点可以是白色,也可以是黑色. 如果这个节点是黑色, 那么她的子节点一定是黑色. 现在输入一个数字 $2\le K \le 2\times 10^{18}$, 根据上述方式构造一棵数, 使之不同的染色方式有 $K$ 种&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt; &lt;code&gt;构造&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;刚开始做的时候没带脑子,直接构造了一个 $(1,2), (2,3) \ldots (n-1, n)$,结果狠狠的 TLE&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;反向思考,当 $x$ 为白色的时候,它的父节点一定也为白色,而当这个节点是黑色的时候,它的父节点可以是白色,也可以是黑色.&lt;/p&gt;
&lt;p&gt;设节点 a 及其子树有 $n$ 中染色方式, 增加一节点 b 连接到 a, 有以下情况:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当 a 为黑色时, 所有节点都为黑色, 1 种染色方式&lt;/li&gt;
&lt;li&gt;当 a 为白色, b 为黑色时, 有 $n-1$ 中染色方式&lt;/li&gt;
&lt;li&gt;当 a 为白色, b 为白色时, 有 $n-1$ 中染色方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;即向一个 $n$ 种渲染方式的节点中添加一个节点, 会使其变为 $2n-1$ 种染色方式.&lt;/p&gt;
&lt;p&gt;因此我们可以构造一个树,目的是使其有 $K$ 中染色方式,当其减少最后一次添加的节点时应该有 $\frac{K+1}{2}$ 种或者 $K-1$ 染色方式,因此只需要进行深度搜索,每次搜索时判断数字的奇偶性即可.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

std::set&amp;lt;std::pair&amp;lt;int,int&amp;gt;&amp;gt; links;

int top = 1;
void dfs(int x, int cnt){
  if(cnt == 2) return;
  cnt--;
  if(cnt % 2 == 1 || cnt == 2){
    links.insert(std::make_pair(x, ++top));
    dfs(top, cnt);
  }else{
    links.insert(std::make_pair(x, ++top));
    links.insert(std::make_pair(x, ++top));
    dfs(top, cnt * 2);
  }
}

int k;
void solve(const std::size_t testcase) {
  std::cin &amp;gt;&amp;gt; k;

  std::cout &amp;lt;&amp;lt; links.size() + 1 &amp;lt;&amp;lt; &quot;\n&quot;;
  for(auto &amp;amp;item: links){
    std::cout &amp;lt;&amp;lt; item.first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; item.second &amp;lt;&amp;lt; &quot;\n&quot;;
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;D - Dyson Box&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个二维的格子中,每轮在指定位置放入一个方块, 方块会在向左的重力和向下的重力下移动. 每轮在方块移动后输出所有方块围成的总周长.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;由于 $n$ 取到 $2e5$, 很明显不能使用模拟.&lt;/p&gt;
&lt;p&gt;实际上由于方块只会进行一次移动操作,我们可以不移动方块,而是统计每个方块的贡献值.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

const int maxn = 2e5 + 17;
int cntx[maxn],cnty[maxn];
int ansx, ansy;
int main(){
    int n;
    std::cin &amp;gt;&amp;gt; n;
    for(int i = 0; i &amp;lt; n; i++){
        int x,y;
        std::cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        cntx[x]++;
        cnty[y]++;
        if(cntx[x] == 1){
            ansx+=2;
        }
        if(cntx[x-1] &amp;lt; cntx[x] &amp;amp;&amp;amp; cntx[x] &amp;gt; cntx[x+1]){
            ansx+=2;
        }else if(cntx[x-1] &amp;gt;= cntx[x] &amp;amp;&amp;amp; cntx[x] &amp;lt;= cntx[x+1]){
            ansx-=2;
        }
        if(cnty[y] == 1){
            ansy+=2;
        }
        if(cnty[y-1] &amp;lt; cnty[y] &amp;amp;&amp;amp; cnty[y] &amp;gt; cnty[y+1]){
            ansy+=2;
        }else if(cnty[y-1] &amp;gt;= cnty[y] &amp;amp;&amp;amp; cnty[y] &amp;lt;= cnty[y+1]){
            ansy-=2;
        }
        std::cout &amp;lt;&amp;lt; ansx &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; ansy &amp;lt;&amp;lt; &quot;\n&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;G - Grade Point Average&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给出科目数量和精确到的小数位数,输出平均分数&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;高精&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

int read(){
    int x=0,f=1; char ch=getchar();
    while(ch&amp;gt;&apos;9&apos;||ch&amp;lt;&apos;0&apos;){ if(ch==&apos;-&apos;){ f=-1; } ch=getchar(); }
    while(ch&amp;gt;=&apos;0&apos;&amp;amp;&amp;amp;ch&amp;lt;=&apos;9&apos;){ x=(x&amp;lt;&amp;lt;3)+(x&amp;lt;&amp;lt;1)+(ch^48); ch=getchar(); }
    return x*f;
}

int n,k;
int divide(int div){
    if(div%n==0){
        std:: cout&amp;lt;&amp;lt;div/n;
        return -1;
    }
    std:: cout&amp;lt;&amp;lt;div/n;
    return div%n;
}

int main(){
    n=read(); k=read();
    int sum=0;
    for(int i=1;i&amp;lt;=n;i++){
        int x=read();
        sum+=x;
    }
    std:: cout&amp;lt;&amp;lt;int(sum/n);
    if(k==0){
        return 0;
    }
    std:: cout&amp;lt;&amp;lt;&quot;.&quot;;
    int temp=sum%n;
    for(int i=1;i&amp;lt;=k;i++){
        temp=(temp&amp;lt;&amp;lt;3)+(temp&amp;lt;&amp;lt;1);
        temp=divide(temp);
        if(temp==-1){
            for(int j=i+1;j&amp;lt;=k;j++){
                std:: cout&amp;lt;&amp;lt;&quot;0&quot;;
            }
            return 0;
        }
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;H - Adventurer&apos;s Guild&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;Yuna 拥有 $H$ 点血量和 $S$ 点体力. 现在有 $n$ 个怪物, 每个怪物需要消耗 Yuna $h_i$ 点血量和 $s_i$ 点体力才能被击败, 同时 Yuna 能获得 $w_i$ 点金币. 当 Yuna 的体力归零后消耗体力会减少对应数量的血量. 输出 Yuna 所能获得的最大金币数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;01 背包&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;像 01 背包变形&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;递推公式:&lt;/p&gt;
&lt;p&gt;$$
f(i,H,S) = \begin{cases}
\max\{f(i-1, H, S), f(i-1, H - h_i, S - s_i) + w_i\}, S \ge s_i \\
\max\{f(i-1, H, S), f(i-1, H - h_i - (s_i - S), 0) + w_i\}, S \lt s_i
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;不过我们需要进行压维, 由于每个怪物只能打一次, 需要让 H 和 S 倒序循环&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;using ll = long long;
const int N = 1000 + 17;
const int M = 300 + 17;
ll dp[M][M];
ll n, h, s;
struct Node{
  ll h, s, w;
} a[N];
int main(){
  std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; h &amp;gt;&amp;gt; s;
  for (int i = 1; i &amp;lt;= n; i++)
    std::cin &amp;gt;&amp;gt; a[i].h &amp;gt;&amp;gt; a[i].s &amp;gt;&amp;gt; a[i].w;
  for (int i = 1; i &amp;lt;= n; i++){
    for (int j = h; j &amp;gt;= 1; j--){
      for (int k = s; k &amp;gt;= 0; k--){
        if (j &amp;gt; a[i].h &amp;amp;&amp;amp; j + k &amp;gt; a[i].s + a[i].h){
          if (k &amp;gt;= a[i].s)
            dp[j][k] = std::max(dp[j][k], dp[j - a[i].h][k - a[i].s] + a[i].w);
          else
            dp[j][k] = std::max(dp[j][k], dp[j - a[i].h - (a[i].s - k)][0] + a[i].w);
        }
      }
    }
  }
  std::cout &amp;lt;&amp;lt; dp[h][s] &amp;lt;&amp;lt; std::endl;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;M - Matrix Problem&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;给出一个 01 矩阵 C, 构造矩阵 A 和 B. 要求矩阵 A 和 B 的与运算结果为 C, 且 A 和 B 中的 1 互相联通&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;如果在 C 的对应位置为 1, 则填充1,否则 A 填充奇数行和最左侧一列, B 填充偶数行和最右侧一列.&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

int read(){
    int x=0,f=1; char ch=getchar();
    while(ch&amp;gt;&apos;9&apos;||ch&amp;lt;&apos;0&apos;){ if(ch==&apos;-&apos;){ f=-1; } ch=getchar(); }
    while(ch&amp;gt;=&apos;0&apos;&amp;amp;&amp;amp;ch&amp;lt;=&apos;9&apos;){ x=(x&amp;lt;&amp;lt;3)+(x&amp;lt;&amp;lt;1)+(ch^48); ch=getchar(); }
    return x*f;
}

const int maxn = 511;

int a[maxn][maxn];
int b[maxn][maxn];
int c[maxn][maxn];

int main(){
    int n=read(),m=read();
    for(int i=1;i&amp;lt;=n;i++){
        for(int j=1;j&amp;lt;=m;j++){
            a[i][j]=b[i][j]=c[i][j]=getchar()^48;
        }
        getchar();
    }
    for(int i=1;i&amp;lt;=n;i+=2){
        for(int j=1;j&amp;lt;m;j++){
            a[i][j]=1;
        }
    }
    for(int i=2;i&amp;lt;=n;i+=2){
        for(int j=2;j&amp;lt;=m;j++){
            b[i][j]=1;
        }
    }
    for(int i=1;i&amp;lt;=n;i++){
        a[i][1]=b[i][m]=1;
    }
    for(int i=1;i&amp;lt;=n;i++){
        for(int j=1;j&amp;lt;=m;j++){
            std:: cout&amp;lt;&amp;lt;a[i][j];
        }
        std:: cout&amp;lt;&amp;lt;std:: endl;
    }
    for(int i=1;i&amp;lt;=n;i++){
        for(int j=1;j&amp;lt;=m;j++){
            std:: cout&amp;lt;&amp;lt;b[i][j];
        }
        std:: cout&amp;lt;&amp;lt;std:: endl;
    }
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>ICPC</category><author>Mslxl</author></item><item><title>2022 International Collegiate Programming Contest Jinan Site</title><link>https://blog.mslxl.com/posts/cp/2022-international-collegiate-programming-contest-jinan-site/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/2022-international-collegiate-programming-contest-jinan-site/</guid><pubDate>Sat, 28 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/gym/104076&quot;&gt;Gym-104076&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;A - Tower&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;有 $n$ 个塔, 每个塔的高度为 $a_i$. 首先先移除其中 $m$ 个塔, 然后可以进行以下操作:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将一个塔的高度 $a_i$ 加 1&lt;/li&gt;
&lt;li&gt;将一个塔的高度 $a_i$ 减 1&lt;/li&gt;
&lt;li&gt;将一个塔的高度 $a_i$ 折半,结果向下取整&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;操作中,塔的高度不允许取 $0$, 现在要使剩下的 $n-m$ 个塔的高度相同, 问最小的操作次数.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;比较暴力的一种做法, 首先大胆猜测最终所有的塔取的结果一定是通过折半获得的,而数越大时,折半时变化越大,因此其他的元素一定是先进行折半,再进行加减操作&lt;/p&gt;
&lt;p&gt;在读入数字的时候首先将所有可能取的值存入 &lt;code&gt;std::set div2&lt;/code&gt;, 然后对每个数 $i \in div2$,求出数 $a_i$ 到 $i$ 的所需的变化次数.找到最小的即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#include &amp;lt;limits&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
   read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

#define int ll
std::vector&amp;lt;int&amp;gt; seq;
std::set&amp;lt;int&amp;gt; div2;

int gain_op_times(int num, int target){
  if(num == target){
    return 0;
  }
  if(num &amp;lt; target){
    return target - num;
  }
  int times= 0;
  while(num / 2 &amp;gt;= target){
    times++;
    num/=2;
  }
  int res = (num - target) + times;
  if(num / 2 &amp;gt; 0){
      res = std::min(res, (target - num/2) + 1 + times) ;
  }

  return res;
}

void solve(const std::size_t testcase) {
  int n, m;
  read(n, m);
  seq.resize(n);
  div2.clear();

  rep(i, n) {
    int a;
    read(a);
    seq[i] = a;
    while(a != 0){
      div2.insert(a);
      a/=2;
    }
  }

  ll ans = std::numeric_limits&amp;lt;ll&amp;gt;::max();
  for(auto target: div2) {
    std::vector&amp;lt;int&amp;gt; diff(n);
    rep(i, n) diff[i] = gain_op_times(seq[i], target);
    std::sort(diff.begin(), diff.end());
    ll cur_ans = std::accumulate(diff.begin(), diff.end() - m, 0LL);
    ans = std::min(cur_ans, ans);
  }
  std::cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;E - Identical Parity&lt;/h2&gt;
&lt;blockquote&gt;
&lt;p&gt;定义序列的 value 为该序列所有数字的和&lt;/p&gt;
&lt;p&gt;判断是否存在长度为 $n$ 的排列, 他们所有长度为 $k$ 的子段的 value 具有相同的奇偶性.&lt;/p&gt;
&lt;p&gt;输入 $T$ 表示测试样例数,对于每个样例,输入 $n$ 和 $k$ 两个数. $(1\le k \le n \le 10^9)$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt; &lt;code&gt;数学&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;当 $k$ 为偶数时,很明显可以对 &lt;code&gt;奇偶奇偶...&lt;/code&gt; 这种排列选取相同数量的奇数和偶数,因此这道题只需要考虑当 $k$ 为偶数的情况.&lt;/p&gt;
&lt;h1&gt;M - Best Carry Player&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;两个数相加，输出进行了几次进位&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;签到&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

// clang-format off
// ------------ Minify with Regex &quot;^\s*(?!#)(.*)\n&quot; -&amp;gt; &quot; &quot; ------------
template &amp;lt;class A, class B&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::pair&amp;lt;A, B&amp;gt; const &amp;amp;a) { return s &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(a) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(a) &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;gt;= sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;) {} template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;lt; sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { if (n != 0) os &amp;lt;&amp;lt; &quot;, &quot;; os &amp;lt;&amp;lt; std::get&amp;lt;n&amp;gt;(tup); print_tuple&amp;lt;n + 1&amp;gt;(os, tup); } template &amp;lt;typename... T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { os &amp;lt;&amp;lt; &quot;(&quot;; print_tuple&amp;lt;0&amp;gt;(os, tup); return os &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;print_collection(std::ostream &amp;amp;s, T const &amp;amp;a) { s &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = std::begin(a); it != std::end(a); ++it) { s &amp;lt;&amp;lt; *it; if (it != std::prev(end(a))) s &amp;lt;&amp;lt; &quot;, &quot;; } return s &amp;lt;&amp;lt; &apos;]&apos;; } template &amp;lt;class T, class U&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::map&amp;lt;T, U&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::set&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::vector&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } void __debug_out() { std::cerr &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename T, class = typename std::enable_if&amp;lt;std::is_pointer&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; void __debug_out(T beg, T end) { std::cerr &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = beg; it != end; it++) { std::cerr &amp;lt;&amp;lt; *it; if (it != std::prev(end)) { std::cerr &amp;lt;&amp;lt; &quot;, &quot;; } } std::cerr &amp;lt;&amp;lt; &apos;]&apos; &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename H, typename... Tail&amp;gt; void __debug_out(H h, Tail... T) { std::cerr &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; h; __debug_out(T...); }
#ifndef ONLINE_JUDGE
#define debug_do if(true)
#else
#define debug_do if(false)
#endif
#define debug(...) debug_do std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)
// clang-format on
void solve(const std::size_t testcase) {
  int n;
  read(n);
  std::vector&amp;lt;std::string&amp;gt; seq(n);
  rep(i, n) {
    std::cin &amp;gt;&amp;gt; seq[i];
    std::reverse(seq[i].begin(), seq[i].end());
  }

  ll ans = 0;
  auto mappend = [&amp;amp;ans](const std::string lhs,
                        const std::string rhs) -&amp;gt; std::string {
    std::string result;
    int carry = 0;
    int adv_carry = 0;
    for (int i = 0, len = std::max(lhs.size(), rhs.size()); i &amp;lt; len; i++) {
      int lnum = i &amp;lt; lhs.size() ? lhs[i] - &apos;0&apos; : 0;
      int rnum = i &amp;lt; rhs.size() ? rhs[i] - &apos;0&apos; : 0;
      if (lnum + rnum + carry &amp;gt;= 10) {
        ans++;
        carry = 1;
      } else {
        carry = 0;
      }
      result += std::to_string((lnum + rnum + adv_carry) % 10);
      adv_carry = carry;
    }
    if(adv_carry &amp;gt; 0){
        result += std::to_string(adv_carry);
    }
    return result;
  };
  std::string mempty(&quot;&quot;);
  std::reduce(seq.begin(), seq.end(), mempty, mappend);

  std::cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>ICPC</category><author>Mslxl</author></item><item><title>树形 DP 练习</title><link>https://blog.mslxl.com/posts/cp/treedp/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/treedp/</guid><pubDate>Wed, 18 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;前几天基本每场都遇到树形DP，趁此熟悉抓紧练练&lt;/p&gt;
&lt;p&gt;在网上找了个树形DP专项&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P1352&quot;&gt;P1352: 没有上司的舞会&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;热个身&lt;/p&gt;
&lt;p&gt;$$
\begin{cases}
f[i][0] = \sum_{son}{\text{ReLU}(\max{(f[son][0], f[son][1]))}}\\
f[i][1] = \sum_{son}{\text{ReLU}(f[son][0])}
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;其中 $f[i][j]$ 中的$i$表示当前节点编号，$j$ 表示是否参加舞会&lt;/p&gt;
&lt;p&gt;&lt;s&gt;加&lt;strong&gt;ReLU&lt;/strong&gt;是因为怎么有人去了还不高兴啊&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;54 行后才是代码主体&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
#include &amp;lt;limits&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

// clang-format off
template &amp;lt;std::size_t MAX_SIZE_EDGE, class TData = int&amp;gt; struct graph {
  struct node {
    int to{};
    TData data{};
    node(int t, TData d): to(t), data(d){}
  };
  std::array&amp;lt;std::list&amp;lt;node&amp;gt;, MAX_SIZE_EDGE&amp;gt; edges;

  graph() {}

  void add_edge(int u, int v, TData data = TData{}) {
    edges[u].emplace_back(v, data);
  }
  void add_biedge(int u, int v, TData data = TData{}) {
    add_edge(u, v, data), add_edge(v, u, data);
  }
  void clear() { edges.fill(std::list&amp;lt;node&amp;gt;()); }
  std::list&amp;lt;node&amp;gt; &amp;amp;from(std::size_t idx) noexcept { return (*this)[idx]; }
  std::list&amp;lt;node&amp;gt; &amp;amp;operator[](std::size_t idx) noexcept { return edges[idx]; }
};
// clang-format on

// clang-format off
// ------------ Minify with Regex &quot;^\s*(?!#)(.*)\n&quot; -&amp;gt; &quot; &quot; ------------
template &amp;lt;class A, class B&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::pair&amp;lt;A, B&amp;gt; const &amp;amp;a) { return s &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(a) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(a) &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;gt;= sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;) {} template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;lt; sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { if (n != 0) os &amp;lt;&amp;lt; &quot;, &quot;; os &amp;lt;&amp;lt; std::get&amp;lt;n&amp;gt;(tup); print_tuple&amp;lt;n + 1&amp;gt;(os, tup); } template &amp;lt;typename... T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { os &amp;lt;&amp;lt; &quot;(&quot;; print_tuple&amp;lt;0&amp;gt;(os, tup); return os &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;print_collection(std::ostream &amp;amp;s, T const &amp;amp;a) { s &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = std::begin(a); it != std::end(a); ++it) { s &amp;lt;&amp;lt; *it; if (it != std::prev(end(a))) s &amp;lt;&amp;lt; &quot;, &quot;; } return s &amp;lt;&amp;lt; &apos;]&apos;; } template &amp;lt;class T, class U&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::map&amp;lt;T, U&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::set&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::vector&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } void __debug_out() { std::cerr &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename T, class = typename std::enable_if&amp;lt;std::is_pointer&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; void __debug_out(T beg, T end) { std::cerr &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = beg; it != end; it++) { std::cerr &amp;lt;&amp;lt; *it; if (it != std::prev(end)) { std::cerr &amp;lt;&amp;lt; &quot;, &quot;; } } std::cerr &amp;lt;&amp;lt; &apos;]&apos; &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename H, typename... Tail&amp;gt; void __debug_out(H h, Tail... T) { std::cerr &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; h; __debug_out(T...); }
#ifndef ONLINE_JUDGE
#define debug_do if(true)
#else
#define debug_do if(false)
#endif
#define debug(...) debug_do std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)
// clang-format on

const int maxn = 6e3 + 17;
const int INF = std::numeric_limits&amp;lt;int&amp;gt;::max();

int n;
int r[maxn];
int fa[maxn];

graph&amp;lt;maxn&amp;gt; g;

int dp[maxn][2];

template &amp;lt;class T&amp;gt; decltype(auto) ReLU(T x) { return x &amp;gt; 0 ? x : 0; }

void dfs(int x) {
  dp[x][0] = 0;
  dp[x][1] = r[x];

  for (auto &amp;amp;[v, _] : g[x]) {
    dfs(v);
    dp[x][0] += ReLU(std::max(dp[v][0], dp[v][1]));
    dp[x][1] += ReLU(dp[v][0]);
  }

  debug(x);
  debug(dp[x][0]);
  debug(dp[x][1]);
}

void solve(const std::size_t testcase) {
  read(n);
  rep1(i, n) read(r[i]);
  rep(i, n - 1) {
    int l, k;
    read(l, k);
    g.add_edge(k, l);
    fa[l] = k;
  }

  int rt = 1;
  while (fa[rt] != 0) {
    rt = fa[rt];
  }
  debug(rt);
  dfs(rt);
  std::cout &amp;lt;&amp;lt; std::max(dp[rt][0], dp[rt][1]);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P2016&quot;&gt;P2016 战略游戏&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;s&gt;DAG也是树，对吧&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;$$
\begin{cases}
f[i][1] = \sum_{son}{\min{(f[son][0], f[son][1])}}\\
f[i][0] = \sum_{son}{f[son][1]}
\end{cases}
$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

// clang-format off
template &amp;lt;std::size_t MAX_SIZE_EDGE, class TData = int&amp;gt; struct graph {
  struct node {
    int to{};
    TData data{};
    node(int t, TData d): to(t), data(d){}
  };
  std::array&amp;lt;std::list&amp;lt;node&amp;gt;, MAX_SIZE_EDGE&amp;gt; edges;

  graph() {}

  void add_edge(int u, int v, TData data = TData{}) {
    edges[u].emplace_back(v, data);
  }
  void add_biedge(int u, int v, TData data = TData{}) {
    add_edge(u, v, data), add_edge(v, u, data);
  }
  void clear() { edges.fill(std::list&amp;lt;node&amp;gt;()); }
  std::list&amp;lt;node&amp;gt; &amp;amp;from(std::size_t idx) noexcept { return (*this)[idx]; }
  std::list&amp;lt;node&amp;gt; &amp;amp;operator[](std::size_t idx) noexcept { return edges[idx]; }
};
// clang-format on

const int maxn = 1.5e3 + 17;
int n;
graph&amp;lt;maxn&amp;gt; g;
bool vis[maxn];
int dp[maxn][2];

void dfs(int x){
  vis[x] = true;
  dp[x][1] = 1;
  dp[x][0] = 0;

  for(auto &amp;amp;[v,_]: g[x]){
    if(vis[v]) continue;
    dfs(v);
    dp[x][1] += std::min(dp[v][0], dp[v][1]);
    dp[x][0] += dp[v][1];
  }
}

void solve(const std::size_t testcase) {
  read(n);
  rep(_i, n){
    int i;
    int k;
    read(i,k);

    rep(j, k){
      int r;
      read(r);
      g.add_biedge(i, r);
    }
  }
  dfs(0);
  std::cout &amp;lt;&amp;lt; std::min(dp[0][0], dp[0][1]);

}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&lt;a href=&quot;https://atcoder.jp/contests/abc259/tasks/abc259_f?lang=en&quot;&gt;ABC259F Select Edges&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;写不出来状态转移方程&lt;/p&gt;
&lt;p&gt;使用 $dp[i][j]$ 表示第 $i$ 个节点是否与父节点相连，当 $j=0$ 时表示不相连，当 $j=1$ 时表示相连。&lt;/p&gt;
&lt;p&gt;在 dfs 时进行讨论，首先肯定要优先选择 $dp[son][1] +w[i] - dp[son][0]$ 大的边进行加边。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当 $d[son] =0$ 或 $w[i] \le 0$ 时，不进行加边，此时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$dp[i][0] += dp[son][0]$&lt;/li&gt;
&lt;li&gt;$dp[i][1] += dp[son][0]$&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当与父节点连接时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$dp[i][1] += \max (dp[v][0], dp[v][1] + w[i])$，该操作最多加$dp[v][1]+w[i]$ $d[i]-1$次&lt;/li&gt;
&lt;li&gt;$dp[i][1] += dp[v][0]$ 不能进行上述操作后&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当不与父节点相连时&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;$dp[i][0] += \max (dp[v][0], dp[v][1] + w[i])$，该操作最多加$dp[v][1]+w[i]$ $d[i]$次&lt;/li&gt;
&lt;li&gt;$dp[i][0] += dp[v][0]$ 不能进行上述操作后&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

// clang-format off
template &amp;lt;std::size_t MAX_SIZE_EDGE, class TData = int&amp;gt; struct graph {
  struct node {
    int to{};
    TData data{};
    node(int t, TData d): to(t), data(d){}
  };
  std::array&amp;lt;std::list&amp;lt;node&amp;gt;, MAX_SIZE_EDGE&amp;gt; edges;

  graph() {}

  void add_edge(int u, int v, TData data = TData{}) {
    edges[u].emplace_back(v, data);
  }
  void add_biedge(int u, int v, TData data = TData{}) {
    add_edge(u, v, data), add_edge(v, u, data);
  }
  void clear() { edges.fill(std::list&amp;lt;node&amp;gt;()); }
  std::list&amp;lt;node&amp;gt; &amp;amp;from(std::size_t idx) noexcept { return (*this)[idx]; }
  std::list&amp;lt;node&amp;gt; &amp;amp;operator[](std::size_t idx) noexcept { return edges[idx]; }
};
// clang-format on

// clang-format off
// ------------ Minify with Regex &quot;^\s*(?!#)(.*)\n&quot; -&amp;gt; &quot; &quot; ------------
template &amp;lt;class A, class B&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::pair&amp;lt;A, B&amp;gt; const &amp;amp;a) { return s &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(a) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(a) &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;gt;= sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;) {} template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;lt; sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { if (n != 0) os &amp;lt;&amp;lt; &quot;, &quot;; os &amp;lt;&amp;lt; std::get&amp;lt;n&amp;gt;(tup); print_tuple&amp;lt;n + 1&amp;gt;(os, tup); } template &amp;lt;typename... T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { os &amp;lt;&amp;lt; &quot;(&quot;; print_tuple&amp;lt;0&amp;gt;(os, tup); return os &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;print_collection(std::ostream &amp;amp;s, T const &amp;amp;a) { s &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = std::begin(a); it != std::end(a); ++it) { s &amp;lt;&amp;lt; *it; if (it != std::prev(end(a))) s &amp;lt;&amp;lt; &quot;, &quot;; } return s &amp;lt;&amp;lt; &apos;]&apos;; } template &amp;lt;class T, class U&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::map&amp;lt;T, U&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::set&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::vector&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } void __debug_out() { std::cerr &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename T, class = typename std::enable_if&amp;lt;std::is_pointer&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; void __debug_out(T beg, T end) { std::cerr &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = beg; it != end; it++) { std::cerr &amp;lt;&amp;lt; *it; if (it != std::prev(end)) { std::cerr &amp;lt;&amp;lt; &quot;, &quot;; } } std::cerr &amp;lt;&amp;lt; &apos;]&apos; &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename H, typename... Tail&amp;gt; void __debug_out(H h, Tail... T) { std::cerr &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; h; __debug_out(T...); }
#ifndef ONLINE_JUDGE
#define debug_do if(true)
#else
#define debug_do if(false)
#endif
#define debug(...) debug_do std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)
// clang-format on

#define int ll
const int maxn = 3e5 + 17;
const int maxw = 1e9;
int n;

int d[maxn];
graph&amp;lt;maxn&amp;gt; g;
bool vis[maxn];
ll dp[maxn][2];

void dfs(int x) {
  vis[x] = true;

  std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; vec;
  for (auto &amp;amp;[v, w] : g[x]) {
    if (vis[v])
      continue;
    dfs(v);
    if (d[v] == 0 || w &amp;lt;= 0) {
      dp[x][0] += dp[v][0];
      dp[x][1] += dp[v][0];
    } else {
      vec.push_back({w, v});
    }
  }

  std::sort(vec.begin(), vec.end(),
            [](const std::pair&amp;lt;int, int&amp;gt; &amp;amp;lhs, const std::pair&amp;lt;int, int&amp;gt; &amp;amp;rhs) {
              return dp[lhs.second][1] + lhs.first - dp[lhs.second][0] &amp;gt;
                     dp[rhs.second][1] + rhs.first - dp[rhs.second][0];
            });

  int cdx = 0;
  for (int i = 0; i &amp;lt; vec.size(); i++) {
    auto &amp;amp;[w, v] = vec[i];
    if (d[v] == 0)
      continue;

    if (dp[v][1] + w &amp;gt; dp[v][0]) {
      cdx++;
      if (cdx &amp;lt;= d[x] - 1) {
        dp[x][1] += dp[v][1] + w;
      } else {
        dp[x][1] += dp[v][0];
      }
      if (cdx &amp;lt;= d[x]) {
        dp[x][0] += dp[v][1] + w;
      } else {
        dp[x][0] += dp[v][0];
      }
    } else {
      dp[x][1] += dp[v][0];
      dp[x][0] += dp[v][0];
    }
  }
}

int inde[maxn];

void solve(const std::size_t testcase) {
  read(n);
  rep1(i, n) { read(d[i]); }
  rep(i, n - 1) {
    int u, v, w;
    read(u, v, w);
    g.add_biedge(u, v, w);
    inde[u]++;
  }
  int rt = std::min_element(inde + 1, inde + 1 + n) - inde;
  dfs(rt);
  std::cout &amp;lt;&amp;lt; std::max(dp[rt][0], dp[rt][1]);
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P3478&quot;&gt;P3478 [POI2008] STA-Station&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;&lt;code&gt;换根dp&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;$dp[son] = dp[fa] + (n - dp[son]) - dp[son]$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // read(t);
  std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
const int maxn = 1e6 + 17;

struct edge{
  int to,next;
}e[maxn * 2];

int head[maxn], eid = 0;

void add_edge(int u, int v){
  eid++;
  e[eid].to = v;
  e[eid].next = head[u];
  head[u] = eid;
}
void add_biedge(int u, int v){
  add_edge(u, v);
  add_edge(v, u);
}

#define int ll
int n;
int inde[maxn];
int size[maxn];
int rt = 0;
int dp[maxn];

int upd_size(int x, int fa, int dep) {
  size[x] = 1;
  int value = dep;
  for (int i = head[x]; i != 0; i = e[i].next) {
    const int v = e[i].to;
    if (v == fa)
      continue;
    value += upd_size(v, x, dep + 1);
    size[x] += size[v];
  }
  return value;
}

void dfs(int x, int fa){
  dp[x] = dp[fa] - size[x] + n - size[x] ;

  for (int i = head[x]; i != 0; i = e[i].next) {
    const int v = e[i].to;
    if(v == fa) continue;
    dfs(v, x);
  }
}

void solve(const std::size_t testcase) {
  read(n);
  rep(i, n-1) {
    int u, v;
    read(u, v);
    add_biedge(u, v);
    inde[v]++;
  }
  rt = 1;

  dp[rt] = upd_size(rt, 0, 0);

  for (int i = head[rt]; i != 0; i = e[i].next) {
    const int v = e[i].to;
    dfs(v, rt);
  }

  std::cout &amp;lt;&amp;lt; (std::max_element(dp+1, dp+1+n) - dp);
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><author>Mslxl</author></item><item><title>The 2021 ICPC Asia Shanghai Regional Programming Contest</title><link>https://blog.mslxl.com/posts/cp/2021-icpc-asia-shanghai-regional-programming-contest/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/2021-icpc-asia-shanghai-regional-programming-contest/</guid><pubDate>Mon, 16 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;上海就是神仙打架&lt;/p&gt;
&lt;p&gt;&amp;lt;table&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/gym/103446/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;
&amp;lt;center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/gym/103446/attachments/download/14828/LiyuuCute.pdf&quot;&gt;官方题解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;竟然是ppt，他真的，我哭死&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&lt;/p&gt;
&lt;h1&gt;D - Strange Fractions&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;给出整数$p$和$q$，找到两个正整数满足$\frac{p}{q} = \frac{a}{b} + \frac{b}{a}$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;数学&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;使用换元法，令$y=\frac{p}{q}, x=\frac{a}{b}$&lt;/p&gt;
&lt;p&gt;则原式等于$y=x + \frac{1}{x}$&lt;/p&gt;
&lt;p&gt;即 $x^2 - xy + 1 = 0$&lt;/p&gt;
&lt;p&gt;题目中已经给了 $y$，我们只需要找到其中一个 $x$即可。&lt;/p&gt;
&lt;p&gt;当 $\Delta=y^2-4\lt 0$时，输出 &lt;code&gt;Impossible&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;在计算过程中全程使用分数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define ll long long
using namespace std;
ll gcd(ll p,ll q){
    ll t;
    t=p;
    while(t!=0){
        t=p%q;
        p=q;
        q=t;
    }
    return p;
}
int main(){
    int index=1;
    int count=1;
    cin&amp;gt;&amp;gt;count;
    for(int i=0;i&amp;lt;count;i++){
        ll p,q;
        cin&amp;gt;&amp;gt;p&amp;gt;&amp;gt;q;
        ll t1=p*p-4*q*q;
        ll t2=sqrt(t1);
        if(t2*t2==t1)
            index=1;
        else
            index=0;
        ll gcdd=gcd(p+t2,q*2);
        if(index==0)
            printf(&quot;0 0\n&quot;);
        else{
            cout&amp;lt;&amp;lt;q*2/gcdd&amp;lt;&amp;lt;&quot; &quot;&amp;lt;&amp;lt;(p+t2)/gcdd&amp;lt;&amp;lt;endl;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;E - Strange Integers&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;给 $n$ 个整数 $A_1,A_2,\cdots,A_n$ 和整数 $k$ ，从中任选一些数字，要求任选的两个数字的差的绝对值大于 $k$ ，输出最大可选择的数字数量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;签到&lt;/code&gt; &lt;code&gt;贪心&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

#include&amp;lt;iostream&amp;gt;
// ------------ Minify with Regex &quot;^\s*(?!#)(.*)\n&quot; -&amp;gt; &quot;$1 &quot; ------------
template &amp;lt;class A, class B&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::pair&amp;lt;A, B&amp;gt; const &amp;amp;a) { return s &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(a) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(a) &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;gt;= sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;) {} template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;lt; sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { if (n != 0) os &amp;lt;&amp;lt; &quot;, &quot;; os &amp;lt;&amp;lt; std::get&amp;lt;n&amp;gt;(tup); print_tuple&amp;lt;n + 1&amp;gt;(os, tup); } template &amp;lt;typename... T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { os &amp;lt;&amp;lt; &quot;(&quot;; print_tuple&amp;lt;0&amp;gt;(os, tup); return os &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;print_collection(std::ostream &amp;amp;s, T const &amp;amp;a) { s &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = std::begin(a); it != std::end(a); ++it) { s &amp;lt;&amp;lt; *it; if (it != std::prev(end(a))) s &amp;lt;&amp;lt; &quot;, &quot;; } return s &amp;lt;&amp;lt; &apos;]&apos;; } template &amp;lt;class T, class U&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::map&amp;lt;T, U&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::set&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::vector&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } void __debug_out() { std::cerr &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename T, class = typename std::enable_if&amp;lt;std::is_pointer&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; void __debug_out(T beg, T end) { std::cerr &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = beg; it != end; it++) { std::cerr &amp;lt;&amp;lt; *it; if (it != std::prev(end)) { std::cerr &amp;lt;&amp;lt; &quot;, &quot;; } } std::cerr &amp;lt;&amp;lt; &apos;]&apos; &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename H, typename... Tail&amp;gt; void __debug_out(H h, Tail... T) { std::cerr &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; h; __debug_out(T...); }
#ifndef ONLINE_JUDGE
#define debug_do if(true)
#else
#define debug_do if(false)
#endif
#define debug(...) debug_do std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)

using ll = long long;
ll n,k;
std::vector&amp;lt;ll&amp;gt; seq;
int main(){
#define int ll
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    seq.resize(n);
    for(int i = 0; i &amp;lt; n; i++){
        std::cin &amp;gt;&amp;gt; seq[i];
    }
    std::sort(seq.begin(), seq.end());

    int r = n-1;
    int ans = 0;
    int l = n- 2;
    while(l &amp;gt;= 0){
        if(seq[r] - seq[l] &amp;gt;= k){
            ans++;
            r = l;
        }else{
            l--;
        }
    }
    std::cout &amp;lt;&amp;lt; ans + 1;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;G - Edge Group&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一个有 $n$ 个顶点 $n-1$ 条边的无向连通图，n是奇数。将其 $n-1$ 条边分为 $\frac{n-1}{2}$ 组，满足下列约束条件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;每组中只有两个边&lt;/li&gt;
&lt;li&gt;一组中的两个边有一个公共顶点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;输出分组方案模 $998244353$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;树形dp&lt;/code&gt; &lt;code&gt;组合数学&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先考虑 $n$ 个边两两分组的情况。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果 $n$ 是奇数，多出来的$1$条边肯定要和父节点上的边进行配对，也就是 $n-1$ 条边相互配对，剩下一条和父节点的配对。&lt;/li&gt;
&lt;li&gt;如果 $n$ 是偶数，那么这些边就要两两相互配对&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当 $n$ 为偶数的时候我们需要考虑两两分组有几种情况。&lt;/p&gt;
&lt;p&gt;考虑$n=2$有1种分法，$n=4$ 时，新加的两个边中的一条边必须和之前的两个边之一配对，要么和另一个新加的边配对，一个有 $(2+1)\times f(1)$ 种分法。推广到 $f(n) = (n-1)\times f(n-2)$。即 $f(n) = (n-1)!!$&lt;/p&gt;
&lt;p&gt;那么现在就可以得出转移方程:设 k 为子树中奇儿子的数量。&lt;/p&gt;
&lt;p&gt;$$
dp[i]=\begin{cases}
(k-1)!! \cdot \prod dp[son] \\
k!! \cdot \prod dp[son]
\end{cases}
$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// 自分の得意な言語で
// Let&apos;s チャレンジ！！

// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

const int maxn =  1e5 + 17;
ll dp[maxn];
ll size[maxn];
std::vector&amp;lt;int&amp;gt; g[maxn];

const int modd = 998244353;

int n;

void dfs(int u, int fa){
  int cnt = 0;
  dp[u] = 1;
  for(auto v: g[u]){
    if(v == fa) continue;
    dfs(v,u);
    if(size[v] % 2 == 0){
      size[u]++;
    }
    dp[u] = dp[u] * dp[v] % modd;
  }

  for(int i = 1; i &amp;lt;= size[u]; i+=2){
    dp[u] = dp[u] * i % modd;
  }

}

void solve(const std::size_t testcase) {
  std::cin &amp;gt;&amp;gt; n;
  rep1(i, n-1){
    int a,b;
    std::cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
    g[a].push_back(b);
    g[b].push_back(a);
  }

  dfs(1,0);
  std::cout &amp;lt;&amp;lt; dp[1];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;I - Steadily Growing Steam&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;有 $n$ 张牌，每张牌具有一个点数 $t_i$ 和一个价值 $v_i$ 共两个属性。选择 $\le k$ 张牌，将其点数扩大一倍，然后将这 $n$ 种牌分为两部分，要求两部分的点数和相等，求最大的价值和。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;背包DP&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;先不考虑 $k$ 次扩大，只考虑 $n$ 张牌分为两部分。&lt;/p&gt;
&lt;p&gt;可以用 $dp[i][j]$ 表示考虑前 $i$ 个物品时，$\sum t_i$ = j时所取的$\sum v_i$&lt;/p&gt;
&lt;p&gt;考虑 $k$ 次扩大之后可以用 $dp[i][j][k]$ 表示考虑前 $i$ 个物品时，执行了$k$次扩大操作后，$\sum t_i = j$ 时所取的 $\sum v_i$ 值&lt;/p&gt;
&lt;p&gt;&lt;s&gt;不是&lt;/s&gt;很明显&lt;/p&gt;
&lt;p&gt;$$
dp[i][j][k] =  \begin{cases}
dp[i-1][j][k] \text{不选择第} i \text{个物品} \\
dp[i-1][j-t_i][k] \text{选择第} i \text{个物品，不翻倍} \\
dp[i-1][j+t_i][k] \text{选择第} i \text{个物品，不翻倍，放到另一堆（即约为选择负的）} \\
dp[i-1][j-t_i\times 2][k-1] \text{选择第} i \text{个物品，翻倍} \\
dp[i-1][j+t_i\times 2][k-1] \text{选择第} i \text{个物品，翻倍，放到另一堆（即约为选择负的）} \\
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;额外处理一下 $j$ 维的负数问题即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

using namespace std;
const int N = 103;
using ll = long long;
ll f[N][3003][N], w[N], v[N];
int main() {
  memset(f, -0x3f, sizeof f);
  f[0][1300][0] = 0;
  int n, m;
  cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
  for (int i = 1; i &amp;lt;= n; i++)
    scanf(&quot;%lld%lld&quot;, &amp;amp; w[i], &amp;amp; v[i]);
  for (int i = 1; i &amp;lt;= n; i++)
    for (int j = 0; j &amp;lt;= m; j++)
      for (int k = 0; k &amp;lt;= 2600; k++) {
        f[i][k][j] = f[i - 1][k][j];
        if (k &amp;gt;= 2 * v[i] &amp;amp;&amp;amp; j &amp;gt;= 1)
          f[i][k][j] = max(f[i][k][j], f[i - 1][k - 2 * v[i]][j - 1] + w[i]);
        if (k &amp;gt;= v[i])
          f[i][k][j] = max(f[i][k][j], f[i - 1][k - v[i]][j] + w[i]);
        if (k + 2 * v[i] &amp;lt;= 2600 &amp;amp;&amp;amp; j &amp;gt;= 1)
          f[i][k][j] = max(f[i][k][j], f[i - 1][k + 2 * v[i]][j - 1] + w[i]);
        if (k + v[i] &amp;lt;= 2600)
          f[i][k][j] = max(f[i][k][j], f[i - 1][k + v[i]][j] + w[i]);
      }
  ll ans = -0x3f3f3f3f;
  for (int i = 0; i &amp;lt;= m; i++)
    ans = max(ans, f[n][1300][i]);
  cout &amp;lt;&amp;lt; ans;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>ICPC</category><author>Mslxl</author></item><item><title>2020-2021 ACM ICPC Asia Nanjing Regional Contest</title><link>https://blog.mslxl.com/posts/cp/2020-2021-icpc-nanjing/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/2020-2021-icpc-nanjing/</guid><pubDate>Sat, 14 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&amp;lt;table&amp;gt;
&amp;lt;tr&amp;gt;
&amp;lt;td&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://codeforces.com/gym/102992/&quot;&gt;题目链接&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/td&amp;gt;
&amp;lt;td&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://zhuanlan.zhihu.com/p/338249705&quot;&gt;官方题解&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/td&amp;gt;
&amp;lt;/tr&amp;gt;
&amp;lt;/table&amp;gt;&lt;/p&gt;
&lt;h1&gt;A - Ah, It’s Yesterday Once More&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;构造一张二维地图，仅有墙壁和空白组成。在每个空白处都有一个人，每个人在接下来的 50000 步中将向一个方向随机移动。
要求构造的地图必须小于 $20\times 20$，至少有两个空白，每个空白之前必须是相互可达的，不能有环，50000步后所有的人$25%$的可能性不在同一个格子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;构造&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;很奇怪的一道题，练习的时候莫名其妙的就 A 了。&lt;/p&gt;
&lt;p&gt;由于题目并没有输入数据，所有的人的行动数据都是随机的。很明显按照题目的意思，答案可以是固定的，没必要在程序中生成。而且路线长什么样子没什么关系（因为人的行动完全随机）。
只要保证人尽可能的多，路线尽可能的长就行。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;然后在 cf 上交了个 PHP 莫名其妙的就 A 了。&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;20 20
11111101111101111101
10010110010110010111
01011011011011011001
11101101101101101101
10110110110110110110
11011011011011011011
01101101101101101101
10110110110110110111
10011011011011011001
11101101101101101101
10110110110110110110
11011011011011011011
01101101101101101101
10110110110110110111
10011011011011011001
11101101101101101101
10110110110110110110
11011011011011011011
01001101001101001101
11110111110111110111
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;D - Drgree of Spanning Tree&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;给一个无向联通图，有$n$个定点$m$条边。找到一颗生成树，使得这个生成树的每个顶点的度数不大于$\frac{n}{2}$&lt;/p&gt;
&lt;p&gt;注意可能有自环或者重边&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;图论&lt;/code&gt; &lt;code&gt;并查集&lt;/code&gt; &lt;code&gt;思维&lt;/code&gt; &lt;code&gt;生成树&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;训练的时候没做出来&lt;/s&gt; &lt;s&gt;现在某种意义上我是抄的这个题解&lt;a href=&quot;https://blog.csdn.net/weixin_45697774/article/details/114681396&quot;&gt;Degree of Spanning Tree&lt;/a&gt;&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;CF上有一道相似的题目（还更麻烦点）&lt;a href=&quot;https://codeforces.com/problemset/problem/1133/F2&quot;&gt;Codeforces 1133F2&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;假如我们现在有这样一张图和它的一个生成树&lt;/p&gt;
&lt;p&gt;我们想要降低顶点 $1$ 的度&lt;/p&gt;
&lt;p&gt;&amp;lt;center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2020njd1.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2020njd2.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;太难看了，我们重新整理一下&lt;/p&gt;
&lt;p&gt;&amp;lt;center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2020njd3.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;之后我们将$1$作为根，使用并查集标记它的所有子树&lt;/p&gt;
&lt;p&gt;&amp;lt;center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2020njd4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;依次遍历原图中所有的边，如果这个边不是和根直接相连的，而且又连接了两个不同的子树，那么我们可以试图将这条边加入生成树中，并移除根与其中一个字树的联系。&lt;/p&gt;
&lt;p&gt;这里我们选择$(2,4)$边&lt;/p&gt;
&lt;p&gt;&amp;lt;center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2020njd5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;显然，新连接的边的定点不符合题意。我们可以反过来试一下（这里没有这个必要，但是部分情况可能会用到这个操作）&lt;/p&gt;
&lt;p&gt;我们连接$(2,4)$时，不再断开$(1,2)$，而是断开$(1,4)$&lt;/p&gt;
&lt;p&gt;&amp;lt;center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2020njd6.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;连接$(2,4)$边的两种方式都不符合要求，现在应该恢复到未连接$2-4$前的状态，继续尝试选择其他边&lt;/p&gt;
&lt;p&gt;&amp;lt;center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2020njd4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;接下来尝试$(3,4)$也不行，直到我们选择$(2,3)$&lt;/p&gt;
&lt;p&gt;&amp;lt;center&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2020njd7.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/center&amp;gt;&lt;/p&gt;
&lt;p&gt;通过这种操作，我们将$1$的度数降低了$1$&lt;/p&gt;
&lt;p&gt;类似的，这道题我们也可以采用这种方式。树我们可以随便生成一个，而其中度数大于$\frac{n}{2}$的定点只会有一个。&lt;/p&gt;
&lt;p&gt;我们只需要将这个顶点作为根，重复上面的操作即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

const int maxn = 2e5 + 10;

std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt; es;
std::map&amp;lt;std::pair&amp;lt;int, int&amp;gt;, int&amp;gt; mp;

// 存生成树用的()
struct Edge {
  int to;
  int next;
} edges[maxn &amp;lt;&amp;lt; 2];

int head[maxn], idx;
int deg[maxn];

void add(int u, int v) {
  edges[idx] = {v, head[u]};
  head[u] = idx++;
  edges[idx] = {u, head[v]};
  head[v] = idx++;
}

int pre[maxn];
int chose[maxn];

// 并查集
int fi(int x) { return x == pre[x] ? x : pre[x] = fi(pre[x]); }

void dfs(int u, int fa, int sig) {
  pre[u] = sig;
  for (int i = head[u]; ~i; i = edges[i].next) {
    int v = edges[i].to;
    if (v == fa)
      continue;
    dfs(v, u, sig);
  }
}

// 多测清数据
void init(int n, int m) {
  mp.clear();
  es.clear();
  for (int i = 0; i &amp;lt;= n; i++) {
    head[i] = -1;
    deg[i] = 0;
    pre[i] = i;
  }

  for (int i = 0; i &amp;lt;= m; i++) {
    chose[i] = 0;
  }
  idx = 0;
}

void solve(const std::size_t testcase) {
  int n, m;
  read(n, m);
  init(n, m);
  for (int i = 0; i &amp;lt; m; i++) {
    int u, v;
    read(u, v);
    if (u &amp;gt; v)
      std::swap(u, v);
    es.push_back({u, v});
  }
  std::sort(es.begin(), es.end());
  es.erase(std::unique(es.begin(), es.end()), es.end()); // 删除重边
  m = int(es.size());
  // 使用并查集建立生成树
  for (int i = 0; i &amp;lt; m; i++) {
    int u = es[i].first;
    int v = es[i].second;
    mp[{u, v}] = mp[{v, u}] = i;
    int fu = fi(u), fv = fi(v);
    if (fu != fv) {
      add(u, v);
      pre[fu] = fv;
      deg[u]++;
      deg[v]++;
      chose[i] = 1;
    }
  }

  // 不连通直接输出 NO
  int flag = 0;
  for (int i = 2; i &amp;lt;= n; i++) {
    if (fi(i) != fi(1))
      flag = 1; // 不连通
  }
  if (flag) {
    std::cout &amp;lt;&amp;lt; &quot;No\n&quot;;
    return;
  }

  // 如果所有的度数都小于n/2，那么不需要调整，直接输出答案
  int rt = -1;
  for (int i = 1; i &amp;lt;= n; i++) {
    if (deg[i] &amp;gt; n / 2) {
      rt = i;
      break;
    }
  }
  if (rt == -1) {
    std::cout &amp;lt;&amp;lt; &quot;Yes\n&quot;;
    for (int i = 0; i &amp;lt; m; i++) {
      if (chose[i]) {
        std::cout &amp;lt;&amp;lt; es[i].first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; es[i].second &amp;lt;&amp;lt; &quot;\n&quot;;
      }
    }
    return;
  }

  // 以rt为根，将其所有的子树加到一个集合里
  for (int i = 1; i &amp;lt;= n; i++)
    pre[i] = i;
  for (int i = head[rt]; ~i; i = edges[i].next) {
    dfs(edges[i].to, rt, edges[i].to);
  }
  for (int i = 0; i &amp;lt; m; i++) {
    if (chose[i])
      continue; // 这条边在当前生成树中已存在，跳过
    int u = es[i].first, v = es[i].second;
    int fu = fi(u), fv = fi(v);
    if (u == rt || v == rt)
      continue; // 这是和根相连的点，要么已使用，要么添加后会增加度数
    if (fu == fv)
      continue; // 这条边的两顶点同属于一棵子树，使用只会增加度数

    // 用u-v边替换掉rt-fu边
    deg[rt]--;
    deg[u]++;
    deg[v]++;
    deg[fu]--;

    if (deg[u] &amp;gt; n / 2 || deg[v] &amp;gt; n / 2) { // 添加u-v边后，u,v两节点是否不合法
      // 原本从 rt-fv 连接子树，换成 rt-fu
      deg[fu]++;
      deg[fv]--;
      if (deg[u] &amp;gt; n / 2 || deg[v] &amp;gt; n / 2) {
        // u-v 仍不合法，把原来的边恢复，再去尝试另一条连接两颗子树的边
        deg[rt]++;
        deg[u]--;
        deg[v]--;
        deg[fv]++;
        continue;
      } else {
        // u -v 合法，也就是说成功把根的度数降低了1
        pre[fv] = fu;
        chose[i] = 1;
        chose[mp[{rt, fv}]] = 0;
      }
    } else {
      // u -v 合法，也就是说成功把根的度数降低了1
      pre[fu] = fv;
      chose[i] = 1;
      chose[mp[{rt, fu}]] = 0;
    }
    if(deg[rt] &amp;lt;= n/2) break; //如果现在根的度数满足要求，就不需要继续进行了
  }
  if(deg[rt] &amp;lt;= n/2){
    std::cout &amp;lt;&amp;lt; &quot;Yes\n&quot;;
    for(int i = 0 ; i&amp;lt; m; i++){
      if(chose[i]){
        std::cout &amp;lt;&amp;lt; es[i].first &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; es[i].second &amp;lt;&amp;lt; &quot;\n&quot;;
      }
    }

  }else{
    std::cout &amp;lt;&amp;lt; &quot;No\n&quot;;
  }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;E - Evil Coordinate&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;机器人从$(0,0)$ 出发，地图上在 $(m_x,m_y)$ 位置有地雷。问机器人完成所有指定指令后，是否不会踩到地雷。
所有的指令顺序可以打乱。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt; &lt;code&gt;模拟&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;还是挺无脑的暴力的。&lt;/p&gt;
&lt;p&gt;一共就 $UDLR$ 四种移动方式，先完成其中的一种，再完成另一种，如果触碰地雷就将完成循序调换一下，很容易得出结果。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

int mx, my;
int ex, ey;
std::string route;

void solve() {
    std::cin &amp;gt;&amp;gt; mx &amp;gt;&amp;gt; my &amp;gt;&amp;gt; route;
    ex = ey = 0;
    int op[4] = {0, 0, 0, 0};
    for (int i = 0, len = route.size(); i &amp;lt; len; i++) {
        if (route[i] == &apos;U&apos;) {
            ey++;
            op[0]++;
        } else if (route[i] == &apos;D&apos;) {
            ey--;
            op[1]++;
        } else if (route[i] == &apos;L&apos;) {
            ex--;
            op[2]++;
        } else if (route[i] == &apos;R&apos;) {
            ex++;
            op[3]++;
        }
    }
    if ((ex == mx &amp;amp;&amp;amp; ey == my) || (mx == 0 &amp;amp;&amp;amp; my == 0)) {
        std::cout &amp;lt;&amp;lt; &quot;Impossible\n&quot;;
        return;
    }
    std::vector&amp;lt;int&amp;gt; flow = {0, 1, 2, 3};
    bool reachable = false;
    do {
        int x = 0, y = 0;
        for (auto cur_op: flow) {
            if(cur_op == 0){
                // U
                for(int t = 0; t &amp;lt; op[cur_op]; t++){
                    y++;
                    if(x == mx &amp;amp;&amp;amp; y == my){
                        goto outter;
                    }
                }
            }else if(cur_op == 1){
                // D
                for(int t = 0; t &amp;lt; op[cur_op]; t++){
                    y--;
                    if(x == mx &amp;amp;&amp;amp; y == my){
                        goto outter;
                    }
                }
            }else if(cur_op == 2){
                // L
                for(int t = 0; t &amp;lt; op[cur_op]; t++){
                    x--;
                    if(x == mx &amp;amp;&amp;amp; y == my){
                        goto outter;
                    }
                }
            }else if(cur_op == 3){
                // R
                for(int t = 0; t &amp;lt; op[cur_op]; t++){
                    x++;
                    if(x == mx &amp;amp;&amp;amp; y == my){
                        goto outter;
                    }
                }
            }
        }
        reachable = true;
        break;

        outter:
        int _unused;
    } while (std::next_permutation(flow.begin(), flow.end()));
    if(reachable){
        for(auto cur_op: flow){
            for(int t = 0; t &amp;lt; op[cur_op]; t++){
                if(cur_op == 0){
                    std::cout &amp;lt;&amp;lt; &quot;U&quot;;
                }else if(cur_op == 1){
                    std::cout &amp;lt;&amp;lt; &quot;D&quot;;
                }else if(cur_op == 2){
                    std::cout &amp;lt;&amp;lt; &quot;L&quot;;
                }else if(cur_op == 3){
                    std::cout &amp;lt;&amp;lt; &quot;R&quot;;
                }
            }
        }
        std::cout &amp;lt;&amp;lt; &quot;\n&quot;;
    }else{
        std::cout &amp;lt;&amp;lt; &quot;Impossible\n&quot;;
    }
}

int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);

    int t;
    std::cin &amp;gt;&amp;gt; t;
    while (t--) {
        solve();
    }
    return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;F - Fireworks&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;Kotori $n$ 分钟能制作一个烟花，每个烟花只有 $p \times 10^{-4}$的可能性成功。当她制作完一个烟花后可以选择再做一个，或者消耗$m$分钟将之前制作的烟花燃放。
如果燃放的烟花中有一个成功， Kotori 就会停止燃放，否则她就会继续燃放。求最优策略下塔停止燃放眼花的最小期望时间，&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;三分&lt;/code&gt; &lt;code&gt;概率&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;设 Kotori 燃放 $k$ 次烟花，那么至少一次燃放成功的概率为 $1- (1-p)^k$，其期望为 $E(k)=\frac{1}{1-(1-p)^k}$&lt;/p&gt;
&lt;p&gt;那么用时期望为 $(k\times n + m) \times E(k) = \frac{nk+m}{1 - (1-p)^k}$&lt;/p&gt;
&lt;p&gt;&lt;s&gt;之后盲猜这是一个凹函数&lt;/s&gt;，用三分法求解:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

using ld =  double;
using ll =  long;

ld qpow(ld a, ll b)
{
    ld ans = 1;
    ld base = a;
    while(b &amp;gt; 0)
    {
        if(b &amp;amp; 1)
            ans *= base;

        base *= base;
        b &amp;gt;&amp;gt;= 1;
    }
    return ans;
}
ld n, m, p;

ld calc(ll k) {
    return  (k * n + m) / (1 - qpow(1 - p, k));
}

void solve() {
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m &amp;gt;&amp;gt; p;
    p /= 1e4;
    ll l = 1, r = std::numeric_limits&amp;lt;int&amp;gt;::max() / 3 * 2;
    while (l &amp;lt; r) {
        ll mid1 = l + (r - l) / 3;
        ll mid2 = r - (r - l) / 3;
        if(calc(mid1) &amp;lt; calc(mid2)) r = mid2 - 1;
        else l = mid1 + 1;
    }
    std::cout &amp;lt;&amp;lt; calc(l) &amp;lt;&amp;lt; &quot;\n&quot;;
}

int main() {
    int T;
    std::cin &amp;gt;&amp;gt; T;
    std::cout &amp;lt;&amp;lt; std::setprecision(5) &amp;lt;&amp;lt; std::fixed;
    while (T--) {
        solve();
    }
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;H - Harmonious Rectangle&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;定义一个和谐矩阵为存在以下任意一种染色的矩阵 $1\le x_1 \lt x_2 \le n, 1 \le y_1 $&lt;/p&gt;
&lt;p&gt;$$
\begin{cases}
color(x_1, y_1) = color(x_1, y_2) \\
color(x_2, y_1) = color(x_2, y_2)
\end{cases}\text{或}
\begin{cases}
color(x_1, y_1) = color(x_2, y_1) \\
color(x_1, y_2) = color(x_2, y_2)
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;输入一个 $n$和$m$，表示矩阵的长和宽。在上面用红，蓝，黄涂色。输出有多少种染色方式存在和谐矩阵。&lt;/p&gt;
&lt;p&gt;结果对 $10^9 + 7$ 取模&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;鸽笼原理&lt;/code&gt; &lt;code&gt;打表&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;首先当 $n=1$ 或者 $m=1$ 时，根据样例，肯定无解。&lt;/p&gt;
&lt;p&gt;当$n=2,m=1$时，共有$9$种组合，也就是说当$m\gt9$时一定存在和谐矩阵。&lt;/p&gt;
&lt;p&gt;进一步推广，也就是当$max(n,m)\gt 9$时一定存在和谐矩阵。我们只需要对$max(n,m)\le 9$的情况打表即可&lt;/p&gt;
&lt;p&gt;然而刚开始没想范围写了个暴力，结果太慢了&lt;/p&gt;
&lt;p&gt;&lt;s&gt;正好拿来对拍&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;def check(map) -&amp;gt; bool:
    for x in range(len(map)):
        for y in range(len(map[x])):

            for w in range(x+1, len(map)):
                for h in range(y+1, len(map[x])):

                    if map[x][y] == map[w][y] and map[x][h] == map[w][h]:
                        return True
                    elif map[x][y] == map[x][h] and map[w][y] == map[w][h]:
                        return True
    return False

map = [[None for i in range(9)] for j in range(9)]

def zero(n, m):
    return [[0 for i in range(n)] for j in range(m)]

def is_end(map) -&amp;gt; bool:
    for y in map:
        for x in y:
            if x != 2:
                return False
    return True

def inc(map):
    map[0][0] += 1
    for i in range(len(map)):
        for j in range(len(map[i])):
            if map[i][j] &amp;gt; 2:
                map[i][j] = 0
                if j+1 == len(map[i]):
                    if i+1 != len(map):
                        map[i+1][0] += 1
                else:
                    map[i][j+1] += 1

with open(&quot;H.txt&quot;, &quot;w&quot;) as f:
    f.write(&quot;{&quot;)
    for m in range(1, 10):
        f.write(&quot;{&quot;)
        for n in range(1, 10):
            ans = 0
            map = zero(n, m)
            print(str(len(map)) + &quot;,&quot; + str(len(map[0])))
            if check(map):
                ans += 1
            while True:
                inc(map)
                if check(map):
                    ans += 1
                if is_end(map):
                    break
            print(ans)
            f.write(str(ans))
            if n != 9:
                f.write(&quot;,&quot;)
        if m != 9:
            f.write(&quot;,&quot;)
        f.write(&quot;}&quot;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;修改之后成了这样子：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

const int MODD = 1e9 + 7;
const int MAXN = 12;
using ll = long long;

template &amp;lt;typename A, typename BaseT&amp;gt;
typename std::enable_if&amp;lt;std::is_integral&amp;lt;BaseT&amp;gt;::value, A&amp;gt;::type
qpow(A a, BaseT n, BaseT modd) {
  decltype(a) ans = 1;
  while (n) {
    if (n &amp;amp; 1)
      ans = (ans * a) % modd;
    n &amp;gt;&amp;gt;= 1;
    a = (a * a) % modd;
  }
  return ans % modd;
}

int a[MAXN][MAXN];
int m, n;
ll gcnt;

void dfs(int xx, int yy) {
  for (int color = 0; color &amp;lt; 3; color++) {
    int x2 = xx;
    int y2 = yy;
    a[y2][x2] = color;
    bool flag = true;
    for (int y1 = 0; y1 &amp;lt; y2 &amp;amp;&amp;amp; flag; y1++) {
      for (int x1 = 0; x1 &amp;lt; x2 &amp;amp;&amp;amp; flag; x1++) {
        if ((a[y1][x1] == a[y2][x1] &amp;amp;&amp;amp; a[y1][x2] == a[y2][x2]) ||
            (a[y1][x1] == a[y1][x2] &amp;amp;&amp;amp; a[y2][x1] == a[y2][x2])) {
          flag = false;
          gcnt += qpow(3LL, (n - 1 - y2) * m + (m - 1) - x2, MODD);
          gcnt %= MODD;
        }
      }
    }
    if (flag) {
      x2++;
      if (x2 &amp;gt;= m) {
        x2 = 0;
        y2++;
        if (y2 &amp;gt;= n) {
          continue;
        }
      }
      dfs(x2, y2);
    }
  }
  a[yy][xx] = -1;
}

int solve() {
  gcnt = 0;
  dfs(0, 0);
  return gcnt;
}

int main() {
  std::ofstream os(&quot;H.txt&quot;);

  for (n = 1; n &amp;lt;= 9; n++) {
    os &amp;lt;&amp;lt; &quot;{&quot;;
    for (m = 1; m &amp;lt;= 9; m++) {
      std::cout &amp;lt;&amp;lt; n &amp;lt;&amp;lt; &quot;x&quot; &amp;lt;&amp;lt; m &amp;lt;&amp;lt; &quot;\n&quot;;
      if (std::min(n, m) == 1) {
        os &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &quot;,&quot;;
        continue;
      } else {
        std::memset(a, 0, sizeof(a));
        os &amp;lt;&amp;lt; solve();
        if (m != 9) {
          os &amp;lt;&amp;lt; &quot;,&quot;;
        }
      }
    }
    os &amp;lt;&amp;lt; &quot;}&quot;;
    if (n != 9) {
      os &amp;lt;&amp;lt; &quot;,\n&quot;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;AC 代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

template&amp;lt;typename A, typename BaseT&amp;gt;
typename std::enable_if&amp;lt;std::is_integral&amp;lt;BaseT&amp;gt;::value, A&amp;gt;::type
qpow(A a, BaseT n, BaseT modd){
    decltype(a) ans = 1;
    while (n){
        if (n &amp;amp; 1) ans = (ans * a) % modd;
        n &amp;gt;&amp;gt;= 1;
        a = (a * a) % modd;
    }
    return ans % modd;
}

using ll = long long;
int map[][9] = {
{0,0,0,0,0,0,0,0,0,},
{0,15,339,4761,52929,517761,4767849,43046721,387420489},
{0,339,16485,518265,14321907,387406809,460338013,429534507,597431612},
{0,4761,518265,43022385,486780060,429534507,792294829,175880701,246336683},
{0,52929,14321907,486780060,288599194,130653412,748778899,953271190,644897553},
{0,517761,387406809,429534507,130653412,246336683,579440654,412233812,518446848},
{0,4767849,460338013,792294829,748778899,579440654,236701429,666021604,589237756},
{0,43046721,429534507,175880701,953271190,412233812,666021604,767713261,966670169},
{0,387420489,597431612,246336683,644897553,518446848,589237756,966670169,968803245}
};
#define int ll

const int modd = 1e9 + 7;
void solve() {
  int n, m;
  std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; m;
  if (n &amp;gt; m)
    std::swap(n, m);
  if(n == 1) {
    std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &quot;\n&quot;;
    return;
  }
  if(m &amp;gt; 9){
    int result = qpow(3LL, n * m, modd);
    std::cout &amp;lt;&amp;lt; result &amp;lt;&amp;lt; &quot;\n&quot;;
  }else{
    std::cout &amp;lt;&amp;lt; map[n-1][m-1]%modd &amp;lt;&amp;lt; &quot;\n&quot;;
  }
}

#undef int
int main() {
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);

  int T;
  std::cin &amp;gt;&amp;gt; T;
  while (T--) {
    solve();
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;K - K Co-prime Permutation&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;$k$ co-prime 排列是指排列中有 $k$ 个数字 $a_i$ 和 $i$ 互质。&lt;/p&gt;
&lt;p&gt;输入序列长度 $n$ 和 $k$, 构造这样的排列&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt; &lt;code&gt;签到&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;一个数和他相邻的数互质，我们只需要将$k$个数错开一位就行。&lt;/p&gt;
&lt;p&gt;直接调库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

int main() {
#define int long long
    int n, k;
    std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
    if(k == 0) {
        std::cout &amp;lt;&amp;lt; -1;
        return 0;
    }
    if(n == 1){
        std::cout &amp;lt;&amp;lt; 1;
        return 0;
    }
    std::vector&amp;lt;int&amp;gt; seq(n);
    for(int i = 0; i &amp;lt; n; i++){
        seq[i] = i+1;
    }
    std::rotate(seq.begin(), seq.begin() + 1, seq.end() - (n-k));
    for(int i = 0; i &amp;lt; n ; i++){
        std::cout &amp;lt;&amp;lt; seq[i] &amp;lt;&amp;lt; &quot; &quot;;
    }

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;L - Let&apos;s Play Curling&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;红队 n 个冰壶、蓝队 m 个冰壶，给出所有冰壶的坐标，找到一个位置 c 使得红队能赢且得分尽可能多，若红队能赢输出最多能得到的分数，若红队不能赢输出 Impossible。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;思维&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;红队得分的条件是红队的冰壶离中心点$c$比蓝队近，所以这个题可以转化成任意相邻的两个烂队冰壶之间最多有几个红队的冰壶。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;

using ll = long long;
using ul = unsigned long long;
using ld = long double;

template&amp;lt;typename T&amp;gt;
inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x) {
    char c;
    T f = 1;
    while (!isdigit(c = getchar())) if (c == &apos;-&apos;)f = -1;
    x = (c &amp;amp; 15);
    while (isdigit(c = getchar())) x = (x &amp;lt;&amp;lt; 1) + (x &amp;lt;&amp;lt; 3) + (c &amp;amp; 15);
    x *= f;
}

template&amp;lt;typename T, typename... A&amp;gt;
inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }

void solve(const std::size_t testcase);

#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)

int main() {
    std::size_t t = 1;
    read(t);
    // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
    rep1(i, t) solve(t);
    return 0;
}
// clang-format on
#define int ll

const int INF = std::numeric_limits&amp;lt;int&amp;gt;::max();

const int maxn = 1e5 + 17;
int n, m;
int blue[maxn], red[maxn];

void solve(const std::size_t testcase) {
    read(n, m);
    rep1(i, n) read(red[i]);
    rep1(i, m) read(blue[i]);
    std::sort(red + 1, red + n + 1);
    std::sort(blue + 1, blue + m + 1);
    blue[m + 1] = INF;
    ll ans = 0;
    rep(i, m + 1) {
        int l = std::upper_bound(red + 1, red + n + 1, blue[i]) - (red + 1) + 1;
        int r = std::lower_bound(red + 1, red + n + 1, blue[i + 1]) - (red + 1) + 1 - 1;
        if (red[l] &amp;lt;= blue[i] || red[r] &amp;gt;= blue[i + 1]) continue; // for duplicated element
        ans = std::max(ans, r - l + 1);
    }
    if (ans != 0) {
        std::cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &quot;\n&quot;;
    } else {
        std::cout &amp;lt;&amp;lt; &quot;Impossible\n&quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;M - Monster Hunter&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;在一个根节点为 $1$ 的有$n$个定点的有根树，每个顶点都有一个怪物，第$i$个顶点上的怪物有$hp_i$滴血。现在要按照下列规则杀死所有怪物&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;当一个顶点的直接父节点上的怪物被杀死时，这个节点上的怪物才能被杀死&lt;/li&gt;
&lt;li&gt;杀死第 $i$ 个节点上的怪物需要消耗的能量为第$i$个节点上的怪物$hp_i$和这个节点的所有直接子节点上的存活的怪物的$hp$总和，即消耗的能量为&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;$$
hp_i + \sum_{\begin{array}{c}\text{顶点} j \text{上的怪物是\textbf{存活}状态} \\ \text{且} i \text{的直接子节点是} j \end{array}} hp_j
$$&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用魔咒消耗$0$能量，且无视上述限制，杀死选择的怪物。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当符卡数量 $m=0,1,2,\ldots,n$ 时，输出杀死所有怪物所需消耗的最小能量&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;树形背包&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;很喜欢yrh说过的一句话，“不会dp”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一开始想着倒着进行贪心，贪着贪着就挂了。&lt;/p&gt;
&lt;p&gt;正解是 dp，某种意义上还挺好理解。$dp[i][j][k]$，其中$i$表示当前节点的编号，$j$表示使用的魔咒的数量，$k$表示是否选择当前节点。&lt;/p&gt;
&lt;p&gt;转移方程为&lt;/p&gt;
&lt;p&gt;$$
\begin{cases}
dp[i][j][0]=dp[i][j-k][0]+\min(dp[son][k][0], dp[i][j-k][1])\\
dp[i][j][1]=dp[i][j-k][1]+\min(dp[son][k][0], dp[son][k][1]+hp[son])
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;对于第二维，我们可以使用滚动数组消掉&lt;s&gt;实测不消也能过&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

template &amp;lt;typename T&amp;gt;
inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x) {
  char c;
  T f = 1;
  while (!isdigit(c = getchar()))
    if (c == &apos;-&apos;)
      f = -1;
  x = (c &amp;amp; 15);
  while (isdigit(c = getchar()))
    x = (x &amp;lt;&amp;lt; 1) + (x &amp;lt;&amp;lt; 3) + (c &amp;amp; 15);
  x *= f;
}
template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) {
  read(value), read(_t...);
}

using ll = long long;

const int maxn = 2021;
const int maxm = 1e5 + 17;
const ll INF = (1ll &amp;lt;&amp;lt; 60);

struct edge {
  int next, to;
} e[maxm];

int head[maxn], idx = 0;

void add_edge(int x, int y) {
  e[++idx].next = head[x];
  head[x] = idx;
  e[idx].to = y;
}

int n;

int hp[maxn], size[maxn];
ll dp[maxn][maxn][2];
ll temp[maxn];

void dfs(int x){
  for(int i = 0; i &amp;lt;=n; i++){
    dp[x][i][0] = dp[x][i][1] = INF;
  }
  dp[x][0][1] = hp[x];
  dp[x][1][0] = 0;
  size[x] = 1;
  for(int i = head[x]; i != 0; i = e[i].next){
    const int v = e[i].to;
    dfs(v);

    for(int j = 0 ; j &amp;lt;= size[x] + size[v]; j++){
      temp[j] = INF;
    }

    for(int j = 0; j &amp;lt;= size[x]; j++){
      for(int k = 0; k &amp;lt;= size[v]; k++){
        temp[j+k] = std::min(temp[j+k], dp[x][j][0] + std::min(dp[v][k][0], dp[v][k][1]));
      }
    }

    for(int j = 0; j &amp;lt;= size[x] + size[v]; j++){
      dp[x][j][0] = temp[j];
      temp[j] = INF;
    }

    for(int j = 0; j &amp;lt;= size[x]; j++){
      for(int k = 0; k &amp;lt;= size[v]; k++){
        temp[j+k] = std::min(temp[j+k], dp[x][j][1] + std::min(dp[v][k][0], dp[v][k][1] + hp[v]));
      }
    }
    for(int j = 0; j &amp;lt;= size[x] + size[v]; j++){
      dp[x][j][1] = temp[j];
      temp[j] = INF;
    }
    size[x] += size[v];
  }
}

void solve() {
  read(n);
  for(int i = 2; i &amp;lt;= n; i++){
    int p;
    read(p);
    add_edge(p, i);
  }
  for(int i = 1; i &amp;lt;= n; i++){
    read(hp[i]);
  }
  dfs(1);
  for(int i = 0; i &amp;lt;= n; i++){
    std::cout &amp;lt;&amp;lt; std::min(dp[1][i][0], dp[1][i][1]) &amp;lt;&amp;lt; &quot; &quot;;
  }
  std::cout &amp;lt;&amp;lt; std::endl;

  std::memset(head, 0, sizeof(head));
  idx = 0;
}

int main() {
  int T;
  read(T);
  while (T--) {
    solve();
  }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>ICPC</category><author>Mslxl</author></item><item><title>The 2020 ICPC Asia Shenyang Regional Programming Contest</title><link>https://blog.mslxl.com/posts/cp/2020-2021-icpc-shenyang/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/2020-2021-icpc-shenyang/</guid><pubDate>Tue, 10 Jan 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/gym/103202&quot;&gt;The 2020 ICPC Asia Shenyang Regional Programming Contest - Codeforces Gym&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;B - Whispers of the Old Gods&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;给出一个正则表达式 &lt;code&gt;pattern&lt;/code&gt; 和字符串 &lt;code&gt;str&lt;/code&gt;，要求对字符串中的数字进行尽可能少的插入，删除，替换操作。输出最小的操作次数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;s&gt;做老题结果发现专业对口这件事&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;首先根据题目给出的 BNF 写出正则的解析器，然后用 Thompson&apos;s Construction 构造和 &lt;code&gt;pattern&lt;/code&gt; 对应的 NFA，
重合 NFA 的起点和 &lt;code&gt;str&lt;/code&gt; 的开始符，向后匹配到 NFA 的结束状态即可。当 &lt;code&gt;str&lt;/code&gt; 的下一个字符使得 NFA 没有对应转移时，
修改 &lt;code&gt;str&lt;/code&gt; 的下一个字符，其实也就相当于一个 01-最短路。&lt;/p&gt;
&lt;p&gt;有关 Thompson&apos;s Construction 构造可以参考 Comp412 课件。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;2.png&quot; alt=&quot;Thompson&apos;s Construction&quot; /&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;You will be tempted to take shortcuts, such as leaving out some of the $\epsilon$ transitions&lt;/li&gt;
&lt;li&gt;Do not do it. Memorize these four patterns. They will keep you out of trouble.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;如果预先将题目中的 BNF 处理成 LL(1) 类型的文法，可以进一步优化速度，但是训练的时候推了一下，没写。
附当时的推导结果:&lt;/p&gt;
&lt;p&gt;$$
\begin{align}
\textbf{&amp;lt;regex&amp;gt;} ::&amp;amp;= \text{&amp;lt;atomic-regex&amp;gt;} \\
&amp;amp;| \text{&amp;lt;regex-op&amp;gt;}\\
&amp;amp;| \text{&amp;lt;regexs&amp;gt;}\\
\textbf{&amp;lt;regex-op&amp;gt;} ::&amp;amp;= \text{ &quot;|&quot; &amp;lt;regex&amp;gt;} \\
&amp;amp;| \text{ &quot;+&quot; &amp;lt;regex&amp;gt;} \\
\textbf{&amp;lt;regexs&amp;gt;} ::&amp;amp;= \text{&amp;lt;atomic-regex&amp;gt; &amp;lt;regex&amp;gt;} \\
&amp;amp;| \epsilon \\
\textbf{&amp;lt;atomic-regex&amp;gt; } ::&amp;amp;= \text{&amp;lt;digit&amp;gt;} \\
&amp;amp;| \text{ &quot;[&quot; &amp;lt;digit-sequence&amp;gt; &quot;]&quot;} \\
&amp;amp;| \text{ &quot;(&quot; &amp;lt;regex&amp;gt; &quot;)&quot;}
\end{align}
$$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
#include&amp;lt;bits/stdc++.h&amp;gt;

const int INF = std::numeric_limits&amp;lt;int&amp;gt;::max();

using PII = std::pair&amp;lt;int, int&amp;gt;; // pair of &amp;lt;int,int&amp;gt;
using State = std::vector&amp;lt;std::pair&amp;lt;int, int&amp;gt;&amp;gt;;

const int epsilonEdge = 0;

#pragma clang diagnostic push
#pragma ide diagnostic ignored &quot;UnreachableCallsOfFunction&quot;
class Nfa : public std::vector&amp;lt;State&amp;gt; {
    const std::string &amp;amp;pat;
    int cur = 0;

    /// 构建状态，并加入默认 epsilon 转换
    /// 加入队尾
    /// \return
    int createState() {
        int root = size();
        push_back(State());
        return root;
    }

    /// 构建原子公式
    /// \return 末状态
    PII parseAtom() {
        if (std::isdigit(pat[cur])) {
            int begin = createState();
            int end = createState();
            at(begin).emplace_back((int) pat[cur], end);
            cur++;
            return {begin, end};
        } else if (pat[cur] == &apos;[&apos;) {
            cur++;
            int begin = createState();
            int end = createState();
            std::set&amp;lt;int&amp;gt; chs;
            while (cur &amp;lt; pat.length() &amp;amp;&amp;amp; std::isdigit(pat[cur])) {
                chs.insert((int) pat[cur++]);
            }
            assert(pat[cur++] == &apos;]&apos;); // 输入错误, Expected token!
            for (int ch: chs) at(begin).emplace_back(ch, end);
            return {begin, end};
        } else {
            assert(pat[cur++] == &apos;(&apos;);
            auto node = parseAlt(); // TODO
            assert(pat[cur++] == &apos;)&apos;);
            return node;
        }
    }

    /// S-expand
    /// \return
    PII parseReg() {
        int begin = createState();
        int end = begin;
        auto peek2PlusOp = [&amp;amp;]() {
            while (cur &amp;lt; pat.length() &amp;amp;&amp;amp; pat[cur] == &apos;+&apos;) cur++;
        };
        while (cur &amp;lt; pat.length() &amp;amp;&amp;amp; (std::isdigit(pat[cur]) || pat[cur] == &apos;[&apos; || pat[cur] == &apos;(&apos;)) {
            auto next = parseAtom();
            if (cur &amp;lt; pat.length() &amp;amp;&amp;amp; pat[cur] == &apos;+&apos;) {
                peek2PlusOp();
                at(end).emplace_back(epsilonEdge, next.first);
                at(next.second).emplace_back(epsilonEdge, next.first);
                end = next.second;
            } else {
                at(end).emplace_back(epsilonEdge, next.first);
                end = next.second;
            }
        }
        return {begin, end};
    }

    /// Alter-combine
    /// \return
    PII parseAlt(){
        int begin = createState();
        auto next = parseReg();
        at(begin).emplace_back(epsilonEdge, next.first);
        std::vector&amp;lt;int&amp;gt; subEnd {next.second};
        while(cur &amp;lt; pat.length() &amp;amp;&amp;amp; pat[cur] == &apos;|&apos;){
            cur++;
            auto next = parseReg();
            at(begin).emplace_back(epsilonEdge, next.first);
            subEnd.push_back(next.second);
        }
        int end = createState();
        for(auto&amp;amp; state: subEnd){
            at(state).emplace_back(epsilonEdge, end);
        }
        return {begin, end};
    }

public:
    explicit Nfa(const std::string&amp;amp; pat) : pat(pat){
        parseAlt();
    }
};
#pragma clang diagnostic pop

int main(){
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    std::cout.tie(nullptr);
    std::string pattern, str;
    std::cin &amp;gt;&amp;gt; pattern &amp;gt;&amp;gt; str;

    Nfa nfa{pattern};
    int nfaSize = nfa.size();
    int strSize = str.length();
    auto dis = std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt;(nfaSize, std::vector&amp;lt;int&amp;gt;(strSize + 1, INF));
    std::deque&amp;lt;PII&amp;gt; deq;
    dis[0][0] = 0;
    deq.emplace_back(0,0);

    const auto m = str.length();
    while(!deq.empty()){
        auto cur = deq.front();
        int ddis = dis[cur.first][cur.second];
        deq.pop_front();

        auto releaseFront = [&amp;amp;](int u, int v){
            if(dis[u][v] &amp;gt; ddis ){
                dis[u][v] = ddis;
                deq.emplace_front(u, v);
            }
        };
        auto releaseBack = [&amp;amp;](int u, int v){
            if(dis[u][v] &amp;gt; ddis + 1){
                dis[u][v] = ddis + 1;
                deq.emplace_back(u, v);
            }
        };
        if(cur.second &amp;lt; m){
            releaseBack(cur.first, cur.second+ 1);
        }
        for(auto &amp;amp;[ch, next] : nfa[cur.first]){
            if(ch == epsilonEdge){
                releaseFront(next, cur.second);
            }else{
                // do matching operation
                if(cur.second &amp;lt; m){
                    if(ch == str[cur.second]){
                        releaseFront(next, cur.second + 1);
                    }if(m) {
                        // fail
                        // panic mode for back
                        releaseBack(next, cur.second + 1);
                    }
                }
            }
            releaseBack(next, cur.second);
        }
    }
    std::cout &amp;lt;&amp;lt; dis[nfaSize - 1][m];

    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;D - Journey to Un&apos;Goro&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;路线中仅包含红蓝两种颜色。输入一个整数，构造一个这样的路线，使的从 $i$ 出发到达$j$经过的红色数量为奇数的路径的数量最大。&lt;/p&gt;
&lt;p&gt;$1 \le i \le j \le n$&lt;/p&gt;
&lt;p&gt;输出满足要求的$(i,j)$的最大数量和这些路线。当路线数量大于100个时，仅输出字典序小的前100个。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;赛时没做出来&lt;/p&gt;
&lt;p&gt;在此介绍一篇神答案 &lt;a href=&quot;https://blog.csdn.net/dyy7777777/article/details/119083417&quot;&gt;打表+找规律&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;r&lt;/code&gt; 设为 $1$，&lt;code&gt;b&lt;/code&gt; 设为 $0$。那么子串中 $r$ 的数量就是前缀和之差。&lt;/p&gt;
&lt;p&gt;考虑什么时候 $r$ 的数量为奇数：显而易见，当前缀和数组中两个元素的奇偶性不同时，其表示的区间才是奇数。记奇数的个数为 $O$，偶数的个数为 $E$。那么在这段区间中，
可以选择任何一个前缀和为奇数的元素和一个前缀和为偶数的元素来构成一个其区间为奇数的子区间。显而易见，这种符合条件的子区间的个数应该是 $O\times E$ 个。&lt;/p&gt;
&lt;p&gt;根据高中学的某个忘掉名字的不等式，当 $O = E$时，$O\times E$取最大值，也就是 $O$ 和 $E$ 各取一半的时候。
此时 $O = \lceil \frac{n+1}{2} \rceil$，$E=\lfloor \frac{n+1}{2} \rfloor$（加一是为了考虑前缀和要留出 $i$ = 0 的空间）&lt;/p&gt;
&lt;p&gt;根据上述内容，我们一顿爆搜就可以了，当$\max(O,E) \gt \lceil \frac{n+1}{2} \rceil$ 时直接剪掉即可。&lt;/p&gt;
&lt;p&gt;在实际搜索中，我们没必要记录前缀和，只需要维护当前的奇偶状态即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
template &amp;lt;class A, class B&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::pair&amp;lt;A, B&amp;gt; const &amp;amp;a) { return s &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(a) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(a) &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;gt;= sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;) {} template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;lt; sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { if (n != 0) os &amp;lt;&amp;lt; &quot;, &quot;; os &amp;lt;&amp;lt; std::get&amp;lt;n&amp;gt;(tup); print_tuple&amp;lt;n + 1&amp;gt;(os, tup); } template &amp;lt;typename... T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { os &amp;lt;&amp;lt; &quot;(&quot;; print_tuple&amp;lt;0&amp;gt;(os, tup); return os &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;print_collection(std::ostream &amp;amp;s, T const &amp;amp;a) { s &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = std::begin(a); it != std::end(a); ++it) { s &amp;lt;&amp;lt; *it; if (it != std::prev(end(a))) s &amp;lt;&amp;lt; &quot;, &quot;; } return s &amp;lt;&amp;lt; &apos;]&apos;; } template &amp;lt;class T, class U&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::map&amp;lt;T, U&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::set&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::vector&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } void __debug_out() { std::cerr &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename T, class = typename std::enable_if&amp;lt;std::is_pointer&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; void __debug_out(T beg, T end) { std::cerr &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = beg; it != end; it++) { std::cerr &amp;lt;&amp;lt; *it; if (it != std::prev(end)) { std::cerr &amp;lt;&amp;lt; &quot;, &quot;; } } std::cerr &amp;lt;&amp;lt; &apos;]&apos; &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename H, typename... Tail&amp;gt; void __debug_out(H h, Tail... T) { std::cerr &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; h; __debug_out(T...); }
#ifndef ONLINE_JUDGE
#define debug_do if(true)
#else
#define debug_do if(false)
#endif
#define debug(...) debug_do std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)
// clang-format on
#define int ll

const ll maxn = 1e5 + 17;
ll n;
ll O, E;
char s[maxn];

int ans_counter = 0;

void dfs(int pos, int cnt_odd, int cnt_even, bool cur_odd) {
  if (std::max(cnt_odd, cnt_even) &amp;gt; O)
    return;
  if (pos == n) {
    s[n] = 0;
    std::cout &amp;lt;&amp;lt; s &amp;lt;&amp;lt; std::endl;
    if (++ans_counter &amp;gt;= 100) {
      std::exit(0);
    }
    return;
  }

  s[pos] = &apos;b&apos;;
  if (cur_odd) {
    dfs(pos + 1, cnt_odd + 1, cnt_even, cur_odd);
  } else {
    dfs(pos + 1, cnt_odd, cnt_even + 1, cur_odd);
  }
  s[pos] = &apos;r&apos;;
  if (cur_odd) {
    dfs(pos + 1, cnt_odd, cnt_even + 1, !cur_odd);
  } else {
    dfs(pos + 1, cnt_odd + 1, cnt_even, !cur_odd);
  }
}

void solve(const std::size_t testcase) {
  read(n);
  O = std::ceil((1.0l * n + 1) / 2);
  E = std::floor((1.0l * n + 1) / 2);

  assert(O==(n+2)/2);
  std::cout &amp;lt;&amp;lt; (O * E) &amp;lt;&amp;lt; &quot;\n&quot;;

  dfs(0, 0, 1, false);
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;F - Kobolds and Catacombs&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;给你一段序列，将其划分为尽可能多的段，要求每段再重新排序再拼接起来后为非下降序列。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;求原序列和排序之后的序列的前缀和，当前缀和元素相等的时候就代表这个位置被分割排序后可以形成非下降序列，此时 $ans++$&lt;/p&gt;
&lt;p&gt;时间复杂度 $O(n\log n)$，瓶颈在排序&lt;/p&gt;
&lt;p&gt;&lt;s&gt;能卡着时间过&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;3.png&quot; alt=&quot;result&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using ll = long long;
int main() {
    ll n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;ll&amp;gt; seq(n);
    std::vector&amp;lt;ll&amp;gt; ord(n);
    for (int i = 0; i &amp;lt; n; i++) {
        std::cin &amp;gt;&amp;gt; seq[i];
        ord[i]= seq[i];
    }
    std::sort(ord.begin(), ord.end());
    ll pre1=0, pre2=0;
    ll ans = 0;
    for(int i = 0; i &amp;lt; n; i++){
        pre1 += seq[i];
        pre2 += ord[i];
        if(pre1 == pre2) ans++;
    }
    std::cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &quot;\n&quot;;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;G - The Witchwood&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;现在有 $n$ 个甜点，每个甜点能带来 $a_i$的愉悦度，Bob 能吃 $k$ 个甜点。输出 Bob的最大愉悦度是多少。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;s&gt;想必这个就是大名鼎鼎的签到题了&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#define ull unsigned long long

const int maxn = 1011;
ull a[maxn];
ull cmp(ull s1, ull s2) { return s1 &amp;gt; s2; }
int main() {
  ull n, k;
  std::cin &amp;gt;&amp;gt; n &amp;gt;&amp;gt; k;
  for (int i = 1; i &amp;lt;= n; i++) {
    std::cin &amp;gt;&amp;gt; a[i];
  }
  std::sort(a + 1, a + 1 + n, cmp);
  ull ans = 0;
  for (int i = 1; i &amp;lt;= k; i++) {
    ans += a[i];
  }
  std::cout &amp;lt;&amp;lt; ans;
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;H - The Boomsday Project&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;某共享单车公司推出了“骑行劵”折扣活动。原本一次骑行需要花费 $r$ 元,一张折扣卷可以在其有效期限的 $d$ 天内免费骑行 $k$ 次。在 $t$ 天购买的折扣劵将在 $t+d-1$天过期。
折扣劵之间可存在覆盖关系，购买新的骑行劵时，旧的骑行劵作废。&lt;/p&gt;
&lt;p&gt;现在有 $n$ 种不同的骑行劵。每种骑行劵需要花费 $c_i$ 元购买，在$d_i$天内享有$k_i$次免费骑行。一个人可以无限次购买同一种骑行劵。&lt;/p&gt;
&lt;p&gt;给出 Aloha 的骑行记录，输出最小花费。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;s&gt;训练时又没做出来&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;我愿称其为玄学dp。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/assets/meme/neko_brains_overloaded.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
#include &amp;lt;limits&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on
#define int ll

const int M = 3e5 + 5;
const int N = 500 + 5;
const int INF = std::numeric_limits&amp;lt;int&amp;gt;::max();
ll n, m, r;

struct DiscountCard {
  int d, k, c;
} ca[N];
struct RideRec {
  int p, q;
} re[M];
int a[M], b[M];
int tot;
int dp[M];

void solve(const std::size_t testcase) {
  read(n, m, r);
  rep1(i, n) { read(ca[i].d, ca[i].k, ca[i].c); }

  rep1(i, m) {
    read(re[i].p, re[i].q);
    dp[i] = INF;
    rep1(j, re[i].q) { a[++tot] = re[i].p; }
  }
  std::sort(a + 1, a + 1 + tot);
  for (int i = 1; i &amp;lt;= tot; i++)
    dp[i] = INF;
  for (int i = 1; i &amp;lt;= n; i++)
    b[i] = 1;
  for (int i = 1; i &amp;lt;= tot; i++) {
    dp[i] = dp[i - 1] + r;         //  第 i 次骑行不用卡
    for (int j = 1; j &amp;lt;= n; j++) { // 搜索所有的骑行劵，编号记为 j
                                   // 找到第 j 种劵能影响到的左边界
      while (a[b[j]] + ca[j].d &amp;lt;= a[i] // 在第 b[j] 次租车的当天用第 j 个劵，在第 i 天刚好能用这个卷
             || b[j] + ca[j].k &amp;lt;= i    // 在而且次数也没过限制
      ) {
        b[j]++;
      }
      dp[i] = std::min(dp[i], dp[b[j] - 1] + ca[j].c);
    }
  }
  std::cout &amp;lt;&amp;lt; dp[tot];
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;I - Rise of Shadows&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一个钟表，时钟转一圈有 $H$ 小时，分针转一圈有 $M$ 分钟。设 $\alpha = \frac{2\pi A}{HM}$。问一天中时钟和分针的夹角小于等于 $\alpha$的时刻有几次。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先选取时针为参照物，每分钟时针运动角度 $\omega_{h\text{绝对}} = \frac{2\pi}{HM}$，分针运动角度 $\omega_{m\text{绝对} = \frac{2\pi}{M}}$
其分针相对速度为 $\omega_m = \omega_{m\text{绝对}} - \omega_{h\text{绝对}} = \frac{2\pi(H-1)}{HM}$&lt;/p&gt;
&lt;p&gt;在 $T$ 分钟的时候，时针和分针的夹角为 $\theta =\omega_m T= \frac{2\pi(H-1)}{HM} T$&lt;/p&gt;
&lt;p&gt;考虑到可能会有转一圈回来的情况，夹角应该是 $\theta = \frac{2\pi(H-1)T}{HM} \mod 2\pi$&lt;/p&gt;
&lt;p&gt;另外时针和分针的能形成的角有两个，这两个角互补。我们应该选择小的角，即 $min(\theta, 2\pi - \theta)$&lt;/p&gt;
&lt;p&gt;也就是求从 $T \in [0,HM]$ 这段时间中有多少个 $\frac{2\pi(H-1)T}{HM} \mod 2\pi \le \frac{2\pi A}{HM}$ 或$2\pi - \frac{2\pi(H-1)T}{HM} \mod 2\pi \le \frac{2\pi A}{HM}$ 成立&lt;/p&gt;
&lt;p&gt;在这里，我们很容易发现一种特殊情况，即 $A=\frac{HM}{2}$时，显然每个时刻都满足题意，答案为 $HM$&lt;/p&gt;
&lt;p&gt;当 $A\ne \frac{HM}{2}$ 时:&lt;/p&gt;
&lt;p&gt;对于上式$\frac{2\pi(H-1)T}{HM} \mod 2\pi \le \frac{2\pi A}{HM}$ 中，我们可以将 $HM$ 看作 $2\pi$，将 (H-1) 每个时刻两个指针的变化量。&lt;/p&gt;
&lt;p&gt;当存在 $T(H-1) mod HM \le A$ 时，一定不会有 $T(H-1) mod HM \ge HM - A$，两个部分不会同时存在重叠的答案，所以我们只需要将两部分的答案
加起来即可。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;先看第一个式子(其中 $[P]$ 表示艾弗森括号)&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;$$
\sum^{HM}_{T=0} [T(H-1) \mod HM \le A]
$$&lt;/p&gt;
&lt;p&gt;令 $G=\gcd(H-1, HM)$，当$G=1$时，由于 $T\in[0,HM]$，构成了一个模为 $HM$ 的完全剩余系。
根据其性质可知，$T(H-1)\mod HM$也是一个完全剩余系，即它一定取遍了 [0, HM-1] 的每一个数，此时不需要关心那个时刻满足答案，只需要知道范围内有多少
数小于等于 $A$ 即可。现在在 $[0,A]$ 的范围内总共有 $A+1$ 个数满足，答案为 $A+1$&lt;/p&gt;
&lt;p&gt;当 $G \ne 1$时，利用同余性质 $ac \equiv bc (\mod b) \Leftrightarrow a \equiv b (\mod \frac{b}{(c,d)})$，式子看转化为
$\sum^{HM}_{T=0}[\frac{T(H-1)}{G} \mod \frac{HM}{G} \le \lfloor \frac{A}{G}\rfloor]$&lt;/p&gt;
&lt;p&gt;也就是相当于把 $[0, HM)$ 平均分成 $G$ 段，每一段的 $T$ 都模一个 $\frac{HM}{G}$ 的完全剩余系，，
每一段的答案都是$\lfloor \frac{A}{G} \rfloor + 1$。即第一个式子的所有答案之和为 $G * (\lfloor \frac{A}{G} \rfloor + 1)$&lt;/p&gt;
&lt;p&gt;同理，我们处理第二个式子，得到答案为 $G * (2\lfloor \frac{A}{G} \rfloor + 1)$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using ll = long long;

int main(){
    ll H,M, A;
    std::cin &amp;gt;&amp;gt; H &amp;gt;&amp;gt; M &amp;gt;&amp;gt; A;
    if(A == H * M / 2){
        std::cout &amp;lt;&amp;lt;  H * M &amp;lt;&amp;lt; &quot;\n&quot;;
        return 0;
    }
    std::cout &amp;lt;&amp;lt; std::__gcd(H-1, H * M)*(2*(A/std::__gcd(H-1, H * M))+1);
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;em&gt;&lt;s&gt;吐槽一下我队友在计算过程中把向下取整掉了&lt;/s&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;&lt;s&gt;不过这位现场百度5分钟内就把完全剩余系学会了，他就是我的神，tql&lt;/s&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h1&gt;K - Scholomance Academ&lt;/h1&gt;
&lt;p&gt;阅读理解题，读懂题意就是小模拟&lt;/p&gt;
&lt;p&gt;&lt;s&gt;结果我比有深度学习经验的队友先读懂&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;以下翻译的术语可能并不正确&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;二元分类是一种对已有实例进行分类的算法，分类结果只能是 &lt;code&gt;positive(+)&lt;/code&gt; 或 &lt;code&gt;negative(-)&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;典型的二元分类算法用一个函数 $S$ 和一个阈值 $\theta$ 进行，当实例的分数 $S(x)\ \ge \theta$ 时，实例x被分类为 &lt;code&gt;positive&lt;/code&gt;，否则就是 &lt;code&gt;negative&lt;/code&gt;
显然不同的阈值 $\theta$ 会产生不同的分类结果。&lt;/p&gt;
&lt;p&gt;二元分类也存在误判。它可以将实际为 &lt;code&gt;positive&lt;/code&gt; 的实例判定为 &lt;code&gt;negative&lt;/code&gt;，这种情况称为 &lt;code&gt;false negative&lt;/code&gt;；也可以将实际为 &lt;code&gt;negative&lt;/code&gt; 的实例判断为 &lt;code&gt;positive&lt;/code&gt;,这种情况称为 &lt;code&gt;false negative&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;5.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;现在题目给出一个数据集和一个分类器。定义 true positive rate(TPR) 和 false positive rate(FPR) 为以下内容&lt;/p&gt;
&lt;p&gt;$$TPR=\frac{\#TP}{\#TP + \#FN}, FPR=\frac{\#FP}{\#TN + \#FP}$$&lt;/p&gt;
&lt;p&gt;你现在需要评估一个分类器的性能，这个分类器在不同的阈值 $\theta$ 下表现的 $TPR$ 与 $FPR$ 不同。记阈值为 $\theta$ 时 TPR 和 FPR 为 $TPR(\theta)$ 和 $FPR(\theta)$。那么 area under curve(AUC) 为&lt;/p&gt;
&lt;p&gt;$$AUC=\int^1_0 \max_{\theta \in R}\{TPR(\theta)\mid FPR(\theta) \le r\}dr$$&lt;/p&gt;
&lt;p&gt;式子中被积函数称为 receiver operating characteristic(ROC)，意为当 $FPR(\theta) \le r$ 时 $TPR$的最大值。&lt;/p&gt;
&lt;p&gt;例如现在有三个测试数据，当阈值取值为$\theta=30$时，有3个 TP, 2个 FP,2个TN，1个 FN。
因此，此时的 $TPR(30)=0.75$，$FPR(30)=0.5$。当 $\theta$变化时，我们能画出 ROC 曲线，并&lt;strong&gt;直接计算出 AUC&lt;/strong&gt;。如图片1。
&lt;img src=&quot;4.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;hr/&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输入数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;第一行一个整数 $n$ ($2 \le n \le 10^6$)，表示测试集中实例的数量。接下来 $n$ 行中，
每一行包含一个字符 $c \in \{+,-\}$ 表示实例的真实类型；一个整数 $s$ $(1\le s \le 10^9)$ 表示当前实例的分数&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;输出数据&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;输出 $AUC$，精确到小数点后10位。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;s&gt;我第一反应是扫描线&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;首先我们需要明确他那个看着吓人的积分函数根本没有任何用处。&lt;/p&gt;
&lt;p&gt;我们可以通过枚举 $\theta$，每次枚举算出 FPR 和 TPR ，并求出面积。这种方法道理上可行，但实际因为取值范围的问题，并不能用。&lt;/p&gt;
&lt;p&gt;退而求其次，因为题目还给了当前实例的分数 $s$，这个$s$即可表示每次$theta$的取值。起始时记 $\theta$ 为最大值，此时所有的实例都会被预测为 &lt;code&gt;negative&lt;/code&gt;。逐步降低 $\theta$，即可得到最后答案，通过预先根据 $s$ 进行排序，可实现逐步降低。&lt;/p&gt;
&lt;p&gt;将 $+$ 排在 $−$ 之前可以便于计算。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
using ll = long long;
using ld = long double;

struct Rect{
    char pos_neg;
    ll value;

    bool operator&amp;lt;(const Rect&amp;amp; rhs)const {
        if(this-&amp;gt;value == rhs.value){
            return this-&amp;gt;pos_neg &amp;lt; rhs.pos_neg;
        }else{
            return this-&amp;gt;value &amp;lt; rhs.value;
        }
    }
};

ll FalseNegative=0, TrueNegative=0;
ll TruePositive=0, FalsePositive=0;
ld ans = 0, LastX;

int main(){
    ll n;
    std::cin &amp;gt;&amp;gt; n;
    std::vector&amp;lt;Rect&amp;gt; seq(n);
    for(int i = 0; i &amp;lt; n; i++){
        std::cin &amp;gt;&amp;gt; seq[i].pos_neg &amp;gt;&amp;gt; seq[i].value;
        if(seq[i].pos_neg == &apos;+&apos;){
            FalseNegative++;
        }else{
            TrueNegative++;
        }
    }
    std::sort(seq.begin(), seq.end());

    for(int i = n-1; i &amp;gt;= 0; i--){
        if(seq[i].pos_neg == &apos;+&apos;){
            TruePositive++;
            FalseNegative--;
        }else{
            FalsePositive++;
            TrueNegative--;
        }
        ans += ld(TruePositive) / ld(TruePositive + FalseNegative) * (ld(FalsePositive) / (TrueNegative + FalsePositive) - LastX);
        LastX = ld(FalsePositive) / (TrueNegative + FalsePositive);
    }
    std::cout &amp;lt;&amp;lt; std::setprecision(12) &amp;lt;&amp;lt; std::fixed &amp;lt;&amp;lt; ans;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>ICPC</category><author>Mslxl</author></item><item><title>Codeforces Round 841 (Div. 2) and Divide by Zero 2022 - ABCD</title><link>https://blog.mslxl.com/posts/cp/cf1731/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/cf1731/</guid><pubDate>Sat, 31 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://codeforces.com/contest/1731&quot;&gt;Codeforces Round #841 (Div. 2) and Divide by Zero 2022&lt;/a&gt;&lt;/p&gt;
&lt;h1&gt;A - Joey Takes Money&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;给一个长度为 n 的整数序列 $a_i \ge 1$&lt;/p&gt;
&lt;p&gt;选择两个数 $a_i$ 和 $b_i$，将其替换为 $x$, $y$，其中 $x _ y = a_i _ a_j $，这个操作可以进行无数次&lt;/p&gt;
&lt;p&gt;输出这个序列的和乘以$2022$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;直接暴力就行:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
#include &amp;lt;functional&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  read(t);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

// coding here
#define int ul
void solve(const std::size_t testcase) {
  int n;
  read(n);

  std::vector&amp;lt;int&amp;gt; seq(n);
  rep(i, n) read(seq[i]);
  if (n == 1) {
    std::cout &amp;lt;&amp;lt; seq[0] * 2022&amp;lt;&amp;lt; std::endl;
    return;
  }
  std::sort(seq.begin(), seq.end());

  for (int i = 0; i &amp;lt; n - 1; i++) {
    seq[i+1] = seq[i] * seq[i+1];
    seq[i] = 1;
  }
  std::cout &amp;lt;&amp;lt; ((n-1) + seq[n-1]) * 2022&amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;B - Kill Demodogs&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;一个矩阵，从 $(1,1)$ 出发走到 $(n,n)$，每经过$(i,i)$可得分$i*i$。 只能向下或者向右走&lt;/p&gt;
&lt;p&gt;问全程最大积分是多少？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先根据 $a+b\ge 2\sqrt{ab}$，当 $a=b$时，$a*b$取最大，所以移动路线应该是这样的:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;1.png&quot; alt=&quot;map&quot; /&gt;&lt;/p&gt;
&lt;p&gt;当我们走到$(1,1)$时,获得积分 $a_1 = 1 * 1$&lt;/p&gt;
&lt;p&gt;从第一行走第二行，获得积分 $a_2 = 2 * 2 + 2 * 1$&lt;/p&gt;
&lt;p&gt;以此类推，当我们走完 $n$ 行时，获得积分 $a_n = n^2 + n(n-1)$&lt;/p&gt;
&lt;p&gt;走到 $(n,n)$，即求数列 $a_n$ 前 $n$ 项的和 $S_n = \frac{n(4n-1)(n+1)}{6}$&lt;/p&gt;
&lt;p&gt;本来当存在取模时，除法要求逆元，但是正好题目要求答案乘以 2022，所以最终答案是 $S_n = 337n(4n-1)(n+1)$&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::ios::sync_with_stdio(false);
  std::cout.tie(nullptr);
  std::cin.tie(nullptr);
  std::size_t t = 1;
  std::cin &amp;gt;&amp;gt; t;
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on
const ul modd = 1e9 + 7;

// coding here
void solve(const std::size_t testcase) {
  ul n;
  std::cin &amp;gt;&amp;gt; n;
  ll ans = n * (4 * n - 1) % modd * (n + 1) % modd ;
  ans = ans % modd * 337 % modd;
  std::cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;C - Even Subarrays&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;给一段长度为 n 的序列 $a_i$，从中找到他的连续子序列，并且这个连续子序列的因数个数为偶数。&lt;/p&gt;
&lt;p&gt;问这样的子序列个数为多少&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;首先一个数的因子都是成对出现的，当这个数是平方数的时候会出现两个一样的因子，也就是说当
一个数不是平方数的时候，它的因子个数一定是偶数个。&lt;/p&gt;
&lt;p&gt;因此我们只需要判断有多少个子区间的异或和为平方数，最后用子区间的个数减去子区间中异或和为平方数的个数即可。&lt;/p&gt;
&lt;p&gt;这个统计操作有一个相似的题目: &lt;a href=&quot;https://ac.nowcoder.com/acm/problem/51460&quot;&gt;Crazy Binary String&lt;/a&gt;，&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
   read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on
#define int ll

void solve(const std::size_t testcase) {
  int n;
  read(n);
  std::vector&amp;lt;int&amp;gt; a(n + 1);
  rep1(i, n) {
    read(a[i]);
    a[i] ^= a[i - 1];
  }
  std::vector&amp;lt;int&amp;gt; mp(4 * n);
  int ans = 0;
  mp[0] = 1;
  rep1(i, n) {
    for (int x = 0; x * x &amp;lt;= 2 * n; x++) {
      int num = x * x;
      ans += mp[a[i] ^ num];
    }
    mp[a[i]]++;
  }
  std::cout &amp;lt;&amp;lt; ll(n * (n + 1) / 2) - ans &amp;lt;&amp;lt; &quot;\n&quot;;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;D - Valiant&apos;s New Map&lt;/h1&gt;
&lt;p&gt;二分+二维前缀和&lt;/p&gt;
&lt;p&gt;&lt;s&gt;应该有别的思路&lt;/s&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;题目给一个 $n\times m$ 的矩阵，从里面选择 $l\times l$ 的子矩阵，并且这个子矩阵的元素最小值必须不小于 $l$&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;从 $l\in [1, \min(n,m)]$ 中二分 $l$，check函数用二维前缀和即可。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;能卡着时间跑过。&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on
bool check(int k, const std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; &amp;amp;a, ll n, ll m) {
  std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; pre(n + 1, std::vector&amp;lt;int&amp;gt;(m + 1, 0));
  for (int i = 1; i &amp;lt;= n; i++) {
    for (int j = 1; j &amp;lt;= m; j++) {
      pre[i][j] =
          (a[i][j] &amp;gt;= k) + pre[i - 1][j] + pre[i][j - 1] - pre[i - 1][j - 1];
    }
  }
  for (int i = k; i &amp;lt;= n; i++) {
    for (int j = k; j &amp;lt;= m; j++) {
      int x = i - k + 1, y = j - k + 1;
      if (pre[i][j] + pre[x - 1][y - 1] - pre[x - 1][j] - pre[i][y - 1] ==
          k * k)
        return true;
    }
  }
  return false;
}

void solve(const std::size_t testcase) {
  ll n, m;
  read(n, m);
  std::vector&amp;lt;std::vector&amp;lt;int&amp;gt;&amp;gt; mp(n + 1, std::vector&amp;lt;int&amp;gt;(m + 1));
  rep1(i, n) {
    rep1(j, m) { read(mp[i][j]); }
  }
  int r = std::min(n, m);
  int l = 1;
  int ans = 0;
  while (l &amp;lt;= r) {
    int mid = l + (r - l) / 2;
    if(check(mid, mp, n,m)){
      ans = std::max(ans, mid);
      l = mid + 1;
    }else{
      r = mid - 1;
    }
  }
  std::cout &amp;lt;&amp;lt; ans  &amp;lt;&amp;lt; std::endl;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>Codeforces</category><author>Mslxl</author></item><item><title>2022 第五届传智杯初赛</title><link>https://blog.mslxl.com/posts/cp/2022-5th-chuanzhi-region/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/2022-5th-chuanzhi-region/</guid><pubDate>Thu, 29 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P8869?contestId=92638&quot;&gt;A-莲子的软件工程学&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;记得开 long long 就好，防止取绝对值时爆炸&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

using ll = long long;
using ul = unsigned long long;
using ld = long double;

template &amp;lt;typename T&amp;gt;
inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){
  char c;T f=1;
  while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1;
  x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15);
  x*=f;
}

template &amp;lt;typename T, typename... A&amp;gt; void read(T &amp;amp;value, A &amp;amp;..._t) {
  read(value);
  read(_t...);
}

#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; i++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; i++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)

// main function
void solve(const std::size_t testcase){
  //coding here
  ll a,b;
  std::cin &amp;gt;&amp;gt; a &amp;gt;&amp;gt; b;
  ll sig = b / std::abs(b);
  std::cout &amp;lt;&amp;lt; std::abs(a) * sig;
}

#ifdef int
#undef int
#endif
int main(){
  std::size_t t = 1;
  // std::cin &amp;gt;&amp;gt; t;
  for(std::size_t i = 1; i &amp;lt;= t; i++){
    solve(t);
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P8870&quot;&gt;B-莲子的机械动力学&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;从低位开始逐位相加，然后取模即可&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

using ll = long long;
using ul = unsigned long long;
using ld = long double;

// ------------ Minify with Regex &quot;^\s*(?!#)(.*)\n&quot; -&amp;gt; &quot; &quot; ------------
// clang-format off
template &amp;lt;class A, class B&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::pair&amp;lt;A, B&amp;gt; const &amp;amp;a) { return s &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(a) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(a) &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;gt;= sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;) {} template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;lt; sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { if (n != 0) os &amp;lt;&amp;lt; &quot;, &quot;; os &amp;lt;&amp;lt; std::get&amp;lt;n&amp;gt;(tup); print_tuple&amp;lt;n + 1&amp;gt;(os, tup); } template &amp;lt;typename... T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { os &amp;lt;&amp;lt; &quot;(&quot;; print_tuple&amp;lt;0&amp;gt;(os, tup); return os &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;print_collection(std::ostream &amp;amp;s, T const &amp;amp;a) { s &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = std::begin(a); it != std::end(a); ++it) { s &amp;lt;&amp;lt; *it; if (it != std::prev(end(a))) s &amp;lt;&amp;lt; &quot;, &quot;; } return s &amp;lt;&amp;lt; &apos;]&apos;; } template &amp;lt;class T, class U&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::map&amp;lt;T, U&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::set&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::vector&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } void __debug_out() { std::cerr &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename T, class = typename std::enable_if&amp;lt;std::is_pointer&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; void __debug_out(T beg, T end) { std::cerr &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = beg; it != end; it++) { std::cerr &amp;lt;&amp;lt; *it; if (it != std::prev(end)) { std::cerr &amp;lt;&amp;lt; &quot;, &quot;; } } std::cerr &amp;lt;&amp;lt; &apos;]&apos; &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename H, typename... Tail&amp;gt; void __debug_out(H h, Tail... T) { std::cerr &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; h; __debug_out(T...); }
#ifndef ONLINE_JUDGE
#define debug(...) std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif
// clang-format on

template &amp;lt;typename T&amp;gt;
inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x) {
  char c;
  T f = 1;
  while (!isdigit(c = getchar()))
    if (c == &apos;-&apos;)
      f = -1;
  x = (c &amp;amp; 15);
  while (isdigit(c = getchar()))
    x = (x &amp;lt;&amp;lt; 1) + (x &amp;lt;&amp;lt; 3) + (c &amp;amp; 15);
  x *= f;
}

template &amp;lt;typename T, typename... A&amp;gt; void read(T &amp;amp;value, A &amp;amp;..._t) {
  read(value);
  read(_t...);
}

#define rep(NAME, MAX) for (decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define replr(NAME, START, END) for(ll _sig = ((ll(END)-ll(START))/ std::abs(ll(END)-ll(START))), NAME = START; NAME != END; NAME+=_sig)
#define replrci(NAME, START, END) for(ll _sig = ((ll(END)-ll(START))/ std::abs(ll(END)-ll(START))), NAME = START+_sig; NAME-_sig != END; NAME+=_sig)

#define int ll
// main function
void solve(const std::size_t testcase) {
  int n, m;
  read(n, m);
  int len = std::max(n, m)+1;
  std::vector&amp;lt;int&amp;gt; a(len, 0);
  std::vector&amp;lt;int&amp;gt; b(len, 0);
  std::vector&amp;lt;int&amp;gt; ans(len, 0);

  replrci(i, n, 0) read(a[i]);
  replrci(i, m, 0) read(b[i]);
  rep(i, len){
    int bin = i + 2;
    ans[i] += a[i] + b[i];
    if(ans[i] &amp;gt;= bin){
      ans[i+1] += ans[i] / bin;
      ans[i] %= bin;
    }
  }
  bool nzero = false;
  replrci(i, ans.size(), 0){
    if(ans[i] == 0 &amp;amp;&amp;amp; !nzero) continue;
    if(ans[i] != 0) nzero = true;
    std::cout &amp;lt;&amp;lt; ans[i] &amp;lt;&amp;lt; &apos; &apos;;
  }
  if(!nzero) std::cout &amp;lt;&amp;lt; 0;
}

#ifdef int
#undef int
#endif
int main() {
  std::size_t t = 1;
  // std::cin &amp;gt;&amp;gt; t;
  for (std::size_t i = 1; i &amp;lt;= t; i++) {
    solve(t);
  }
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P8871&quot;&gt;C-莲子的排版设计学&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;全读进来，粗略统计一下输出结果即可。&lt;/p&gt;
&lt;p&gt;值得一提的是如果想要统计数字 x 是几位数字，可以用 $\lg{(x)} + 1$ 计算。&lt;/p&gt;
&lt;p&gt;如果不愿意自己对齐空格，可以动态构造格式化字符串，然后用 &lt;code&gt;std::vformat&lt;/code&gt; 或者 &lt;code&gt;printf&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;
#include &amp;lt;bits/stdc++.h&amp;gt;
// clang-format off
// ------------ Minify with Regex &quot;^\s*(?!#)(.*)\n&quot; -&amp;gt; &quot; &quot; ------------
template &amp;lt;class A, class B&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::pair&amp;lt;A, B&amp;gt; const &amp;amp;a) { return s &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(a) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(a) &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;gt;= sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;) {} template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;lt; sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { if (n != 0) os &amp;lt;&amp;lt; &quot;, &quot;; os &amp;lt;&amp;lt; std::get&amp;lt;n&amp;gt;(tup); print_tuple&amp;lt;n + 1&amp;gt;(os, tup); } template &amp;lt;typename... T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { os &amp;lt;&amp;lt; &quot;(&quot;; print_tuple&amp;lt;0&amp;gt;(os, tup); return os &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;print_collection(std::ostream &amp;amp;s, T const &amp;amp;a) { s &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = std::begin(a); it != std::end(a); ++it) { s &amp;lt;&amp;lt; *it; if (it != std::prev(end(a))) s &amp;lt;&amp;lt; &quot;, &quot;; } return s &amp;lt;&amp;lt; &apos;]&apos;; } template &amp;lt;class T, class U&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::map&amp;lt;T, U&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::set&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::vector&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } void __debug_out() { std::cerr &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename T, class = typename std::enable_if&amp;lt;std::is_pointer&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; void __debug_out(T beg, T end) { std::cerr &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = beg; it != end; it++) { std::cerr &amp;lt;&amp;lt; *it; if (it != std::prev(end)) { std::cerr &amp;lt;&amp;lt; &quot;, &quot;; } } std::cerr &amp;lt;&amp;lt; &apos;]&apos; &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename H, typename... Tail&amp;gt; void __debug_out(H h, Tail... T) { std::cerr &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; h; __debug_out(T...); }
#ifndef ONLINE_JUDGE
#define debug(...) std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif

using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt;
inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){
  char c;T f=1;
  while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1;
  x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15);
  x*=f;
}
template &amp;lt;typename T, typename... A&amp;gt; void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define replr(NAME, START, END) for(ll _sig = ((ll(END)-ll(START))/ std::abs(ll(END)-ll(START))), NAME = START; NAME != END; NAME+=_sig)
#define replrci(NAME, START, END) for(ll _sig = ((ll(END)-ll(START))/ std::abs(ll(END)-ll(START))), NAME = START+_sig; NAME-_sig != END; NAME+=_sig)
// clang-format on

// coding here
inline void solve(const std::size_t testcase) {
  std::string line;
  std::vector&amp;lt;std::string&amp;gt; lines;
  while (std::getline(std::cin, line)) {
    lines.push_back(line);
  }
  ll linenum = std::log10(lines.size()) + 1;
  std::string fmt = &quot;%&quot; + std::to_string(linenum) + &quot;lld %s\n&quot;;

  rep(i,lines.size()){
    printf(fmt.data(), i+1, lines[i].data());
  }
}

#ifdef int
#undef int
#endif
int main() {
  std::size_t t = 1;
  // std::cin &amp;gt;&amp;gt; t;
  for (std::size_t i = 1; i &amp;lt;= t; i++)
    solve(t);
  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P8872&quot;&gt;D-莲子的物理热力学&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;贪心&lt;/p&gt;
&lt;p&gt;&lt;s&gt;首先要保证自己没有读错题,题目中的$max_j$中的$j$并不是每次自己选择一段区间&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;题目中给了我们 $m$ 次进行操作的机会，我们可以确定当进行一次操作时，只会让当前的极差不变
或者变小，也就是说我们可以尽可能多的进行操作。&lt;/p&gt;
&lt;p&gt;我们不可避免的要先让最大值变为最小值，再让最小值变为次大值。&lt;/p&gt;
&lt;p&gt;我们可以将 $u$ 个数变大，再将 $u + v$ 个数变小，需要进行 $u+v+u$ 次操作。或者将 $v$ 个数变小，再将 $u+v$ 个数变大, 总共进行 $v + u + v$ 次
操作，也就是说，最终操作次数应该是 $u+v+min(u,v)=m$。&lt;/p&gt;
&lt;p&gt;根据这个式子，我们可以推出以下结论：&lt;/p&gt;
&lt;p&gt;$$
\begin{cases}
v &amp;amp;= m - 2u &amp;amp; 3u \le m \cr
v &amp;amp;= \frac{m-u}{2} &amp;amp; 3u \gt m
\end{cases}
$$&lt;/p&gt;
&lt;p&gt;当我们枚举 $u$ 时，即可算出 $v$ 的取值，每次枚举都能求出一个极差，枚举所有值，找出极差的最小值即可。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // std::cin &amp;gt;&amp;gt; t;
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on
#define int ll
int n, m;
std::vector&amp;lt;ll&amp;gt; seq;

// coding here
void solve(const std::size_t testcase) {
  read(n, m);
  seq.resize(n);
  rep(i, n) read(seq[i]);
  std::sort(seq.begin(), seq.end());

  if (m == 0) {
    std::cout &amp;lt;&amp;lt; seq[seq.size() - 1] - seq[0];
    return;
  }
  if (n == 1) {
    std::cout &amp;lt;&amp;lt; 0;
    return;
  }

  ll ans = std::numeric_limits&amp;lt;ll&amp;gt;::max();

  for (int u = 0; u &amp;lt;= m &amp;amp;&amp;amp; u &amp;lt; seq.size(); u++) {
    int v;
    if (u * 3 &amp;lt;= m) {
      v = m - 2 * u;
    } else {
      v = (m - u) / 2;
    }
    if (u + v &amp;gt;= seq.size()) {
      ans = 0;
      break;
    } else {
      ans = std::min(ans, seq[seq.size() - v - 1] - seq[u]);
    }
  }
  std::cout &amp;lt;&amp;lt; ans;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P8873&quot;&gt;E-莲子的市场经济学&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;二分&lt;/p&gt;
&lt;p&gt;首先通过瞪眼法找通项公式，我们把一个周期看作一组，可以发现第一个组的峰值为 $1$，第二个组的峰值为 $2$...
而且很容易发现每组的数字数量是一个等差数列，通项公式为 $1+4n$&lt;/p&gt;
&lt;p&gt;也就是说第 $n$ 组最后一个数字是 $1 + (3n + 2n^2)$，第一个数字是 $1 + (3(n-1) + 2(n-1)^2) + 1$&lt;/p&gt;
&lt;p&gt;由于 $k\le 4*1e18$ 可以通过二分的方式来寻找 $k$ 属于哪一组&lt;/p&gt;
&lt;p&gt;接下来就是简单的数学题了：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  read(t);
  rep1(i, t) solve(t);
  return 0;
}
// clang-format on

ll group_index_maxk(ll n) { return 1 + 3 * n + 2 * n * n; }

// coding here
void solve(const std::size_t testcase) {
  ll k;
  read(k);
  if (k == 1) {
    std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &quot;\n&quot;;
    return;
  }

  ll l = 1, r = 2e9;
  ll group_idx;
  while (l &amp;lt;= r) {
    group_idx = l + (r - l) / 2;
    ll maxk = group_index_maxk(group_idx);
    ll mink = group_index_maxk(group_idx - 1)+1;
    if (mink &amp;lt;= k &amp;amp;&amp;amp; k &amp;lt;= maxk)
      break;
    if (maxk &amp;lt; k) {
      l = group_idx + 1;
    } else if (k &amp;lt; mink) {
      r = group_idx - 1;
    }
  }

  ll group_min_k = group_index_maxk(group_idx - 1) + 1;
  ll group_max_k = group_index_maxk(group_idx);
  ll group_peak_ak = group_idx;
  ll group_mid_k = group_min_k + (group_max_k - group_min_k) / 2;
  ll group_peak_span = (group_mid_k - group_min_k) / 2;
  ll top_peak_k = group_min_k + group_peak_span;
  ll bottom_peak_k = group_mid_k + group_peak_span;

  if (k == group_min_k) {
    std::cout &amp;lt;&amp;lt; 0 &amp;lt;&amp;lt; &quot;\n&quot;;
  } else if (k &amp;gt; group_mid_k) {
    if (k &amp;gt; bottom_peak_k) {
      std::cout &amp;lt;&amp;lt; -group_idx + (k - bottom_peak_k) &amp;lt;&amp;lt; &quot;\n&quot;;
    } else {
      std::cout &amp;lt;&amp;lt; -(k - group_mid_k) &amp;lt;&amp;lt; &quot;\n&quot;;
    }
  } else {
    if (k &amp;gt; top_peak_k) {
      std::cout &amp;lt;&amp;lt; group_idx - (k - top_peak_k) &amp;lt;&amp;lt; &quot;\n&quot;;
    } else {
      std::cout &amp;lt;&amp;lt; k - group_min_k &amp;lt;&amp;lt; &quot;\n&quot;;
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P8874&quot;&gt;F-二人的大富翁游戏&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;大模拟，不想写&lt;/p&gt;
&lt;h1&gt;&lt;a href=&quot;https://www.luogu.com.cn/problem/P8875&quot;&gt;E-二人的花纹纸游戏&lt;/a&gt;&lt;/h1&gt;
&lt;p&gt;染色二维前缀和&lt;/p&gt;
&lt;p&gt;不妨看看&lt;a href=&quot;https://www.luogu.com.cn/problem/solution/P8875&quot;&gt;官方题解&lt;/a&gt;?&lt;/p&gt;
&lt;p&gt;&lt;s&gt;它的题面$x,y$的使用顺序正好和我相反，迷惑了半天&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// clang-format off
#include &amp;lt;bits/stdc++.h&amp;gt;
using ll = long long; using ul = unsigned long long; using ld = long double;
template &amp;lt;typename T&amp;gt; inline typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;x){ char c;T f=1; while(!isdigit(c=getchar())) if(c==&apos;-&apos;)f=-1; x=(c&amp;amp;15); while(isdigit(c=getchar())) x= (x&amp;lt;&amp;lt;1) + (x&amp;lt;&amp;lt;3) + (c&amp;amp;15); x*=f; } template &amp;lt;typename T, typename... A&amp;gt; inline void read(T &amp;amp;value, A &amp;amp;..._t) { read(value), read(_t...); }
void solve(const std::size_t testcase);
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; NAME++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; NAME++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
int main() {
  std::size_t t = 1;
  // read(t);
  // std::ios::sync_with_stdio(false); std::cin.tie(nullptr); std::cout.tie(nullptr);
  rep1(i, t) solve(t);
  return 0;
}
template &amp;lt;class A, class B&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::pair&amp;lt;A, B&amp;gt; const &amp;amp;a) { return s &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(a) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(a) &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;gt;= sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;) {} template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;lt; sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { if (n != 0) os &amp;lt;&amp;lt; &quot;, &quot;; os &amp;lt;&amp;lt; std::get&amp;lt;n&amp;gt;(tup); print_tuple&amp;lt;n + 1&amp;gt;(os, tup); } template &amp;lt;typename... T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { os &amp;lt;&amp;lt; &quot;(&quot;; print_tuple&amp;lt;0&amp;gt;(os, tup); return os &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;print_collection(std::ostream &amp;amp;s, T const &amp;amp;a) { s &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = std::begin(a); it != std::end(a); ++it) { s &amp;lt;&amp;lt; *it; if (it != std::prev(end(a))) s &amp;lt;&amp;lt; &quot;, &quot;; } return s &amp;lt;&amp;lt; &apos;]&apos;; } template &amp;lt;class T, class U&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::map&amp;lt;T, U&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::set&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::vector&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } void __debug_out() { std::cerr &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename T, class = typename std::enable_if&amp;lt;std::is_pointer&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; void __debug_out(T beg, T end) { std::cerr &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = beg; it != end; it++) { std::cerr &amp;lt;&amp;lt; *it; if (it != std::prev(end)) { std::cerr &amp;lt;&amp;lt; &quot;, &quot;; } } std::cerr &amp;lt;&amp;lt; &apos;]&apos; &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename H, typename... Tail&amp;gt; void __debug_out(H h, Tail... T) { std::cerr &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; h; __debug_out(T...); }
#ifndef ONLINE_JUDGE
#define debug_do if(true)
#else
#define debug_do if(false)
#endif
#define debug(...) debug_do std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)
// clang-format on

#define int ll
template &amp;lt;typename T&amp;gt; using vvector = std::vector&amp;lt;std::vector&amp;lt;T&amp;gt;&amp;gt;;
const int modd = 998244353;

void solve(const std::size_t testcase) {
  int n, m, r, c;
  read(n, m);
  vvector&amp;lt;int&amp;gt; A(n + 1, std::vector&amp;lt;int&amp;gt;(m + 1));
  rep1(i, n) rep1(j, m) read(A[i][j]);
  read(r, c);
  vvector&amp;lt;int&amp;gt; B(r + 1, std::vector&amp;lt;int&amp;gt;(c + 1));
  rep1(i, r) rep1(j, c) read(B[i][j]);

  vvector&amp;lt;int&amp;gt; pre(A);
  for (int i = 1; i &amp;lt;= n; i++) {
    for (int j = 1; j &amp;lt;= m; j++) {
      int irj = i - r &amp;gt;= 0 ? pre[i - r][j] : 0;
      irj %= modd;
      int ijc = j - c &amp;gt;= 0 ? pre[i][j - c] : 0;
      ijc %= modd;
      int irjc = (i - r) &amp;gt;= 0 &amp;amp;&amp;amp; (j - c) &amp;gt;= 0 ? pre[i - r][j - c] : 0;
      irjc %= modd;
      pre[i][j] = (pre[i][j] + irj) % modd;
      pre[i][j] = (pre[i][j] + ijc) % modd;
      pre[i][j] = (pre[i][j] - irjc + modd) % modd;
    }
  }

  debug(&quot;Done&quot;);
  debug(n, m, r, c);
  int q;
  read(q);
  rep(i, q) {
    int x1, y1, x2, y2;
    read(x1, y1, x2, y2);
    debug(x1, y1, x2, y2);
    int ans = 0;
    for (int i = 1; i &amp;lt;= std::min(r, x2 - x1 + 1); i++) {
      for (int j = 1; j &amp;lt;= std::min(c, y2 - y1 + 1); j++) {
        if (B[i][j] == 0) {
          debug(i, j);
          int rx1 = x1 + i - 1;
          int rx2 = rx1 + (x2 - rx1) / r * r;
          int ry1 = y1 + j - 1;
          int ry2 = ry1 + (y2 - ry1) / c * c;
          debug(rx1, rx2, ry1, ry2);
          debug(rx1 - c, ry2 - r);

          int ret = pre[rx2][ry2];
          int rx1r = rx1 - r &amp;gt;= 0 ? pre[rx1 - r][ry2] : 0;
          int ry1c = ry1 - c &amp;gt;= 0 ? pre[rx2][ry1 - c] : 0;
          int rx1rry1c =
              rx1 - r &amp;gt;= 0 &amp;amp;&amp;amp; ry1 - c &amp;gt;= 0 ? pre[rx1 - r][ry1 - c] : 0;

          ret = (ret - rx1r + modd) % modd;
          ret = (ret - ry1c + modd) % modd;
          ret = (ret  + rx1rry1c) % modd;
          ans = (ans + ret) % modd;
        }
      }
    }
    std::cout &amp;lt;&amp;lt; ans &amp;lt;&amp;lt; &quot;\n&quot;;
  }
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>传智杯</category><author>Mslxl</author></item><item><title>The 2022 ICPC Asia Xian Regional Contest (CHGJ)</title><link>https://blog.mslxl.com/posts/cp/2022-icpc-asia-xian-regional-contest/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/cp/2022-icpc-asia-xian-regional-contest/</guid><pubDate>Tue, 13 Dec 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;只把签到题做了做。&lt;/p&gt;
&lt;p&gt;回头把剩下的题补一下&lt;/p&gt;
&lt;p&gt;听说今年要七道题才能铜 😂&lt;/p&gt;
&lt;h2&gt;&lt;a href=&quot;https://codeforces.com/gym/104077/problem/C&quot;&gt;C - Clone Ranran&lt;/a&gt;&lt;/h2&gt;
&lt;h4&gt;题目大意&lt;/h4&gt;
&lt;p&gt;然然要准备 $c$ 道题，它可以进行两种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;克隆一个自己，使自己的数量变为原来的二倍，这需要消耗 $a$ 分钟时间&lt;/li&gt;
&lt;li&gt;每个自己准备一道题，这需要消耗 $b$ 分钟的时间&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;然然不可能同时做两件事，问准备 $c$ 道题目最少用时。&lt;/p&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;p&gt;经过分析我们可以得知，先进行克隆操作总是不亏的，因为每次克隆操作都能使接下来用相同的时间
准备的题目数量增加2倍。而且我们一定是先进行完所有的克隆操作，最后再准备题目。&lt;/p&gt;
&lt;p&gt;那么什么时候停止克隆呢。我们可以计算每次克隆+准备所有题目的用时和不克隆准备所有题目的用时，
如果大于就不再克隆了。&lt;/p&gt;
&lt;p&gt;确定了这两点，代码就不难写了&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;
#define rep(NAME, MAX) for (int NAME = 0; NAME &amp;lt; MAX; i++)
#define rep1(NAME, MAX) for (int NAME = 1; NAME &amp;lt;= MAX; i++)
#define repv0(NAME, START) for (int NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for (int NAME = START; NAME &amp;gt;= 1; NAME--)

template &amp;lt;typename T&amp;gt;
typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;value) {
  value = 0;
  char ch = getchar();
  bool flag = false;
  while (!std::isdigit(ch)) {
    if (ch == &apos;-&apos;)
      flag = true;
    ch = getchar();
  }
  while (std::isdigit(ch)) {
    value = value * 10 + (ch - &apos;0&apos;);
    ch = getchar();
  }
  if (flag)
    value *= -1;
}

template &amp;lt;typename T, typename... A&amp;gt; void read(T &amp;amp;value, A &amp;amp;..._t) {
  read(value);
  read(_t...);
}

using ll = long long;
using ul = unsigned long long;
using ld = long double;

void solve() {
  ul a, b, c;
  read(a, b, c);

  ul ranran = 1;
  ul time = 0;
  while (std::ceil(1.0 * c / ranran) * b &amp;gt;
         a + std::ceil(1.0 * c / (ranran * 2)) * b) {
    ranran *= 2;
    time += a;
  }
  time += std::ceil(1.0 * c/ranran) * b ;

  std::cout &amp;lt;&amp;lt; time &amp;lt;&amp;lt; &quot;\n&quot;;
}

int main() {
  int t;
  read(t);
  rep(i, t) solve();
  return 0;
}

&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;https://vjudge.net/problem/Gym-104077F/origin&quot;&gt;F - Hotel&lt;/a&gt;&lt;/h2&gt;
&lt;h3&gt;题目大意&lt;/h3&gt;
&lt;p&gt;有 n 个队伍，每个队伍有3名成员，把他们安置在宾馆中。宾馆有单人间和双人间两种，
要求性别不同的人不能同住一间双人间，不同队伍的 人也不能同住一间双人间。&lt;/p&gt;
&lt;p&gt;单人间的花费为 $c_1$，双人间的花费为 $c_2$ ，问安置所有的队伍最小花费多少钱。&lt;/p&gt;
&lt;h3&gt;思路&lt;/h3&gt;
&lt;p&gt;按照性别数量贪就行了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;三个人性别都不一样，答案是 $min(3 * c_1, 3* c_2)$&lt;/li&gt;
&lt;li&gt;两个人性别一样，答案是 $min{3*c_1, c_2 + c_1}$&lt;/li&gt;
&lt;li&gt;三个人性别一样，答案是 $min{3*c_1, c_2 + c_1}$&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;代码&lt;/h3&gt;
&lt;pre&gt;&lt;code&gt;#include &amp;lt;bits/stdc++.h&amp;gt;

#define rep(NAME, MAX) for (int NAME = 0; NAME &amp;lt; MAX; i++)
#define rep1(NAME, MAX) for (int NAME = 1; NAME &amp;lt;= MAX; i++)
#define repv0(NAME, START) for (int NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for (int NAME = START; NAME &amp;gt;= 1; NAME--)

using ll = long long;
using ul = unsigned long long;
using ld = long double;

int main() {
#ifdef ONLINE_JUDGE
  std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);
#endif
  int numOfTeam, cost1, cost2;
  std::cin &amp;gt;&amp;gt; numOfTeam &amp;gt;&amp;gt; cost1 &amp;gt;&amp;gt; cost2;
  ll totalCost = 0;
  std::string team;
  std::getline(std::cin, team);
  rep(i, numOfTeam) {
    std::getline(std::cin, team);
    std::set&amp;lt;char&amp;gt; set(team.begin(), team.end());
    if (set.size() == 3) {
      totalCost += std::min(3 * cost1, 3 * cost2);
    } else if (set.size() == 2) {
      totalCost += std::min(
          3 * cost1, std::min(cost1 + cost2, std::min(2 * cost1 + cost2, 2 *cost2)));
    } else if (set.size() == 1) {
      totalCost += std::min(3 * cost1, std::min(2 * cost2, cost1 + cost2));
    }
  }
  std::cout &amp;lt;&amp;lt; totalCost &amp;lt;&amp;lt; &quot;\n&quot;;

  return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;&lt;a href=&quot;https://codeforces.com/gym/104077/problem/G&quot;&gt;G - Prefect Word&lt;/a&gt; 递推&lt;/h2&gt;
&lt;h4&gt;题目大意&lt;/h4&gt;
&lt;p&gt;给予 $n$ 个字符串，在里面找到 prefect 字符串，它的所有非空字字符串在给的字符串中都出现过。输出这个 prefect 字符串
的长度。&lt;/p&gt;
&lt;h4&gt;思路&lt;/h4&gt;
&lt;p&gt;首先可以确定，如果所有的字符串的长度都是1，答案是1。&lt;/p&gt;
&lt;p&gt;若字符串$s$长度为2，$s[0:0]$和$s[1:1]$一定在所有给的字符串中出现过&lt;/p&gt;
&lt;p&gt;若字符串长度为3，它的$s[0:0]$，$s[1:1]$，$s[2:2]$,$s[0:1]$，$s[1:2]$一定也出现过，但是由于我们之前判断过$s[0:1]$合法，因此我们现在只需要判断$s[1:2]$合发法即可（$s[1:2]$如果合法，也包含了$s[2:2]$出现过）。&lt;/p&gt;
&lt;p&gt;继续，若字符串长度为$4$，由于我们之前判断了 $s[0,2]$合法，因此现在我们只需要判断$s[1:3]$合法即可。&lt;/p&gt;
&lt;p&gt;一旦所有长度为$t$的字符串判断失败时，答案即为$t-1$&lt;/p&gt;
&lt;h4&gt;代码&lt;/h4&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;

#define rep(NAME, MAX) for(int NAME = 0; NAME &amp;lt; MAX; i++)
#define rep1(NAME, MAX) for(int NAME = 1; NAME &amp;lt;= MAX; i++)
#define repv0(NAME, START) for(int NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(int NAME = START; NAME &amp;gt;= 1; NAME--)

using ll = long long;
using ul = unsigned long long;
using ld = long double;

// ------------ Minify with Regex &quot;^\s*(?!#)(.*)\n&quot; -&amp;gt; &quot;$1 &quot; ------------
template &amp;lt;class A, class B&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::pair&amp;lt;A, B&amp;gt; const &amp;amp;a) { return s &amp;lt;&amp;lt; &quot;(&quot; &amp;lt;&amp;lt; std::get&amp;lt;0&amp;gt;(a) &amp;lt;&amp;lt; &quot;, &quot; &amp;lt;&amp;lt; std::get&amp;lt;1&amp;gt;(a) &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;gt;= sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;) {} template &amp;lt;size_t n, typename... T&amp;gt; typename std::enable_if&amp;lt;(n &amp;lt; sizeof...(T))&amp;gt;::type print_tuple(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { if (n != 0) os &amp;lt;&amp;lt; &quot;, &quot;; os &amp;lt;&amp;lt; std::get&amp;lt;n&amp;gt;(tup); print_tuple&amp;lt;n + 1&amp;gt;(os, tup); } template &amp;lt;typename... T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;os, const std::tuple&amp;lt;T...&amp;gt; &amp;amp;tup) { os &amp;lt;&amp;lt; &quot;(&quot;; print_tuple&amp;lt;0&amp;gt;(os, tup); return os &amp;lt;&amp;lt; &quot;)&quot;; } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;print_collection(std::ostream &amp;amp;s, T const &amp;amp;a) { s &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = std::begin(a); it != std::end(a); ++it) { s &amp;lt;&amp;lt; *it; if (it != std::prev(end(a))) s &amp;lt;&amp;lt; &quot;, &quot;; } return s &amp;lt;&amp;lt; &apos;]&apos;; } template &amp;lt;class T, class U&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::map&amp;lt;T, U&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::set&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } template &amp;lt;class T&amp;gt; std::ostream &amp;amp;operator&amp;lt;&amp;lt;(std::ostream &amp;amp;s, std::vector&amp;lt;T&amp;gt; const &amp;amp;a) { return print_collection(s, a); } void __debug_out() { std::cerr &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename T, class = typename std::enable_if&amp;lt;std::is_pointer&amp;lt;T&amp;gt;::value&amp;gt;::type&amp;gt; void __debug_out(T beg, T end) { std::cerr &amp;lt;&amp;lt; &apos;[&apos;; for (auto it = beg; it != end; it++) { std::cerr &amp;lt;&amp;lt; *it; if (it != std::prev(end)) { std::cerr &amp;lt;&amp;lt; &quot;, &quot;; } } std::cerr &amp;lt;&amp;lt; &apos;]&apos; &amp;lt;&amp;lt; std::endl; } template &amp;lt;typename H, typename... Tail&amp;gt; void __debug_out(H h, Tail... T) { std::cerr &amp;lt;&amp;lt; &quot; &quot; &amp;lt;&amp;lt; h; __debug_out(T...); }
#ifndef ONLINE_JUDGE
#define debug(...) std::cerr &amp;lt;&amp;lt; &quot;[&quot; &amp;lt;&amp;lt; #__VA_ARGS__ &amp;lt;&amp;lt; &quot;]:&quot;, __debug_out(__VA_ARGS__)
#else
#define debug(...) do {} while (0)
#endif
// Codes Below

int main(){
  #ifdef ONLINE_JUDGE
    std::ios::sync_with_stdio(false);
  std::cin.tie(nullptr);
  std::cout.tie(nullptr);
  #endif
  ll n;
  std::cin &amp;gt;&amp;gt; n;
  std::vector&amp;lt;std::string&amp;gt; words(n);
  ll maxlen = 0;
  rep(i, n) {
    std::cin &amp;gt;&amp;gt; words[i];
    maxlen = std::max(ll(words[i].size()), maxlen);
  }

  if(maxlen == 1){
    std::cout &amp;lt;&amp;lt; 1;
    return 0;
  }

  std::sort(words.begin(), words.end(), [](const std::string &amp;amp;l, const std::string&amp;amp; r){
    return l.size() &amp;lt; r.size();
  });

  ll len = 1;
  for(auto iter = words.begin(); iter != words.end(); iter++){
    if(iter-&amp;gt;size() - len &amp;gt; 1){
      // after is impossible
      words.erase(iter, words.end());
      break;
    }else{
      len = iter-&amp;gt;size();
    }
  }

  std::set&amp;lt;std::string&amp;gt; exists;
  len = 0;
  rep(i, words.size()){
    if(words[i].size() == 1){
      exists.insert(words[i]);
      len = std::max(len, ll(words[i].size()));
    }else if(exists.count(words[i].substr(0, words[i].size()-1)) &amp;amp;&amp;amp; exists.count(words[i].substr(1, words[i].size() - 1)) ){
      exists.insert(words[i]);
      len = std::max(len, ll(words[i].size()));
    }
  }
  std::cout &amp;lt;&amp;lt; len;
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;h1&gt;J - Strange Sum&lt;/h1&gt;
&lt;pre&gt;&lt;code&gt;#include&amp;lt;bits/stdc++.h&amp;gt;
#define rep(NAME, MAX) for(decltype(MAX) NAME = 0; NAME &amp;lt; MAX; i++)
#define rep1(NAME, MAX) for(decltype(MAX) NAME = 1; NAME &amp;lt;= MAX; i++)
#define repv0(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 0; NAME--)
#define repv1(NAME, START) for(decltype(START) NAME = START; NAME &amp;gt;= 1; NAME--)
template &amp;lt;typename T&amp;gt;
typename std::enable_if&amp;lt;std::is_integral&amp;lt;T&amp;gt;::value&amp;gt;::type read(T &amp;amp;value) {
  value = 0;
  char ch = getchar();
  bool flag = false;
  while (!std::isdigit(ch)) {
    if (ch == &apos;-&apos;)
      flag = true;
    ch = getchar();
  }
  while (std::isdigit(ch)) {
    value = value * 10 + (ch - &apos;0&apos;);
    ch = getchar();
  }
  if (flag)
    value *= -1;
}

template &amp;lt;typename T, typename... A&amp;gt; void read(T &amp;amp;value, A &amp;amp;..._t) {
  read(value);
  read(_t...);
}
using ll = long long;
using ul = unsigned long long;
using ld = long double;

int main(){
  ll n;
  read(n);
  std::vector&amp;lt;ll&amp;gt; seq(n);
  rep(i, n) read(seq[i]);
  std::sort(seq.begin(), seq.end());
  std::cout &amp;lt;&amp;lt; std::max(0LL, std::max(seq[n-1], n &amp;gt;= 2? seq[n-1] + seq[n-2]: 0LL));
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
</content:encoded><category>Competitive Programming</category><category>ICPC</category><author>Mslxl</author></item><item><title>Dev-C++ OpenCV 环境搭建</title><link>https://blog.mslxl.com/posts/others/opencv-env/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/opencv-env/</guid><pubDate>Fri, 14 Oct 2022 00:00:00 GMT</pubDate><content:encoded>&lt;blockquote&gt;
&lt;p&gt;该文章写于 2022 年十月，部分内容可能已经过时
此文目的为实验室同学参考，个人还是推荐尽早换下 Dev&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;用 CodeBlock(MinGW-make) 理论上配置差别不大，可以参考下。&lt;/p&gt;
&lt;p&gt;用 Visual Studio 的话网上全是教程，直接百度就行。&lt;/p&gt;
&lt;h2&gt;需要准备的软件&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Dev-C++ 或 RedPanda C++&lt;/li&gt;
&lt;li&gt;MinGW 或 msys2-mingw32 (一般安装 Dev-C++ 时会同时安装)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://opencv.org/releases&quot;&gt;OpenCV Source&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://cmake.org/download/&quot;&gt;CMake&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;步骤&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;下载 OpenCV 源代码&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由于新版的 OpenCV 不提供 gcc 的编译，而 Dev-C++ 只能使用 gcc 编译器，所以我们需要自行使用 gcc 编译 OpenCV&lt;/p&gt;
&lt;p&gt;从 &lt;a href=&quot;https://opencv.org/releases/&quot;&gt;OpenCV Releases Page&lt;/a&gt; 下载源代码，注意选择 Source&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;src.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;下载完成后进行解压（这里解压到 &lt;code&gt;D:\Code\opencv\opencv-4.6.0&lt;/code&gt; )&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置 OpenCV 编译环境&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 &lt;code&gt;Dev-C++&lt;/code&gt; 的安装目录找到 &lt;code&gt;MinGW&lt;/code&gt; 目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;mingw.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;将 &lt;code&gt;MinGW\bin&lt;/code&gt; 添加到 Path 环境变量中（具体方法参考百度）&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编译 OpenCV&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;打开命令行，进入 opencv 的代码文件夹&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;pwd.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;依次执行下列命令&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;mkdir build #创建 build 文件夹
cd build #进入 build 文件夹
cmake -G &quot;MinGW Makefiles&quot; .. #生成 makefile
mingw32-make #根据 makefile 编译
mingw32-make install
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在执行 cmake 的时候可能会下载其他依赖，这个过程比较慢，&lt;s&gt;有科技手段的话可以用点科技手段&lt;/s&gt;
执行 &lt;code&gt;mingw-make&lt;/code&gt; 时可以使用 &lt;code&gt;-j&lt;/code&gt; 参数指定进程数量&lt;/p&gt;
&lt;p&gt;最终编译后的文件将保存在代码目录下的 &lt;code&gt;build/install&lt;/code&gt; 下&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;done.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;配置 IDE&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在 Dev-C++ 中编译器配置里&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果你是RedPanda，那么编译器配置在&lt;code&gt;菜单栏-Tools-Options-Compiler-Compiler Set&lt;/code&gt; 中&lt;/li&gt;
&lt;li&gt;如果你是Dev-C++，那么编译器配置在 &lt;code&gt;菜单栏-Tools-Compiler Tools&lt;/code&gt; 中&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;打开编译器配置，在 &lt;code&gt;Binary&lt;/code&gt; 中添加 &lt;code&gt;build\install\x64\mingw\bin&lt;/code&gt; 目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;bin.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;Library&lt;/code&gt; 中添加 &lt;code&gt;build\install\x64\mingw\lib&lt;/code&gt; 目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;lib.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在 &lt;code&gt;C++ Include&lt;/code&gt; 中添加 &lt;code&gt;build\install\include&lt;/code&gt; 目录&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;inc.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;在 Linker 参数中加入以下链接库&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;-lopencv_highgui460.dll -lopencv_calib3d460.dll -lopencv_core460.dll -lopencv_dnn460.dll -lopencv_features2d460.dll -lopencv_flann460.dll -lopencv_gapi460.dll -lopencv_imgcodecs460.dll -lopencv_imgproc460.dll -lopencv_ml460.dll -lopencv_objdetect460.dll -lopencv_photo460.dll -lopencv_stitching460.dll -lopencv_video460.dll -lopencv_videoio460.dll
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img src=&quot;linker.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;p&gt;至此，OpenCV 环境配置完成&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;需注意&lt;/strong&gt;，以上配置应对同一组编译器配置，而且使用的编译器配置应当和设置的编译器配置一致。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;set.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;测试&lt;/li&gt;
&lt;/ol&gt;
&lt;pre&gt;&lt;code&gt;#include &quot;opencv2/highgui.hpp&quot;
int main(){
    cv::namedWindow(&quot;Test Windows&quot;);
    cv::waitKey();
    return 0;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;试试这个段代码，这段代码将会创建一个空白窗口&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;prev.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;
</content:encoded><category>C++</category><category>OpenCV</category><author>Mslxl</author></item><item><title>使用 ts 实现 Parser 组合子</title><link>https://blog.mslxl.com/posts/others/ts-combinator/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/ts-combinator/</guid><pubDate>Fri, 07 Oct 2022 12:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Parser 组合子(Parser Combinator) 可用于实现词法分析器或者 LL 语法分析器，它的实现较为简单，但缺点是运行效率较低(尤其是在组合层数较多时)，在对性能要求不高时可采用 Parser 组合子来进行解析任务。&lt;/p&gt;
&lt;p&gt;本文最终会实现这样的 Parser Combinator:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const input = &apos;114514aabbcc&apos;

const result = parser.digit1()(input)
console.log(result)

// { kind: &apos;Right&apos;, right: { first: &apos;aabbcc&apos;, second: &apos;114514&apos; } }
&lt;/code&gt;&lt;/pre&gt;
&lt;hr /&gt;
&lt;h2&gt;准备: &lt;code&gt;Either&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;要表示 Parser Combinator，首先要先分别表示出 parse 成功和失败的两种状态。
本文采用了类似 &lt;code&gt;Either&lt;/code&gt; 的概念，其 Left 储存错误信息，而 Right 储存匹配成功项和剩余项。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export interface Left&amp;lt;E&amp;gt; {
  readonly kind: &apos;Left&apos;
  left: E
}

export interface Right&amp;lt;E&amp;gt; {
  readonly kind: &apos;Right&apos;
  right: E
}

export type Either&amp;lt;L, R&amp;gt; = Left&amp;lt;L&amp;gt; | Right&amp;lt;R&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;为了方便对 &lt;code&gt;Either&lt;/code&gt; 的基本操作，我们添加以下代码:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export interface Pair&amp;lt;F, S&amp;gt; {
  first: F
  second: S
}

export function left&amp;lt;L, R = never&amp;gt;(value: L): Either&amp;lt;L, R&amp;gt; {
  return {
    kind: &apos;Left&apos;,
    left: value
  }
}

export function right&amp;lt;R, L = never&amp;gt;(value: R): Either&amp;lt;L, R&amp;gt; {
  return {
    kind: &apos;Right&apos;,
    right: value
  }
}

export function is_left&amp;lt;L = never, R = never&amp;gt;(either: Either&amp;lt;L, R&amp;gt;): boolean {
  return either.kind == &apos;Left&apos;
}
export function is_right&amp;lt;L = never, R = never&amp;gt;(either: Either&amp;lt;L, R&amp;gt;): boolean {
  return either.kind == &apos;Right&apos;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;left&lt;/code&gt; 和 &lt;code&gt;right&lt;/code&gt; 用于构造一个 &lt;code&gt;Either&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;第一个 Parser 组合子: &lt;code&gt;text&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;有了这些准备，我们就可以实现一个最简单的 Parser 组合子了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;type Parser&amp;lt;E, L&amp;gt; = (input: string) =&amp;gt; either.Either&amp;lt;L, Pair&amp;lt;string, E&amp;gt;&amp;gt;

export function text(expect: string): Parser&amp;lt;string, string&amp;gt; {
  return function (input: string): either.Either&amp;lt;string, Pair&amp;lt;string, string&amp;gt;&amp;gt; {
    if (input.startsWith(expect)) {
      return either.right({ first: input.substring(expect.length), second: expect })
    }
    else {
      return either.left(expect)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;如果 &lt;code&gt;input&lt;/code&gt; 是以 &lt;code&gt;expect&lt;/code&gt; 开头的字符串，则返回 &lt;code&gt;Right&lt;/code&gt; 表示匹配成功，否则返回 &lt;code&gt;Left&lt;/code&gt; 表示失败。这样我们就可以使用 text 来匹配特定的字符了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;const input = &apos;114514abababa&apos;
const result = text(&apos;114&apos;)(input)
console.log(result)
// { kind: &apos;Right&apos;, right: { first: &apos;514abababa&apos;, second: &apos;114&apos; } }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;很明显这远远不够，因为有时我们不能确定要匹配的文本出现顺序，比方说我们要匹配一个数字，但是不能确定数字是什么，使用 &lt;code&gt;text&lt;/code&gt; 就无能为力了，这时候我们就需要一个新的组合子来修饰旧组合子了。&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;oneOf&lt;/code&gt; Parser 组合子&lt;/h2&gt;
&lt;p&gt;我们在下面实现一个 &lt;code&gt;oneOf&lt;/code&gt; 组合子，它将从提供的所有 Parser 组合子中选择第一个匹配成功项并返回。&lt;/p&gt;
&lt;p&gt;从一系列结果中选择成功项很容易让我们联想到 &lt;code&gt;Alternative&lt;/code&gt; 的性质，所以让我们先让结果 &lt;code&gt;Either&lt;/code&gt; 能进行 &lt;code&gt;Alternative&lt;/code&gt; 的运算吧(即实现 &lt;code&gt;alt&lt;/code&gt; 和 &lt;code&gt;map&lt;/code&gt; 函数)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export function map&amp;lt;L, R, E&amp;gt;(either: Either&amp;lt;L, R&amp;gt;, block: (right: R) =&amp;gt; E): Either&amp;lt;L, E&amp;gt; {
  if (either.kind == &apos;Right&apos;) {
    const value = block(either.right)
    return right(value)
  }
  else {
    return either as Either&amp;lt;L, E&amp;gt;
  }
}

export function alt&amp;lt;L, R&amp;gt;(...either: Either&amp;lt;L, R&amp;gt;[]): Either&amp;lt;L, R&amp;gt; {
  return either.reduce((p, c) =&amp;gt; {
    if (p.kind == &apos;Right&apos;)
      return p
    else return c
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;code&gt;map&lt;/code&gt; 会对 &lt;code&gt;Right&lt;/code&gt; 中的元素进行操作，原样返回 &lt;code&gt;Left&lt;/code&gt; 中的元素，&lt;code&gt;alt&lt;/code&gt; 则会选择第一个 &lt;code&gt;Right&lt;/code&gt;，抛弃前面的所有 &lt;code&gt;Left&lt;/code&gt;（放在 Haskell 上也就是使 &lt;code&gt;Either&lt;/code&gt; 是 &lt;code&gt;Alternative&lt;/code&gt; 的一个实现）&lt;/p&gt;
&lt;p&gt;有了 &lt;code&gt;alt&lt;/code&gt;， 我们很容易实现 &lt;code&gt;oneOf&lt;/code&gt; 函数。只需要从所有匹配结果中选择第一个成功项即可（即 &lt;code&gt;Right&lt;/code&gt;)&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export function oneOf&amp;lt;E, L&amp;gt;(...parsers: Parser&amp;lt;E, L&amp;gt;[]): (input: string) =&amp;gt; either.Either&amp;lt;L, Pair&amp;lt;string, E&amp;gt;&amp;gt; {
  return function (input: string): either.Either&amp;lt;L, Pair&amp;lt;string, E&amp;gt;&amp;gt; {
    return parsers
      .map(p =&amp;gt; p(input))
      .reduce((c, p) =&amp;gt; either.alt(c, p))
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;让我们来试着匹配任一个数字:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export function digit1(): Parser&amp;lt;string, string&amp;gt; {
  const digit = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  const digitParser = digit.map(i =&amp;gt; text(i.toString()))
  return oneOf(...digitParser)
}

digit1()(&apos;1145aa&apos;)
// { kind: &apos;Right&apos;, right: { first: &apos;145aa&apos;, second: &apos;1&apos; } }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么如果我们想要匹配一串数字怎么办？这时候就要借助 &lt;code&gt;many&lt;/code&gt; 了&lt;/p&gt;
&lt;h2&gt;&lt;code&gt;many&lt;/code&gt; Parser 组合子&lt;/h2&gt;
&lt;p&gt;让我们先理一下 &lt;code&gt;many&lt;/code&gt; 的行为。&lt;code&gt;many&lt;/code&gt; 会不停的使用提供的组合子进行匹配，直到匹配失败为止，以数组的形式返回之前的匹配成功项。&lt;/p&gt;
&lt;p&gt;下面是代码，&lt;s&gt;写的有点摸鱼，但是能用&lt;/s&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export function many0&amp;lt;E, L&amp;gt;(parser: Parser&amp;lt;E, L&amp;gt;): Parser&amp;lt;E[], L&amp;gt; {
  return function (input: string): either.Either&amp;lt;L, Pair&amp;lt;string, E[]&amp;gt;&amp;gt; {
    const result: E[] = []
    let err: L = null
    let success = false
    while (true) {
      const v = parser(input)
      if (either.is_left(v)) {
        err = (v as either.Left&amp;lt;L&amp;gt;).left
        break
      }
      else {
        success = true
        const rv = v as either.Right&amp;lt;Pair&amp;lt;string, E&amp;gt;&amp;gt;
        input = rv.right.first
        result.push(rv.right.second)
      }
    }
    if (success) {
      return either.right({ first: input, second: result })
    }
    else {
      return either.left(err)
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;让我们用 &lt;code&gt;many&lt;/code&gt; 和 &lt;code&gt;oneOf&lt;/code&gt; 试着匹配一串数字，修改 &lt;code&gt;digit1&lt;/code&gt; 函数如下:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export function digit1(): Parser&amp;lt;string, string&amp;gt; {
  const digit = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  const digitParser = digit.map(i =&amp;gt; text(i.toString()))
  return many0(oneOf(...digitParser))
}

digit1()(&apos;114aba&apos;)

// { kind: &apos;Right&apos;, right: { first: &apos;aba&apos;, second: [&apos;1&apos;, &apos;1&apos;, &apos;4&apos;] } }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;似乎成功了，但是返回结果是 &lt;code&gt;[&apos;1&apos;, &apos;1&apos;, &apos;4&apos;]&lt;/code&gt;，我们想要的是 &lt;code&gt;114&lt;/code&gt;，怎么办？&lt;/p&gt;
&lt;p&gt;很遗憾没有办法，parser 组合子就是从最小的单位开始匹配，匹配结果理所当然的是一个一个的最小单元，但是你可以在 &lt;code&gt;many&lt;/code&gt; 中将这些元素拼起来(不推荐)，或者再创建一个用于处理匹配结果的组合子。&lt;/p&gt;
&lt;p&gt;这里利用 &lt;code&gt;Either&lt;/code&gt; 的 &lt;code&gt;map&lt;/code&gt; 再写一个 &lt;code&gt;map&lt;/code&gt; 组合子用于处理匹配结果：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export function map&amp;lt;E, L, R&amp;gt;(parser: Parser&amp;lt;E, L&amp;gt;, block: (e: E) =&amp;gt; R): Parser&amp;lt;R, L&amp;gt; {
  return function (input: string): either.Either&amp;lt;L, Pair&amp;lt;string, R&amp;gt;&amp;gt; {
    return either.map(parser(input), (r) =&amp;gt; {
      const result = block(r.second)
      return { first: r.first, second: result }
    })
  }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;再改造一下 &lt;code&gt;digit1&lt;/code&gt; 函数：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;export function digit1(): Parser&amp;lt;string, string&amp;gt; {
  const digit = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
  const digitParser = digit.map(i =&amp;gt; text(i.toString()))
  return map(many0(oneOf(...digitParser)), (e) =&amp;gt; {
    return e.reduce((p, c) =&amp;gt; p + c)
  })
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;现在我们已经可以用 &lt;code&gt;digit1&lt;/code&gt; 来愉快的匹配数字了&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;digit1()(&apos;114514ababab&apos;)
// { kind: &apos;Right&apos;, right: { first: &apos;ababab&apos;, second: &apos;114514&apos; } }
digit1()(&apos;66ccff&apos;)
// { kind: &apos;Right&apos;, right: { first: &apos;ccff&apos;, second: &apos;66&apos; } }
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当然， Parser 组合子还不仅如此，你还可以写出 &lt;code&gt;optional&lt;/code&gt; 等等组合子，或者写出自己想要的组合子。Parser 组合子也不止可以处理字符串，只需改动少量代码，上述代码便可处理任意序列&lt;/p&gt;
&lt;p&gt;这里有一份 Json 解析器是用 Haskell 写的 Parser 组合子，可共参考 &lt;a href=&quot;https://github.com/mslxl/MeoAssistantArknightsCLI/blob/main/app/JsonParser.hs&quot;&gt;JsonParser.hs&lt;/a&gt;&lt;/p&gt;
</content:encoded><category>TypeScript</category><author>Mslxl</author></item><item><title>关于消失的页面</title><link>https://blog.mslxl.com/posts/others/2022-dispearpage/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/2022-dispearpage/</guid><pubDate>Fri, 22 Jul 2022 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;突然发现之前有些文章全是黑历史，全删了*(:3」∠)*。 再换一个简单的主题，原先的主题感觉有点喧宾夺主。&lt;/p&gt;
&lt;p&gt;内容的话有时间再整理一下。&lt;/p&gt;
</content:encoded><author>Mslxl</author></item><item><title>使用 Doom Emacs 工作</title><link>https://blog.mslxl.com/posts/tools/doomemacs/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/tools/doomemacs/</guid><pubDate>Mon, 30 Aug 2021 00:00:00 GMT</pubDate><content:encoded>&lt;h1&gt;Table of Contents&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#table-of-contents&quot;&gt;Table of Contents&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AE%89%E8%A3%85&quot;&gt;安装&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E9%A1%B9%E7%9B%AE%E4%B8%8E%E5%B7%A5%E4%BD%9C%E7%A9%BA%E9%97%B4-projects-and-workspaces&quot;&gt;项目与工作空间 (Projects and Workspaces)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%B8%B8%E8%A7%81%E4%BB%BB%E5%8A%A1-common-tasks&quot;&gt;常见任务 (Common Tasks)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%AF%BB%E6%89%BE%E6%96%87%E6%9C%AC-finding-text&quot;&gt;寻找文本 (Finding Text)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9C%A8%E6%96%87%E6%9C%AC%E9%97%B4%E7%A7%BB%E5%8A%A8-moving-to-text&quot;&gt;在文本间移动 (Moving To Text)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%89%A9%E5%A4%A7%E5%92%8C%E7%BC%A9%E5%B0%8F%E8%8C%83%E5%9B%B4-narrowing-and-widening-regions&quot;&gt;扩大和缩小范围 (Narrowing and Widening Regions)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%A4%9A%E5%85%89%E6%A0%87-multiple-cursors&quot;&gt;多光标 (Multiple Cursors)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%92%A4%E9%94%80%E4%B8%8E%E9%87%8D%E5%81%9A-undoing-and-redoing&quot;&gt;撤销与重做 (Undoing and Redoing)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E5%9C%A8%E7%BC%96%E8%AF%91%E8%BE%93%E5%87%BA%E9%97%B4%E5%AF%BC%E8%88%AA-navigating-compliation-output&quot;&gt;在编译输出间导航 (Navigating Compliation Output)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E6%9D%82%E9%A1%B9&quot;&gt;杂项&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;#%E4%BA%86%E8%A7%A3%E6%9B%B4%E5%A4%9A-doom&quot;&gt;了解更多 Doom&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;原文: &lt;a href=&quot;https://noelwelsh.com/posts/doom-emacs/&quot;&gt;Doom Emacs Workflows&lt;/a&gt; 发布于 2019 年 2 月 15日，部分功能可能已发生变化。&lt;/p&gt;
&lt;p&gt;我最近放弃了 Spacemacs, 开始使用 &lt;a href=&quot;https://github.com/hlissner/doom-emacs&quot;&gt;Doom Emacs&lt;/a&gt;. 目前为止，Doom Emacs 的文档仍十分简陋，所以我用 Doom Emacs 写了这篇个人笔记来介绍我的工作流（包含一些我认为比较重要但是缺少文档的功能）。&lt;/p&gt;
&lt;p&gt;如果你有下面的情况，Doom 也许就很适合你：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;喜欢 Emacs 又想使用 Vim 的按键绑定&lt;/li&gt;
&lt;li&gt;没有时间配置像是 helm 之类的优秀插件&lt;/li&gt;
&lt;li&gt;感觉 Spacemacs 太慢&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这篇文章并不打算介绍 Emacs 的运行方式和基础的 Vim 按键绑定，而是把焦点放在我认为出类拔萃的地方&lt;/p&gt;
&lt;p&gt;&amp;lt;a id=&quot;org6a62219&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;安装&lt;/h1&gt;
&lt;p&gt;一定要使用 &lt;code&gt;develop&lt;/code&gt; 分支，不是 &lt;code&gt;master&lt;/code&gt; ! 使用 &lt;code&gt;develop&lt;/code&gt; 分支需要&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;git clone https://github.com/hlissner/doom-emacs ~/.emacs.d
cd ~/.emacs.d
git checkout develop
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;然后运行 &lt;code&gt;bin/doom quickstart&lt;/code&gt; 即可完成安装。之后您可以运行 &lt;code&gt;bin/doom help&lt;/code&gt; 查看可用命令。&lt;/p&gt;
&lt;p&gt;&amp;lt;a id=&quot;org8fec0f7&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;项目与工作空间 (Projects and Workspaces)&lt;/h1&gt;
&lt;p&gt;我发现使用项目与工作空间来管理工作十分有用。我从中得到了两点好处：从当前项目中寻找东西更快，还可以快速方便的通过保存和恢复 window 和 buffer 配置来回到工作。在 Doom 中，这些功能由 &lt;code&gt;projectile&lt;/code&gt; 和 &lt;code&gt;persp-mode&lt;/code&gt; 实现。&lt;/p&gt;
&lt;p&gt;基本工作流程如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;判断我自己要做什么。是单独的一个项目，还是涉及多个项目 (例如管理 Todo 列表)，亦或是不需要在项目中保存 (像是进行在 scratch buffer 中快速计算)？如果是单独的项目，就把它放到一个属于它的工作空间中，否则就把它放在默认工作空间中（main)&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;SPC TAB .&lt;/code&gt; 切换到恰当的工作空间。如果这个工作空间并没有显示，那么就用 &lt;code&gt;SPC TAB l&lt;/code&gt; 加载这个工作空间，或者使用 &lt;code&gt;SPC TAB n&lt;/code&gt; 创建一个新工作空间。就我个人而言，我经常用 &lt;code&gt;SPC TAB r&lt;/code&gt; 来使工作空间的命名中包含更多信息，然后用 &lt;code&gt;SPC TAB s&lt;/code&gt; 保存。&lt;/li&gt;
&lt;li&gt;当我切换到一个已存在的工作空间时，Emacs 会恢复到我上次在项目的工作状态，这样我可以直接开始工作。不然我会使用 &lt;code&gt;SPC p p&lt;/code&gt; 来选择一个项目来继续工作。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有三个命令非常有用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SPC SPC&lt;/code&gt; 在当前项目中切换文件，支持模糊搜索&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPC ,&lt;/code&gt; 在项目中切换 buffer, 同样支持模糊搜索&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPC f r&lt;/code&gt; 打开最近浏览的文件&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;a id=&quot;org7198548&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;常见任务 (Common Tasks)&lt;/h1&gt;
&lt;p&gt;我经常使用的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SPC :&lt;/code&gt; 而非 &lt;code&gt;M x&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPC g g&lt;/code&gt; 打开 &lt;a href=&quot;https://magit.vc/&quot;&gt;Magit&lt;/a&gt;, 这是我唯一使用 Git 的方式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我偶尔使用的有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SPC .&lt;/code&gt; 打开一个文件。值得一提的是使用 &lt;code&gt;SPC SPC&lt;/code&gt; 比使用这个要快，只有当你要打开当前项目之外的文件时才会使用这个命令&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPC b B&lt;/code&gt; 切换到当前项目外的 buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;a id=&quot;org747bd18&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;寻找文本 (Finding Text)&lt;/h1&gt;
&lt;p&gt;如果你知道有某个文本存在，却不知道它的位置，有两种方式可以找到它：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;SPC s p&lt;/code&gt; 搜索当前项目中的所有文件 （按下 &lt;code&gt;SPC s&lt;/code&gt; 后等待弹窗出现可以了解其他选项)。您可以在搜索结果的 buffer 中使用 &lt;code&gt;Return&lt;/code&gt; 跳转到该位置，或者使用 &lt;code&gt;C-c C-e&lt;/code&gt; 来编辑所有的搜索结果。无论您修改了什么，您都可以使用 &lt;code&gt;C-c C-c&lt;/code&gt; 来保存修改，或者使用 &lt;code&gt;C-c C-k&lt;/code&gt; 放弃保存。这对于简单或者复杂的编辑多个文件中的内容都特别有用。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt; 在当前 buffer 中搜索。使用 &lt;code&gt;n&lt;/code&gt; 和 &lt;code&gt;N&lt;/code&gt; 分别跳转的下一个搜索结果和上一个搜索结果。 (使用 &lt;code&gt;?&lt;/code&gt; 可以向上搜索)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;a id=&quot;orgdeef4b5&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;在文本间移动 (Moving To Text)&lt;/h1&gt;
&lt;p&gt;当您在屏幕上看到某个特定文字时，有很多方式可让您快速的将光标移动到那里：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;s&lt;/code&gt; 然后输入两个字符，您就能跳转的当前位置下方的最近的匹配项，用 &lt;code&gt;S&lt;/code&gt; 则可以向上跳转。输入 &lt;code&gt;,&lt;/code&gt; 可以继续跳转到该 buffer 中的上一项，=;= 则能跳转到下一项。通常配置下，这些功能只会跳转到当前行中的匹配结果，但是如果您多次输入 &lt;code&gt;,&lt;/code&gt; 或 &lt;code&gt;;&lt;/code&gt; ，您就可以在整个 buffer 中进行跳转操作。这是 &lt;a href=&quot;https://github.com/hlissner/evil-snipe&quot;&gt;evil-snipe&lt;/a&gt; 的功能。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g s SPC&lt;/code&gt; ，然后键入你想找的文字。当没有歧义时，您可以直接跳转到那里，否则需要使用特定的字母组合来选择位置。如果您在 &lt;code&gt;config.el&lt;/code&gt; 文件中配置了 &lt;code&gt;(seq avy-all-windows t)&lt;/code&gt; ，则会在所有的可见窗口中进行匹配。我比较喜欢这个功能，因为他能让我在屏幕中快速跳转。该功能使用了 &lt;a href=&quot;https://github.com/abo-abo/avy&quot;&gt;Avy&lt;/a&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;g s&lt;/code&gt; 后等待弹窗出现可以了解其他选项，其实我并没有真正使用过这个，因为上面的两个方法完全可以满足我的需求，但是或许我在这里错过了什么。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当我想跳转到的位置和现在的位置比较近时，我会使用 evil-snipe (&lt;code&gt;s&lt;/code&gt; 和 &lt;code&gt;S&lt;/code&gt;)。如果位置较远或在另一个窗口，我会使用 Avy (&lt;code&gt;g s SPC&lt;/code&gt;)。它们都能用来选择文本，假如我们有这样的一串文本：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;Just some example text
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;当光标位于 &lt;code&gt;J&lt;/code&gt; 时，如果我们想选中 &lt;code&gt;Just some example&lt;/code&gt; 。我们可以用 &lt;code&gt;v3e&lt;/code&gt; ，但如果这样我们就需要去查单词的数量（还要记住 &lt;code&gt;e&lt;/code&gt; 和 &lt;code&gt;w&lt;/code&gt; 的区别），因此，我们可以用 &lt;code&gt;vsle&lt;/code&gt; 。 &lt;code&gt;s&lt;/code&gt; 表示使用 evil-snipe , &lt;code&gt;le&lt;/code&gt; 则是我们找的两个字母。我们也可以用 &lt;code&gt;vgs SPC le&lt;/code&gt; 来使用 Avy (然后我们需要把光标向右移动一个字母)。&lt;/p&gt;
&lt;p&gt;使用 evil-snipe 有点复杂。它把选择命令绑定到了 &lt;code&gt;s&lt;/code&gt; 键上，但是其他一些指令（例如 yank, 或者说 &lt;code&gt;y&lt;/code&gt;) 被 &lt;a href=&quot;https://github.com/emacs-evil/evil-surround&quot;&gt;evil-surround&lt;/a&gt; 绑定到了 &lt;code&gt;s&lt;/code&gt; 上。在这种情况下， evil-snipe 被绑定到了 &lt;code&gt;z&lt;/code&gt; 键（ &lt;code&gt;Z&lt;/code&gt; 来向后搜索）。如果我们不想在选中的文字中包含某个特定文本，我们可以使用 &lt;code&gt;x&lt;/code&gt; ( &lt;code&gt;X&lt;/code&gt; 键向后搜索 )&lt;/p&gt;
&lt;p&gt;&amp;lt;a id=&quot;orgd28a4f0&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;扩大和缩小范围 (Narrowing and Widening Regions)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：该部分在新版 Doom emacs 中有较大变化，故该部分存在少许调整与原文不同，如需查看旧版本操作请查看原文。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在 Emacs 中有一个叫 Narrowing 的功能，对于将 buffer 限制到一个选择的文本中十分有用，但它由于经常给初学者造成困扰，默认情况下被禁用，在初次使用时可以选择是否启用。它特别适合与多个光标（见下）同时使用。您可以用 &lt;code&gt;C-x n n&lt;/code&gt; 来将范围缩小到当前选择的区域，使用 &lt;code&gt;C-x n w&lt;/code&gt; 执行相反操作（即扩大范围）。用 &lt;code&gt;C-x n d&lt;/code&gt; 来缩小范围到当前的函数也十分有用。&lt;/p&gt;
&lt;p&gt;&amp;lt;a id=&quot;org806bc14&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;多光标 (Multiple Cursors)&lt;/h1&gt;
&lt;p&gt;多光标允许您同时编辑多个地方。Doom 提供了两种多光标的实现方式，它们分别是 &lt;a href=&quot;https://github.com/hlissner/evil-multiedit&quot;&gt;evil-multiedit&lt;/a&gt; 和 &lt;a href=&quot;https://github.com/gabesoft/evil-mc&quot;&gt;evil-mc&lt;/a&gt;。我各人感觉 evil-multiedit 更容易使用，但是功能比较局限。&lt;/p&gt;
&lt;p&gt;有两种方式可以开始使用 evil-multiedit ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;选择您想编辑的文本，然后按 &lt;code&gt;R&lt;/code&gt; 继续选择在当前 buffer 中您想要编辑的文本。&lt;/li&gt;
&lt;li&gt;将光标移动到您想要编辑的单词旁，然后使用 &lt;code&gt;M-d&lt;/code&gt; 和 &lt;code&gt;M-D&lt;/code&gt; 来分别选中上一个或下一个相同的单词（可以先缩小范围）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当您选择了一些文本区域后，您可以使用 &lt;code&gt;C-n&lt;/code&gt; (下一个) 和 &lt;code&gt;C-p&lt;/code&gt; (上一个)。按下选中的文本上按回车键，该文本区域会被取消选中。使用这些按键，您可以随意地选中文本。&lt;/p&gt;
&lt;p&gt;当您完成了选择后，对一个区域的修改将会影响所有的区域，大多数的 evil 命令都能够与 evil-multiedit 配合使用。&lt;/p&gt;
&lt;p&gt;您也可以使用平时的取消按键（ &lt;code&gt;ESC&lt;/code&gt; 或 &lt;code&gt;C-[&lt;/code&gt; ）来退出 evil-multiedit 模式。&lt;/p&gt;
&lt;p&gt;evil-mc 是另外一个多光标实现，它更加的灵活，但也更加难以使用。使用 evil-mc 创建多个光标有以下几种选择：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gzm&lt;/code&gt; 在所有的匹配项创建一个光标（可以先缩小范围）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gzd&lt;/code&gt; 创建光标，然后移动到下一个匹配项（ &lt;code&gt;gzd&lt;/code&gt; 移动到上一项）&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gzj&lt;/code&gt; 创建光标，然后移动到下一行 ( &lt;code&gt;gzk&lt;/code&gt; 移动到上一行 )&lt;/li&gt;
&lt;li&gt;&lt;code&gt;gzz&lt;/code&gt; 在当前项创建光标。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这些创建光标会重复您在真正的光标上输入的命令。您可以用 &lt;code&gt;gzt&lt;/code&gt; 来临时关闭多光标，从光标位置继续可以再次按相同的按键 &lt;code&gt;gzt&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;大多数的命令都能与 evil-mc 配合使用，但是少数我使用的功能不能用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;DEL&lt;/code&gt; (backspace) 在插入模式下不能在所有的光标进行重复操作&lt;/li&gt;
&lt;li&gt;&lt;code&gt;ysiw&lt;/code&gt; 在所有模式下都不能在所有的光标下工作 (尽管 &lt;code&gt;ciw&lt;/code&gt; 可以)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果光标之间不同步，使用撤消一些命令通常可以解决问题。&lt;/p&gt;
&lt;p&gt;当您完成了编辑操作后，按下 &lt;code&gt;gzu&lt;/code&gt; 来移除所有光标&lt;/p&gt;
&lt;p&gt;&amp;lt;a id=&quot;org35af536&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;撤销与重做 (Undoing and Redoing)&lt;/h1&gt;
&lt;blockquote&gt;
&lt;p&gt;译者注：原文在这里标注了 TODO&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;em&gt;TODO&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;u&lt;/code&gt; 键撤销。 &lt;code&gt;undo-tree&lt;/code&gt; 系统比较复杂，但是您会慢慢习惯它。 &lt;code&gt;C-r&lt;/code&gt; 和 &lt;code&gt;M-_&lt;/code&gt; 执行重做操作， &lt;code&gt;C-x u&lt;/code&gt; 显示撤销树（undo tree）&lt;/p&gt;
&lt;p&gt;&amp;lt;a id=&quot;org4a475a3&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;在编译输出间导航 (Navigating Compliation Output)&lt;/h1&gt;
&lt;p&gt;&lt;em&gt;TODO&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;按下 &lt;code&gt;SPC p c&lt;/code&gt; 或 &lt;code&gt;M-b&lt;/code&gt; 来进行编译。 &lt;code&gt;]e&lt;/code&gt; 和 &lt;code&gt;[e&lt;/code&gt; 查看下一个或上一个 flycheck (一种拼写检查) 错误。 &lt;code&gt;SPC c x&lt;/code&gt; 来分别列出所有错误。&lt;/p&gt;
&lt;p&gt;&amp;lt;a id=&quot;org2d0afb3&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;杂项&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;gcc&lt;/code&gt; 注释或取消当前行的注释&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPC oA&lt;/code&gt; 打开 Org agenda&lt;/li&gt;
&lt;li&gt;&lt;code&gt;SPC x&lt;/code&gt; 为任意笔记打开临时 buffer (scratch buffer)&lt;/li&gt;
&lt;li&gt;更改文字大小： &lt;code&gt;M-=+&lt;/code&gt; 增加字号， &lt;code&gt;M--&lt;/code&gt; 缩小字号， &lt;code&gt;M-+&lt;/code&gt; 重置&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;lt;a id=&quot;orgdbc49a3&quot;&amp;gt;&amp;lt;/a&amp;gt;&lt;/p&gt;
&lt;h1&gt;了解更多 Doom&lt;/h1&gt;
&lt;p&gt;我对 Doom 的了解大多数都是通过阅读&lt;a href=&quot;https://github.com/hlissner/doom-emacs/blob/develop/modules/config/default/+evil-bindings.el&quot;&gt;默认按键绑定&lt;/a&gt;, 查看我不认识的命令获得的。在 scratch buffer 中实验每个命令的含义很容易。&lt;/p&gt;
</content:encoded><category>译</category><category>Emacs</category><author>Mslxl</author></item><item><title>V2Ray Setup</title><link>https://blog.mslxl.com/posts/others/v2ray/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/v2ray/</guid><pubDate>Sun, 19 Jan 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;404 Not Found (Even though your browser tell you that status code is 200)&lt;/p&gt;
</content:encoded><category>V2Ray</category><author>Mslxl</author></item><item><title>Epub 文件结构</title><link>https://blog.mslxl.com/posts/others/epub/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/epub/</guid><pubDate>Fri, 20 Sep 2019 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;epub 文件的实质其实是一个固定格式的 zip 压缩包，文件名以 UTF-8 编码，但是不同的软件对于同一个 epub 标准有不同的实现。&lt;/p&gt;
&lt;p&gt;为了兼容所有软件，同时提升加载速度，最好是 Compression level = Store，因为个别软件严格遵守epub标准（比如 Okular）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OCF 规定: ZIP 文件的压缩等级必须为 stored 、方式为 deflate&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;原文&amp;lt;/summary&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;blockquote&amp;gt;&amp;lt;p&amp;gt;OCF ZIP Containers MUST include only stored (uncompressed) and Deflate-compressed ZIP entries within the ZIP archive. OCF Processors MUST treat any OCF Containers that use compression techniques other than Deflate as being in error.&amp;lt;/p&amp;gt;&amp;lt;/blockquote&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;epub 主要由三部分组成&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mimetype&lt;/li&gt;
&lt;li&gt;META-INF&lt;/li&gt;
&lt;li&gt;OEBPS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注意大小写敏感，这主要是针对 linux 平台上的诸多软件。&lt;/p&gt;
&lt;h2&gt;mimetype&lt;/h2&gt;
&lt;p&gt;mimetype 主要是标记文件的格式，内容恒定，为&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;application/epub+zip
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;OCF 规定： mimetype 内容必须为 &lt;code&gt;application/epub+zip&lt;/code&gt; ，以 US-ASCII 编码，不得添加空格等任何字符，不得包含 Unicode 签名或 BOM 头。mimetype 文件不得被压缩、加密。文件名中不得有额外字符。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;原文&amp;lt;/summary&amp;gt;
&amp;lt;div&amp;gt;
&amp;lt;blockquote&amp;gt;
&amp;lt;p&amp;gt;The first file in the OCF ZIP Container MUST be the mimetype file. The contents of this file MUST be the MIME media type [RFC2046] string application/epub+zip encoded in US-ASCII [US-ASCII].&amp;lt;/p&amp;gt;
&amp;lt;p&amp;gt;The contents of the mimetype file MUST NOT contain any leading padding or white space, MUST NOT begin with the Unicode signature (or Byte Order Mark), and the case of the media type string MUST be exactly as presented above. The mimetype file additionally MUST NOT be compressed or encrypted, and there MUST NOT be an extra field in its ZIP header. &amp;lt;/p&amp;gt;
&amp;lt;/blockquote&amp;gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;/div&amp;gt;
&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;实践证明 mimetype 对epub的解析无影响，将内容改为 &lt;code&gt;application/epub+x-tar&lt;/code&gt; 再压缩为 zip 依旧能正常打开，但如果压缩成 tar 解析错误。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;该文件即使不存在都能正常打开，Edge 、 Okular 、Calibre 和 Neat Reader 都没有理这个文件&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;万一那个阅读器读取这个文件，最好还是写&lt;code&gt;application/epub+zip&lt;/code&gt;吧&lt;/s&gt;&lt;/p&gt;
&lt;h2&gt;META-INF 文件夹&lt;/h2&gt;
&lt;h3&gt;container.xml&lt;/h3&gt;
&lt;p&gt;内容一般无需更改&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&amp;gt;
    &amp;lt;rootfiles&amp;gt;
        &amp;lt;rootfile full-path=&quot;OEBPS/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&amp;gt;
   &amp;lt;/rootfiles&amp;gt;
&amp;lt;/container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;strong&gt;经测试 &lt;code&gt;rootfiles&lt;/code&gt; 下不管有几项 &lt;code&gt;rootfile&lt;/code&gt; 项, Edge 只会读取第一项&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;s&gt;这不是和 OCF 对着干吗&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;OEBPS/content.opf&lt;/code&gt; 就是下文中要提到的 &lt;a href=&quot;#opf&quot;&gt;opf 文件&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&amp;lt;details&amp;gt;
&amp;lt;summary&amp;gt;测试内容&amp;lt;/summary&amp;gt;
&amp;lt;ul&amp;gt;
&amp;lt;li&amp;gt;
我将文件修改为以下内容并添加 &lt;code&gt;OEBPS/content1.opf&lt;/code&gt; 文件与 ncx 文件，两个ncx中章节名不同&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
    &amp;lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&amp;gt;
        &amp;lt;rootfiles&amp;gt;
            &amp;lt;rootfile full-path=&quot;OEBPS/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&amp;gt;
            &amp;lt;rootfile full-path=&quot;OEBPS/content1.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&amp;gt;
    &amp;lt;/rootfiles&amp;gt;
&amp;lt;/container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;重新压缩后打开后显示的章节名只有 &lt;code&gt;OEBPS/content.opf&lt;/code&gt; 指向的 ncx 的章节名称，没有&lt;code&gt;OEBPS/content1.opf&lt;/code&gt;中指向的 ncx 的章节名称&lt;/p&gt;
&lt;p&gt;&amp;lt;/li&amp;gt;
&amp;lt;li&amp;gt;
创建了一个新文件夹 &lt;code&gt;Test&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
    &amp;lt;container version=&quot;1.0&quot; xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&amp;gt;
        &amp;lt;rootfiles&amp;gt;
            &amp;lt;rootfile full-path=&quot;OEBPS/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&amp;gt;
            &amp;lt;rootfile full-path=&quot;Test/content.opf&quot; media-type=&quot;application/oebps-package+xml&quot;/&amp;gt;
    &amp;lt;/rootfiles&amp;gt;
&amp;lt;/container&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;结果和一相同
&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;
&amp;lt;/details&amp;gt;&lt;/p&gt;
&lt;h3&gt;encryption.xml (可选)&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;该文件可以不存在&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;该文件储存有关加密的信息&lt;/p&gt;
&lt;p&gt;下面的一个例子展示了被 AES 加密的 &lt;code&gt;image.jpeg&lt;/code&gt; ,使用 John Smith 的 RSA 密匙进一步加密。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;encryption
    xmlns =&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;
    xmlns:enc=&quot;http://www.w3.org/2001/04/xmlenc#&quot;
    xmlns:ds=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&amp;gt;
    &amp;lt;enc:EncryptedKey Id=&quot;EK&quot;&amp;gt;
        &amp;lt;enc:EncryptionMethod Algorithm=&quot;http://www.w3.org/2001/04/xmlenc#rsa-1_5&quot;/&amp;gt;
        &amp;lt;ds:KeyInfo&amp;gt;
            &amp;lt;ds:KeyName&amp;gt;John Smith&amp;lt;/ds:KeyName&amp;gt;
        &amp;lt;/ds:KeyInfo&amp;gt;
        &amp;lt;enc:CipherData&amp;gt;
            &amp;lt;enc:CipherValue&amp;gt;xyzabc&amp;lt;/enc:CipherValue&amp;gt;
        &amp;lt;/enc:CipherData&amp;gt;
    &amp;lt;/enc:EncryptedKey&amp;gt;
    &amp;lt;enc:EncryptedData Id=&quot;ED1&quot;&amp;gt;
        &amp;lt;enc:EncryptionMethod Algorithm=&quot;http://www.w3.org/2001/04/xmlenc#kw-aes128&quot;/&amp;gt;
        &amp;lt;ds:KeyInfo&amp;gt;
            &amp;lt;ds:RetrievalMethod URI=&quot;#EK&quot;
                Type=&quot;http://www.w3.org/2001/04/xmlenc#EncryptedKey&quot;/&amp;gt;
        &amp;lt;/ds:KeyInfo&amp;gt;
        &amp;lt;enc:CipherData&amp;gt;
            &amp;lt;enc:CipherReference URI=&quot;image.jpeg&quot;/&amp;gt;
        &amp;lt;/enc:CipherData&amp;gt;
    &amp;lt;/enc:EncryptedData&amp;gt;
&amp;lt;/encryption&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;注意，以下为不可加密的文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;mimetype&lt;/li&gt;
&lt;li&gt;META-INF/container.xml&lt;/li&gt;
&lt;li&gt;META-INF/encryption.xml&lt;/li&gt;
&lt;li&gt;META-INF/manifest.xml&lt;/li&gt;
&lt;li&gt;META-INF/metadata.xml&lt;/li&gt;
&lt;li&gt;META-INF/rights.xml&lt;/li&gt;
&lt;li&gt;META-INF/signatures.xml&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;manifest.xml (可选)&lt;/h3&gt;
&lt;p&gt;该文件提供 epub 中的文件清单&lt;/p&gt;
&lt;p&gt;OCF 并没有规定清单格式&lt;/p&gt;
&lt;h3&gt;metadata.xml (可选)&lt;/h3&gt;
&lt;p&gt;该文件定义 epub 文件中的元数据&lt;/p&gt;
&lt;p&gt;如果 &lt;code&gt;metadata.xml&lt;/code&gt;存在，他的命名空间必须被显示的声明为 &lt;a href=&quot;https://www.w3.org/TR/2009/REC-xml-names-20091208/&quot;&gt;[XMLNS]&lt;/a&gt;。文件应当在命名空间 &lt;code&gt;http://www.idpf.org/2013/metadata&lt;/code&gt; 仅包含一个根节点 &lt;code&gt;metadata&lt;/code&gt;。其他的节点为了向后兼容允许存在，，阅读器应当无视 &lt;code&gt;metadata.xml&lt;/code&gt; 中不能识别的根节点。&lt;/p&gt;
&lt;p&gt;3.1版的 OCF 中并没有定义 &lt;code&gt;metadata.xml&lt;/code&gt; 中元数据的用途。也许未来会有。&lt;/p&gt;
&lt;h3&gt;rights.xml (可选)&lt;/h3&gt;
&lt;p&gt;该文件用于数字版权管理（DRM），用于在权利人，中间人和用户之间信任交换EPUB出版物的信息。
3.1 版的 OCF 标准中并未规定 DRM 细细的特殊格式，但未来也许有。&lt;code&gt;rights.xml&lt;/code&gt; 的命名空间应当被显式的声明为 &lt;a href=&quot;https://www.w3.org/TR/2009/REC-xml-names-20091208/&quot;&gt;[XMLNS]&lt;/a&gt; 来避免以后的冲突。&lt;/p&gt;
&lt;p&gt;当 rights.xml 不存在时，版权信息可能位于其他位置。&lt;/p&gt;
&lt;h3&gt;signatures.xml (可选)&lt;/h3&gt;
&lt;p&gt;该文件存有 epub 的数组签名。它的内容必须符合 &lt;a href=&quot;https://www.w3.org/Submission/epub-ocf/#app-schema-signatures&quot;&gt;signatures.xml&lt;/a&gt; schema.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;signatures.xml&lt;/code&gt; 的根节点为 &lt;code&gt;signatures&lt;/code&gt;，子节点为定义在 &lt;a href=&quot;https://www.w3.org/Submission/epub-ocf/#refXMLDSIGCORE&quot;&gt;XML DSIG Core&lt;/a&gt; 中的 &lt;code&gt;Signature&lt;/code&gt;。签名可以部分应用，也可以应用到 epub 整体，它可以使任何形式的签名数据，也就是说，不仅仅是 XML。&lt;/p&gt;
&lt;p&gt;下面的 XML 是 signatures.xml的一个例子，它包含了一个签名，应用到了两个资源，分别是 &lt;code&gt;EPUB/book.xhtml&lt;/code&gt; 和 &lt;code&gt;EPUB/images/cover.jpeg&lt;/code&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;signatures xmlns=&quot;urn:oasis:names:tc:opendocument:xmlns:container&quot;&amp;gt;
    &amp;lt;Signature Id=&quot;sig&quot; xmlns=&quot;http://www.w3.org/2000/09/xmldsig#&quot;&amp;gt;
        &amp;lt;SignedInfo&amp;gt;
            &amp;lt;CanonicalizationMethod
                Algorithm=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315&quot;/&amp;gt;
            &amp;lt;SignatureMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#dsa-sha1&quot;/&amp;gt;
            &amp;lt;Reference URI=&quot;#Manifest1&quot;&amp;gt;
                &amp;lt;DigestMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#sha1&quot;/&amp;gt;
                &amp;lt;DigestValue&amp;gt;j6lwx3rvEPO0vKtMup4NbeVu8nk=&amp;lt;/DigestValue&amp;gt;
            &amp;lt;/Reference&amp;gt;
        &amp;lt;/SignedInfo&amp;gt;
        &amp;lt;SignatureValue&amp;gt;…&amp;lt;/SignatureValue&amp;gt;
        &amp;lt;KeyInfo&amp;gt;
            &amp;lt;KeyValue&amp;gt;
                &amp;lt;DSAKeyValue&amp;gt;
                    &amp;lt;P&amp;gt;…&amp;lt;/P&amp;gt;&amp;lt;Q&amp;gt;…&amp;lt;/Q&amp;gt;&amp;lt;G&amp;gt;…&amp;lt;/G&amp;gt;&amp;lt;Y&amp;gt;…&amp;lt;/Y&amp;gt;
                &amp;lt;/DSAKeyValue&amp;gt;
            &amp;lt;/KeyValue&amp;gt;
        &amp;lt;/KeyInfo&amp;gt;
        &amp;lt;Object&amp;gt;
            &amp;lt;Manifest Id=&quot;Manifest1&quot;&amp;gt;
                &amp;lt;Reference URI=&quot;EPUB/book.xhtml&quot;&amp;gt;
                    &amp;lt;Transforms&amp;gt;
                        &amp;lt;Transform
                            Algorithm=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315&quot;/&amp;gt;
                    &amp;lt;/Transforms&amp;gt;
                    &amp;lt;DigestMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#sha1&quot;/&amp;gt;
                    &amp;lt;DigestValue&amp;gt;&amp;lt;/DigestValue&amp;gt;
                &amp;lt;/Reference&amp;gt;
                &amp;lt;Reference URI=&quot;EPUB/images/cover.jpeg&quot;&amp;gt;
                    &amp;lt;Transforms&amp;gt;
                        &amp;lt;Transform
                            Algorithm=&quot;http://www.w3.org/TR/2001/REC-xml-c14n-20010315&quot;/&amp;gt;
                    &amp;lt;/Transforms&amp;gt;
                    &amp;lt;DigestMethod Algorithm=&quot;http://www.w3.org/2000/09/xmldsig#sha1&quot;/&amp;gt;
                    &amp;lt;DigestValue&amp;gt;&amp;lt;/DigestValue&amp;gt;
                &amp;lt;/Reference&amp;gt;
            &amp;lt;/Manifest&amp;gt;
        &amp;lt;/Object&amp;gt;
    &amp;lt;/Signature&amp;gt;
&amp;lt;/signatures&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;内容目录&lt;/h2&gt;
&lt;p&gt;其实这个目录并没有什么固定的名字，主要包含的是书籍内容。&lt;/p&gt;
&lt;p&gt;&lt;s&gt;一般来说这个文件夹名字是OEPBS，但 OCF 推荐叫做该书的名字&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;目录内存有 opf 、ncx、css、html等文件...&lt;/p&gt;
&lt;p&gt;重要的文件有 OPF 和 NCX&lt;/p&gt;
&lt;h3&gt;opf&lt;/h3&gt;
&lt;p&gt;以下为一个例子。
我认为只需要一个例子就能说明了。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE package PUBLIC &quot;+//ISBN 978-7-308-05831-5//DTD OEB 1.2 Package//EN&quot; &quot;http://openebook.org/dtds/oeb-1.2/oebpkg12.dtd&quot;&amp;gt;
&amp;lt;package unique-identifier=&quot;bookid&quot;
    xmlns:opf=&quot;http://www.idpf.org/2007/opf&quot;
    xmlns=&quot;http://www.idpf.org/2007/opf&quot; version=&quot;2.0&quot;&amp;gt;
    &amp;lt;metadata&amp;gt;
        &amp;lt;dc-metadata xmlns:dc=&quot;http://purl.org/dc/elements/1.1/&quot;
            xmlns:dcterms=&quot;http://purl.org/dc/terms/&quot;
            xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&amp;gt;
            &amp;lt;dc:title&amp;gt;龙族 I&amp;lt;/dc:title&amp;gt;
            &amp;lt;dc:creator&amp;gt;江南老贼&amp;lt;/dc:creator&amp;gt;
            &amp;lt;!-- dc:subject 主题或关键字 --&amp;gt;
            &amp;lt;dc:subject&amp;gt;幻想&amp;lt;/dc:subject&amp;gt;
            &amp;lt;dc:subject&amp;gt;刀片&amp;lt;/dc:subject&amp;gt;
            &amp;lt;dc:subject&amp;gt;胃药&amp;lt;/dc:subject&amp;gt;
            &amp;lt;dc:subject&amp;gt;冒险&amp;lt;/dc:subject&amp;gt;
            &amp;lt;!-- dc:description 简介 --&amp;gt;
            &amp;lt;dc:description&amp;gt;你年少的时候，是否有过孤独而热血的梦？2010，龙，改变世界秘史！&amp;lt;dc:description&amp;gt;
            &amp;lt;!-- dc:publisher 出版方 --&amp;gt;
            &amp;lt;dc:publisher&amp;gt;长江出版社&amp;lt;/dc:publisher&amp;gt;
            &amp;lt;!-- dc:contributor 贡献者 --&amp;gt;
            &amp;lt;dc:contributor/&amp;gt;
            &amp;lt;dc:date&amp;gt;2013-07-01&amp;lt;/dc:date&amp;gt;
            &amp;lt;dc:type&amp;gt;普通图书&amp;lt;/dc:type&amp;gt;
            &amp;lt;dc:format&amp;gt;Text/html(.html,.htm)&amp;lt;/dc:format&amp;gt;
            &amp;lt;dc:identifier id=&quot;bookid&quot; opf:scheme=&quot;ISBN&quot;&amp;gt;isbn:9787549220632&amp;lt;/dc:identifier&amp;gt;
            &amp;lt;!-- dc:source 来源 --&amp;gt;
            &amp;lt;dc:source/&amp;gt;
            &amp;lt;dc:language&amp;gt;chinese&amp;lt;/dc:language&amp;gt;
            &amp;lt;dc:relation/&amp;gt;
            &amp;lt;dc:coverage/&amp;gt;
            &amp;lt;dc:rights&amp;gt;机械工业出版社版权所有&amp;lt;/dc:rights&amp;gt;
        &amp;lt;/dc-metadata&amp;gt;
    &amp;lt;x-metadata/&amp;gt;
    &amp;lt;/metadata&amp;gt;
    &amp;lt;!--manifest 文件清单，列出OEBPS文档及相关的文件（图片），仅由一种子元素组成
        id 可以自由命名，在以后多个位置都有使用，较为重要 --&amp;gt;
    &amp;lt;manifest&amp;gt;
        &amp;lt;item id=&quot;ncx&quot; href=&quot;toc.ncx&quot; media-type=&quot;application/x-dtbncx+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;style&quot; href=&quot;style.css&quot; media-type=&quot;text/css&quot;/&amp;gt;
        &amp;lt;item id=&quot;cover&quot; href=&quot;cover.htm&quot; media-type=&quot;text/html&quot;/&amp;gt;
        &amp;lt;item id=&quot;tableofc&quot; href=&quot;toc.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;forword&quot; href=&quot;forword.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap01&quot; href=&quot;chap01.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap02&quot; href=&quot;chap02.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap03&quot; href=&quot;chap03.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap04&quot; href=&quot;chap04.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap05&quot; href=&quot;chap05.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap06&quot; href=&quot;chap06.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap07&quot; href=&quot;chap07.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap08&quot; href=&quot;chap08.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap09&quot; href=&quot;chap09.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;chap10&quot; href=&quot;chap10.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
        &amp;lt;item id=&quot;reference&quot; href=&quot;reference.xhtml&quot; media-type=&quot;application/xhtml+xml&quot;/&amp;gt;
    &amp;lt;/manifest&amp;gt;
    &amp;lt;!-- 提供书籍的线性阅读次序
        toc 填上面 manifest 中 ncx 文件的 ID，关于 ncx 文件下面提 --&amp;gt;
    &amp;lt;spine toc=&quot;ncx&quot;&amp;gt;
        &amp;lt;!-- idref 是上面 manifest 中 item 的 id --&amp;gt;
        &amp;lt;itemref idref=&quot;cover&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;tableofc&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;forword&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap01&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap02&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap03&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap04&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap05&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap06&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap07&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap08&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap09&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;chap10&quot;/&amp;gt;
        &amp;lt;itemref idref=&quot;reference&quot;/&amp;gt;
    &amp;lt;/spine&amp;gt;
    &amp;lt;!-- guide 指南,依次列出电子书的特定页面, 例如封面、目录、序言等, 属性值指向文件保存地址。一般情况下，epub电子书不用该元素 --&amp;gt;
    &amp;lt;guide/&amp;gt;
    &amp;lt;!-- tour 导读。可以根据不同的读者水平或者阅读目的, 按一定次序, 选择电子书中的部分页面组成导读。一般情况下，epub电子书不用该元素。--&amp;gt;
    &amp;lt;tour/&amp;gt;
&amp;lt;/package&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;另：&lt;s&gt;江南就是个写小说的，他懂个什么龙族&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;千万千万不要写不存在的 path 或 idref， Edge 不能正确识别&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;ncx&lt;/h3&gt;
&lt;p&gt;ncx文件用来描述电子书的目录结构，一般来说，opf 中 spine 一般也会出现在这里。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&apos;1.0&apos; encoding=&apos;utf-8&apos; ?&amp;gt;
&amp;lt;ncx xmlns=&quot;http://www.daisy.org/z3986/2005/ncx/&quot; version=&quot;2005-1&quot;&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta content=&quot;coay_307750&quot; name=&quot;dtb:uid&quot; /&amp;gt;
        &amp;lt;meta content=&quot;2&quot; name=&quot;dtb:depth&quot; /&amp;gt;
        &amp;lt;meta content=&quot;0&quot; name=&quot;dtb:totalPageCount&quot; /&amp;gt;
        &amp;lt;meta content=&quot;0&quot; name=&quot;dtb:maxPageNumber&quot; /&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;docTitle&amp;gt;
        &amp;lt;text&amp;gt;《龙族 I》&amp;lt;/text&amp;gt;
    &amp;lt;/docTitle&amp;gt;
    &amp;lt;docAuthor&amp;gt;
        &amp;lt;text&amp;gt;江南&amp;lt;/text&amp;gt;
    &amp;lt;/docAuthor&amp;gt;
    &amp;lt;navMap&amp;gt;
        &amp;lt;!-- class 划重点
            id 这里好像没什么用处
            playOrder 要和 opf 中 spine 的 item 顺序一致 --&amp;gt;
        &amp;lt;navPoint class=&quot;chapter&quot; id=&quot;article_307750_1&quot; playOrder=&quot;1&quot;&amp;gt;
            &amp;lt;navLabel&amp;gt;
                &amp;lt;text&amp;gt;第1章&amp;lt;/text&amp;gt;
            &amp;lt;/navLabel&amp;gt;
            &amp;lt;content src=&quot;article_307750_1.html&quot; /&amp;gt;
        &amp;lt;/navPoint&amp;gt;
        &amp;lt;navPoint class=&quot;chapter&quot; id=&quot;article_307750_2&quot; playOrder=&quot;2&quot;&amp;gt;
            &amp;lt;navLabel&amp;gt;
                &amp;lt;text&amp;gt;第2章&amp;lt;/text&amp;gt;
            &amp;lt;/navLabel&amp;gt;
            &amp;lt;content src=&quot;article_307750_2.html&quot; /&amp;gt;
        &amp;lt;/navPoint&amp;gt;
        &amp;lt;navPoint class=&quot;chapter&quot; id=&quot;article_307750_3&quot; playOrder=&quot;3&quot;&amp;gt;
            &amp;lt;navLabel&amp;gt;
                &amp;lt;text&amp;gt;第3章&amp;lt;/text&amp;gt;
            &amp;lt;/navLabel&amp;gt;
            &amp;lt;content src=&quot;article_307750_3.html&quot; /&amp;gt;
        &amp;lt;/navPoint&amp;gt;
        &amp;lt;navPoint class=&quot;chapter&quot; id=&quot;article_307750_4&quot; playOrder=&quot;4&quot;&amp;gt;
            &amp;lt;navLabel&amp;gt;
                &amp;lt;text&amp;gt;第4章&amp;lt;/text&amp;gt;
            &amp;lt;/navLabel&amp;gt;
            &amp;lt;content src=&quot;article_307750_4.html&quot; /&amp;gt;
        &amp;lt;/navPoint&amp;gt;
        &amp;lt;navPoint class=&quot;chapter&quot; id=&quot;article_307750_5&quot; playOrder=&quot;5&quot;&amp;gt;
            &amp;lt;navLabel&amp;gt;
                &amp;lt;text&amp;gt;第5章&amp;lt;/text&amp;gt;
            &amp;lt;/navLabel&amp;gt;
            &amp;lt;content src=&quot;article_307750_5.html&quot; /&amp;gt;
        &amp;lt;/navPoint&amp;gt;
        &amp;lt;!-- 经 Okular 测试这里是可以分卷的
            不过标准中没写，可能会出现无法识别的情况（比如 Edge） --&amp;gt;
        &amp;lt;navPoint class=&quot;chapter&quot; id=&quot;article_307750_5&quot; playOrder=&quot;5&quot;&amp;gt;
            &amp;lt;navLabel&amp;gt;
                &amp;lt;text&amp;gt;第1卷&amp;lt;/text&amp;gt;
            &amp;lt;/navLabel&amp;gt;
            &amp;lt;navPoint class=&quot;chapter&quot; id=&quot;article_307750_1&quot; playOrder=&quot;1&quot;&amp;gt;
                &amp;lt;navLabel&amp;gt;
                    &amp;lt;text&amp;gt;第1章&amp;lt;/text&amp;gt;
                &amp;lt;/navLabel&amp;gt;
                &amp;lt;content src=&quot;article_307750_1.html&quot; /&amp;gt;
            &amp;lt;/navPoint&amp;gt;
            &amp;lt;navPoint class=&quot;chapter&quot; id=&quot;article_307750_2&quot; playOrder=&quot;2&quot;&amp;gt;
                &amp;lt;navLabel&amp;gt;
                    &amp;lt;text&amp;gt;第2章&amp;lt;/text&amp;gt;
                &amp;lt;/navLabel&amp;gt;
                &amp;lt;content src=&quot;article_307750_2.html&quot; /&amp;gt;
            &amp;lt;/navPoint&amp;gt;
        &amp;lt;/navPoint&amp;gt;
    &amp;lt;/navMap&amp;gt;
&amp;lt;/ncx&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;h2&gt;html 坑点&lt;/h2&gt;
&lt;p&gt;以下内容一点也不能少，少了 Edge 会哭的。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;
&amp;lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&amp;gt;
&amp;lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xml:lang=&quot;zh-CN&quot;&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;第二章&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;正文&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;s&gt;又是你 Edge&lt;/s&gt;&lt;/p&gt;
</content:encoded><category>Epub</category><author>Mslxl</author></item><item><title>谈谈手抄报</title><link>https://blog.mslxl.com/posts/others/newpapers_handcopy/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/newpapers_handcopy/</guid><pubDate>Mon, 15 Oct 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;每逢什么重大的事件，我们学校或者班级都要布置一份手抄报的任务，一年下来，不知道要布置多少手抄报，我对这份没有一丁点的兴趣，只是随便应付一下，但有些话我还是想说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;报纸是人类转递信息的工具&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;上面那句话来自我们的历史课本，我不知道何时有了手抄报，但是我认为，手抄报发展到了现在，已经偏离的它的本质。如果说手抄报现在作为一种艺术，我不反对，也许学校也是这么想的。但是到了学生这里，却变成了强制性的任务。再谈一下报纸的本质，报纸本身是传递信息的，但现在的手抄报却根本不能改变什么，它就被贴在一个地方，很少有人看，而且大都是远远的望一眼。既然是远远的望一眼，那就换成图片吧，也不行，为什么？因为布置的是手抄报不是图片。&lt;/p&gt;
&lt;p&gt;姑且先定位为任务吧，用电脑做再打印可不可以？同样不行，既然是 “手抄报”，那就一定得 “手抄”。用电脑不是能做得更好吗？更好也没有用，这是检验态度的问题。手抄报再差，也是你手做的，就算内容都是抄来的；用电脑再好，也是打印机打出来的。再提一下我们班主任的话：“来之不易的才有价值”，但是呢？用更简单的方式获取更有价值的物品，即使获取方式简单，也不能否认他的价值吧。&lt;/p&gt;
&lt;p&gt;关于图片，全都是图片，还不能都是字。究其原由，大概是我上面提到的“远远地一看 ”吧，领导在门口一看就可以看到无限风光。&lt;/p&gt;
&lt;p&gt;图片的内容也是一样，没有什么可以画的。那一样，延续传统，变成了中央的巨幅图片。至于到底画的什么，我也不曾记得了。毕竟内容太常见、太多而又太没有创意了。&lt;/p&gt;
&lt;p&gt;上面的还是无关紧要的问题。至于最严重的，是它还关系到你的 “态度”。如果你弄不好，糊弄糊弄，别人就说你态度不好；对待这么意见神圣庄严的任务怎么能随便糊弄过去呢。这里的中心依然任务的，因而这态度也就是你对学校、对班级的态度了。原来做手抄报的目的是为了检验你对学校和班级的态度，如果做手抄报能反映态度的话，那赔礼道歉就带一堆手抄报过去吧。&lt;/p&gt;
&lt;p&gt;真相大白了。&lt;/p&gt;
</content:encoded><category>随笔</category><author>Mslxl</author></item><item><title>论鸽子</title><link>https://blog.mslxl.com/posts/others/gugugu2/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/gugugu2/</guid><pubDate>Sat, 06 Oct 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;从前，有个国家，它的执政者认为只有胜者才能统治一切，从而发动了战争，百姓惨不忍睹，整个世界遍体鳞伤。&lt;/p&gt;
&lt;p&gt;而只要有流血和牺牲，就必定有仇恨，有伤害，以及无休止的反抗和争议，那么战争就不会结束。&lt;/p&gt;
&lt;p&gt;人们陷入了无止尽的苦难和折磨之中民不聊生，苦不堪言。&lt;/p&gt;
&lt;p&gt;于是在无休止的循环下，为了给战争画下句号，终于有人站了出来，它开始主张和平协议战争双方停止战争。&lt;/p&gt;
&lt;p&gt;主张和平的人们被称为鸽派，他们呼吁停止战争倡导不用武力来解决问题，暴力和杀戮只会让人生活的如同傀儡机器和行尸走肉。&lt;/p&gt;
&lt;p&gt;这个思想纷纷被认同，广泛流传到世上，但是这就触及了在战争中获利的人的利益，也与主张战争的鹰派相对立。于是鸽派中的人被各种诬陷，追捕，暗杀接连不断出现血色名单。&lt;/p&gt;
&lt;p&gt;即使这样，这个国家依然有各界人士纷纷站了出来主张和平与自由，他们组成了新的鸽派，他们向各界传达自己的思想然后与鹰派进行了各种斗争。终于在各界迫使的压力和内部失去支持的情况，鹰派下台了。&lt;/p&gt;
&lt;p&gt;鸽派胜利了，他们提倡的和平协议被签署，战争停止了，随着时代慢慢推移，一切又慢慢开始恢复到以前那般繁荣，人们开始赞颂，以前的鸽派是多么的伟大在流血和牺牲中获取到和平。&lt;/p&gt;
&lt;p&gt;而现在世界欣欣向荣，一片美好。&lt;/p&gt;
&lt;p&gt;多亏了这些敢于在那个时代站出来的人，他们拯救了一切。&lt;/p&gt;
&lt;p&gt;鸽派的精神也被继承下来，被后人传颂，鸽子也被称为了自由和平的象征，是传达各种美好的信物。&lt;/p&gt;
&lt;p&gt;所以啊，鸽的行为是促进和谐发展的有助于人类进步的，它不应该被指责，一切都需要鸽的力量，它担负起拯救苍生，维护世界和平的重任。
所以啊，有人在网上发鸽子的图片请不要见怪，这是赞美鸽子的一种行为。让我们发出和平的声音:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;咕咕咕咕&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</content:encoded><category>随笔</category><author>Mslxl</author></item><item><title>咕咕咕咕</title><link>https://blog.mslxl.com/posts/others/gugugu/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/gugugu/</guid><pubDate>Thu, 30 Aug 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;各位:&lt;/p&gt;
&lt;p&gt;你好！&lt;/p&gt;
&lt;p&gt;当你看到了这封信的时候，我已经离开并飞向了远方，所以这次你算是白跑了一趟了，早在通知书发下来的时候我就已经得知了一切&lt;/p&gt;
&lt;p&gt;虽然我是只鸽子，也是一只肉质鲜美肥嫩的鸽子，但是…鸽子就算是再肥也是能飞向远方的。&lt;/p&gt;
&lt;p&gt;我们也有我们学生的苦衷，我们鸽子也有我们鸽子的感情，各位，我幸运的逃过了这一劫。&lt;/p&gt;
&lt;p&gt;所以这一次，以及下下次，你都不可能掌我的行踪，就算是鸽子也有鸽子的忠实粉丝，这是永远无法改变的事实。&lt;/p&gt;
&lt;p&gt;咕咕咕咕咕咕咕咕咕咕咕咕…………。&lt;/p&gt;
&lt;p&gt;我是一个重情义的鸽子，也是十分害怕网络上鼎鼎大名的新鸽手读者与一拳巨佬，所以知道你来找我后，我自然而然的会选择离开。&lt;/p&gt;
&lt;p&gt;因为我怕死，我也怕疼，更是害怕会被抓住做成鸽子宴。&lt;/p&gt;
&lt;p&gt;而且今天我直接说白了，我不仅要做鸽子，我还会煽动一些其他的作者，让他们也像我一样做一只鸽子。&lt;/p&gt;
&lt;p&gt;鸽子是和平的象征，但是在你们的眼里，我们就是食物，可遇不可求。&lt;/p&gt;
&lt;p&gt;读者皆无情，我们鸽子有真情，咕天咕地咕天下，敞开心怀咕咕咕叫。&lt;/p&gt;
&lt;p&gt;所以你这次还是放弃吧，我是鸽子界的领导者，也是诸多鸽子评选而出的鸽王。&lt;/p&gt;
&lt;p&gt;在鸽王的面前，纵然你是巨佬，只要我们飞向蓝天，飞向自己向往的崭新天地，就算是斩鸽手一群读者也别想制裁我们。&lt;/p&gt;
&lt;p&gt;无论是写作还是聚会，只要有我在，你们两个就别想抓到一只鸽子！&lt;/p&gt;
&lt;p&gt;鸽子汤，烤乳鸽，水煮鸽，鸽肉串，从今起将永远不会出现在所有博客的餐桌上了。&lt;/p&gt;
&lt;p&gt;祝福您此时能够开心。&lt;/p&gt;
&lt;p&gt;于二〇一八年八月三十日&lt;/p&gt;
&lt;p&gt;&amp;lt;hr/&amp;gt;&lt;/p&gt;
&lt;p&gt;其实是鸽子我开学了，碰不了计算机了。&lt;/p&gt;
&lt;p&gt;Sayonara。&lt;/p&gt;
</content:encoded><category>随笔</category><author>Mslxl</author></item><item><title>i3 User&apos;s Guide 进阶操作篇（对应第 3 节）</title><link>https://blog.mslxl.com/posts/tools/i3wm-tree/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/tools/i3wm-tree/</guid><pubDate>Fri, 24 Aug 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://i3wm.org/docs/userguide.html&quot;&gt;原页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该文档包含了配置和使用 i3 的所有信息。如果没有您所需要的信息，请先检查&lt;a href=&quot;https://www.reddit.com/r/i3wm/&quot;&gt;&lt;a href=&quot;https://www.reddit.com/r/i3wm/&quot;&gt;https://www.reddit.com/r/i3wm/&lt;/a&gt;&lt;/a&gt; 是否已包含您所需要的内容，然后再通过 IRC （推荐）或者电子邮件咨询。&lt;/p&gt;
&lt;h2&gt;3. 树&lt;/h2&gt;
&lt;p&gt;i3 以树结构存储 X11 的输出，工作空间和窗口布局的所有信息。根节点是 X11 根窗口，接着是 X11 输出，然后是停靠区和内容容器，然后是工作区，最后是窗口本身。在以前版本的 I3 中，我们有多个集合（包含输出、工作区）和每个工作区的表。这种方法使用起来很复杂，而且很难理解和实施。&lt;/p&gt;
&lt;h3&gt;3.1. 容器树&lt;/h3&gt;
&lt;p&gt;组成树的每一个节点都叫做&lt;code&gt;容器（Containers）&lt;/code&gt;，一个&lt;code&gt;容器（Container）&lt;/code&gt;可以容纳一个窗口（ X11 窗口，就是那种可以看见并操作的，比如浏览器）。不过，&lt;code&gt;容器（Container）&lt;/code&gt;也可以容纳其他的&lt;code&gt;容器（Containers）&lt;/code&gt;。举一个十分常见的例子：当你在一个用一个显示器启动 i3 并在一个工作空间中打开两个终端，将会是像这样的一棵树：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&quot;tree-shot4.png&quot; alt=&quot;tree-shot4&quot; /&gt;&lt;/th&gt;
&lt;th&gt;&lt;img src=&quot;tree-layout2.png&quot; alt=&quot;tree-layout2&quot; /&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;3.2. 定向分割容器&lt;/h3&gt;
&lt;p&gt;当使用树型结构作为数据结构时，使用所谓的&lt;code&gt;分割容器（Split Containers）&lt;/code&gt;来构建布局是很自然的。在 i3 中，每个&lt;code&gt;容器&lt;/code&gt;都有方向（水平、垂直或未指定），并且方向取决于容器的布局（横向布局、纵向布局、堆叠、和选项卡）。在我们的工作区示例中，工作区容器的默认布局是横向分割（现在大多数监视器都是宽屏的）。如果将布局更改为 &lt;code&gt;纵向布局（splitv）&lt;/code&gt;（默认按 &lt;code&gt;$mod+v&lt;/code&gt; ），然后打开两个终端，i3 将显示如下窗口：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;tree-shot2.png&quot; alt=&quot;tree-shot2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;从 v4 向后的版本可以拆分一切的东西：假设在工作空间上有两个终端（横向布局），将焦点移动到右面的终端，现在你想在下面再打开一个终端。如果你直接打开新终端，由于横向布局的原因，它会显示在右边。因此应该按下 &lt;code&gt;$mod + v&lt;/code&gt; 将当前容器切换到纵向布局（切换到横向布局按&lt;code&gt;$mod+h&lt;/code&gt;），现在再打开一个新终端，他会显示在当前的终端下面&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;img src=&quot;tree-shot1.png&quot; alt=&quot;tree-shot1&quot; /&gt;&lt;/th&gt;
&lt;th&gt;&lt;img src=&quot;tree-layout1.png&quot; alt=&quot;tree-layout1&quot; /&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;你可能已经猜到了：这棵树并没有深度限制&lt;/p&gt;
&lt;h3&gt;3.3. 移动焦点到父容器&lt;/h3&gt;
&lt;p&gt;让我们继续 3.2 的例子，我们现有 1 个终端在左边，2 个终端一上一下摆在右边，焦点正在右下角的终端上，当你再打开一个新终端的时候，它会出现在右下角终端的下面。&lt;/p&gt;
&lt;p&gt;那么，如何打开新终端窗口，让它在当前窗口的右侧呢？答案就是&lt;code&gt;聚焦父容器（focus parent）&lt;/code&gt;，在样，聚点将会移动到横向布局的容器。因此，现在新的窗口将被打开到右侧：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;tree-shot3.png&quot; alt=&quot;tree-shot3&quot; /&gt;&lt;/p&gt;
</content:encoded><category>译</category><category>i3wm</category><category>Linux</category><author>Mslxl</author></item><item><title>i3 User&apos;s Guide 操作篇</title><link>https://blog.mslxl.com/posts/tools/i3wm-guide/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/tools/i3wm-guide/</guid><pubDate>Thu, 23 Aug 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;a href=&quot;https://i3wm.org/docs/userguide.html&quot;&gt;原页面&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;该文档包含了配置和使用 i3 的所有信息。如果没有您所需要的信息，请先检查&lt;a href=&quot;https://www.reddit.com/r/i3wm/&quot;&gt;&lt;a href=&quot;https://www.reddit.com/r/i3wm/&quot;&gt;https://www.reddit.com/r/i3wm/&lt;/a&gt;&lt;/a&gt; 是否已包含您所需要的内容，然后再通过 IRC （推荐）或者电子邮件咨询。&lt;/p&gt;
&lt;h2&gt;1.默认键位&lt;/h2&gt;
&lt;p&gt;这是为那些“太长，不读”的用户准备的默认键位的一览&lt;/p&gt;
&lt;p&gt;&lt;em&gt;按下 $mod 键 ( Alt 键 )&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;keyboard-layer1.png&quot; alt=&quot;keyboard-layer1&quot; /&gt;&lt;/p&gt;
&lt;p&gt;&lt;em&gt;按下 Shift + $mod 键&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;keyboard-layer2.png&quot; alt=&quot;keyboard-layer2&quot; /&gt;&lt;/p&gt;
&lt;p&gt;注意在启动 i3 时如果没有配置文件，i3-config-wizard 将会为你提供一份像上图一样的键位，不管你使用什么键盘布局，如果你想使用自己的配置文件，那么只需要取消掉 i3-config-wizard 的提示，然后配置 &lt;code&gt;/etc/i3/config&lt;/code&gt;。&lt;/p&gt;
&lt;h2&gt;2. 使用 i3&lt;/h2&gt;
&lt;p&gt;整篇导航中的 &lt;code&gt;$mod&lt;/code&gt; 都指的是配置文件中配置的修饰键。默认是 Alt 键 (&lt;code&gt;Mod1&lt;/code&gt;)，不过 Windows 键 (&lt;code&gt;Mod4&lt;/code&gt;) 也是一个十分流行的&lt;code&gt;$mod&lt;/code&gt;键，可以有效的防止与应用程序之间的快捷键发生冲突。&lt;/p&gt;
&lt;h3&gt;2.1. 打开终端并四处移动&lt;/h3&gt;
&lt;p&gt;打开一个新终端窗口是非常基础的操作，默认快捷键下为 &lt;code&gt;$mod + Enter&lt;/code&gt;，也就是说在使用默认配置文件时的 &lt;code&gt;Mod1 + Enter&lt;/code&gt;，通过按下 &lt;code&gt;$mod + Enter&lt;/code&gt; 打开一个新终端，他将会占据屏幕上所有可用空间。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;single_terminal.png&quot; alt=&quot;POI&quot; /&gt;&lt;/p&gt;
&lt;p&gt;如果再打开另一个终端，i3 会把它放到当前窗口之后，把屏幕一分为二，分割方向依赖于显示器，I3 将创建的窗口放在现有窗口旁（在宽显示器上）或现有窗口之下（旋转显示）。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;two_terminals.png&quot; alt=&quot;Nanodesu&quot; /&gt;&lt;/p&gt;
&lt;p&gt;你可以使用像 &lt;code&gt;vi&lt;/code&gt; 上的方式移动焦点，但是在 i3 中你需要按住 &lt;code&gt;$mod&lt;/code&gt; 键再按这些按键（在&lt;code&gt;vi&lt;/code&gt;中，这些按键为了兼容大多数键盘布局都被向左移动了一个键）。因此，&lt;code&gt;$mod + j&lt;/code&gt;是向左，&lt;code&gt;$mod + k&lt;/code&gt; 是向下，&lt;code&gt;$mod + l&lt;/code&gt;是向上，&lt;code&gt;$mod + ;&lt;/code&gt;是向右，所以，在两个终端之前切换只需要 &lt;code&gt;$mod + k&lt;/code&gt; 和 &lt;code&gt;$mod + l&lt;/code&gt;，当然，你也可以使用方向键。&lt;/p&gt;
&lt;p&gt;此时，你包含两个终端的工作空间是被指定的方向分割的（默认为横向），每个窗口都可以像工作空间一样重新横向或纵向分割。术语是 “window”，用于包含 X11 窗口（如终端或浏览器）的容器，以及“split container” 用于由一个或多个窗口组成的容器。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;TODO: picture of the tree&lt;/p&gt;
&lt;p&gt;原文中就是 TODO 我也很绝望啊&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;要垂直分割窗口，请在创建新窗口之前按 &lt;code&gt;$mod+v&lt;/code&gt;。要水平拆分，按 &lt;code&gt;$mod+h&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;2.2. 改变容器布局&lt;/h3&gt;
&lt;p&gt;split container 可以有一下几种布局：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;splith/splitv
&lt;ul&gt;
&lt;li&gt;相同容器内的每个窗口获得相等的空间&lt;/li&gt;
&lt;li&gt;splith ：横向布局&lt;/li&gt;
&lt;li&gt;splitv ：纵向布局&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;stacking：堆叠
&lt;ul&gt;
&lt;li&gt;只显示容器内具有焦点的窗口，在容器的顶部会显示所有窗口的列表&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;tabbed：选项卡
&lt;ul&gt;
&lt;li&gt;与 stacking 相同，但是容器顶部的窗口列表是横向显示&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用 &lt;code&gt;$mod + e&lt;/code&gt; 切换 splith 和 splitv 模式，按&lt;code&gt;$mod + s&lt;/code&gt; 切换到 stacking 模式，按 &lt;code&gt;$mod + w&lt;/code&gt; 切换到 tabbed 模式&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;modes.png&quot; alt=&quot;up white ze smart voice&quot; /&gt;&lt;/p&gt;
&lt;h3&gt;2.3. 窗口全屏&lt;/h3&gt;
&lt;p&gt;对当前窗口开关全屏模式，请按 &lt;code&gt;$mod+f&lt;/code&gt; 键。&lt;/p&gt;
&lt;p&gt;在 I3 中还有一个全局全屏模式，命令为 &lt;code&gt;fullscreen toggle global&lt;/code&gt;&lt;/p&gt;
&lt;h3&gt;2.4. 打开其他应用程序&lt;/h3&gt;
&lt;p&gt;除了打开终端外，默认也可以按 &lt;code&gt;$mod + d&lt;/code&gt; 来打开 &lt;code&gt;dmenu&lt;/code&gt; 的菜单。只需要键入你要打开的程序名称就可以打开该应用。&lt;code&gt;dmenu&lt;/code&gt; 将在 &lt;code&gt;$PATH&lt;/code&gt; 中寻找应用程序。&lt;/p&gt;
&lt;p&gt;此外，如果您的应用程序非常频繁地打开，则可以创建用于直接启动应用程序的键绑定。详情请参阅章节 &lt;a href=&quot;https://i3wm.org/docs/userguide.html#configuring&quot;&gt;配置&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;2.5. 关闭窗口&lt;/h3&gt;
&lt;p&gt;如果一个应用程序不提供关闭机制（大多数应用提供一个菜单或者像是 &lt;code&gt;Control + w &lt;/code&gt; 的快捷键），你可以按 &lt;code&gt;$mod + Shift + q&lt;/code&gt; 来关闭窗口。对于支持 WM_DELETE 协议的应用程序，这将正确地关闭应用程序（保存或执行其他清理操作）。如果应用程序不支持 WM_DELETE 协议，则 X 服务器将关闭窗口，并且之后的行为取决于应用程序。&lt;/p&gt;
&lt;h3&gt;2.6. 使用工作空间&lt;/h3&gt;
&lt;p&gt;工作空间是一个可以把窗口组合起来的简单方式。默认情况下你位于第一工作空间，在左下角的指示条上会显示。若要切换到其他工作空间，请按 &lt;code&gt;$mod + num&lt;/code&gt;，&lt;code&gt;num&lt;/code&gt;是要打开的工作空间的序号，如果这个工作空间不存在将会被创建。&lt;/p&gt;
&lt;h3&gt;2.7. 在工作空间中移动窗口&lt;/h3&gt;
&lt;p&gt;要将窗口移动到另一个工作区，只需按 &lt;code&gt;$mod+Shift+num&lt;/code&gt;，其中 &lt;code&gt;num&lt;/code&gt; 是目标工作区的序号。和切换工作空间相似，目标工作空间如果不存在将会被创建。&lt;/p&gt;
&lt;h3&gt;2.8. 调整大小&lt;/h3&gt;
&lt;p&gt;调整容器大小的最最最简单方法是使用鼠标：拖住边框并将其移动到所需大小。&lt;/p&gt;
&lt;p&gt;你也可以使用 &lt;a href=&quot;https://i3wm.org/docs/userguide.html#binding_modes&quot;&gt;模式绑定&lt;/a&gt;来定义一个模式，以供使用键盘移动和调整大小。举个栗子，由 i3 提供的&lt;a href=&quot;https://github.com/i3/i3/blob/next/etc/config.keycodes&quot;&gt;默认配置&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;2.9. 重启 i3&lt;/h3&gt;
&lt;p&gt;如果你遇到了什么 bug 或者要升级高版本，没有必要重启电脑，只需要&lt;code&gt;$mod + Shift + r&lt;/code&gt;。&lt;/p&gt;
&lt;h3&gt;2.10. 退出 i3&lt;/h3&gt;
&lt;p&gt;使用 &lt;code&gt;$mod + Shift + e&lt;/code&gt;可以不关闭 X 服务退出 i3。默认会有一个弹窗来讯问你是否退出。&lt;/p&gt;
&lt;h3&gt;2.11. 浮动模式&lt;/h3&gt;
&lt;p&gt;浮动模式和平铺模式是两个截然相反的模式。窗口的位置和大小不是由 i3 自动管理，而是由您手动管理。使用此模式违反了平铺标准，但对于某些特殊情况（如 “另存为” 对话框窗口或工具栏窗口（GIMP 等））非常有用。这些窗口通常设置适当的提示，默认情况下以浮动模式打开。&lt;/p&gt;
&lt;p&gt;你可以通过 &lt;code&gt;$mod + Shift + Space&lt;/code&gt; 来开关浮动模式。使用你的鼠标拖动窗口的标题可以任意移动该窗口。拖动窗口边框可以重设大小。你也可以使用 &lt;a href=&quot;https://i3wm.org/docs/userguide.html#floating_modifier&quot;&gt;floating_modifier&lt;/a&gt;。右键标题并拖动也是调整窗口大小的另一种方式。&lt;/p&gt;
&lt;p&gt;使用键盘在浮动模式调整窗口大小可以参见 &lt;a href=&quot;https://github.com/i3/i3/blob/next/etc/config.keycodes&quot;&gt;i3 默认配置&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;浮动窗口始终位于平铺窗口上。&lt;/p&gt;
</content:encoded><category>译</category><category>i3wm</category><category>Linux</category><author>Mslxl</author></item><item><title>No Game No Life Zero</title><link>https://blog.mslxl.com/posts/others/nogamenolifezero/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/nogamenolifezero/</guid><pubDate>Tue, 21 Aug 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&amp;lt;hr/&amp;gt;
&amp;lt;iframe frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=298 height=52 src=&quot;//music.163.com/outchain/player?type=2&amp;amp;id=490182455&amp;amp;auto=1&amp;amp;height=32&quot;&amp;gt;&amp;lt;/iframe&amp;gt;&lt;/p&gt;
&lt;p&gt;首先，这是一个悲剧，这是一个有关挣扎，奋斗，生存的悲剧&lt;/p&gt;
&lt;p&gt;在很久以前，这个世界上，似乎存在过叫做太阳的东西，那炽白色的火焰散发着明亮的悠久的光芒，将天空洗涤的蔚蓝透亮。&lt;/p&gt;
&lt;p&gt;是的，在人类的历史中，就是这样流传的。&lt;/p&gt;
&lt;p&gt;但，不知何时起，神与他们所创造的生物为了争夺所谓的『唯一』而展开了无休无止的大战。&lt;/p&gt;
&lt;p&gt;太阳被摧毁，大地在燃烧，所有的种族互相仇视、争斗，将天空染成了血红色。&lt;/p&gt;
&lt;p&gt;值得一提的是，在这些种族里唯独没有人类。&lt;/p&gt;
&lt;p&gt;人类如此弱小，以至于连参战都不配。人类就像战场中的蚂蚁，不要说炮弹，即使是遇到路过的士兵也可能被踩死——即使他是无心的。&lt;/p&gt;
&lt;p&gt;大战产生的精灵遗骸笼罩了天空，布满了大地，这种灰尘宛如死神一样腐蚀着一切生命。&lt;/p&gt;
&lt;p&gt;但人类活下来了。&lt;/p&gt;
&lt;p&gt;利库初登场时，失去了一名同伴，却只是为了寻找维持生活的物资、其他种族的情报，以便避开战争。&lt;/p&gt;
&lt;p&gt;没有什么向他族复仇的小队，也没有什么聚落内的权力争斗。人类没有空闲去想这些，只要能活着就好了。&lt;/p&gt;
&lt;p&gt;人们怕死吗？他们只是怕无意义的死罢了。&lt;/p&gt;
&lt;p&gt;自然也没有玩游戏的时间了。&lt;/p&gt;
&lt;p&gt;利库儿时的那盘棋，也未能下完。&lt;/p&gt;
&lt;p&gt;利库的眼神一直是死去的，看不到希望，没有未来，只能锁上『心锁』，只能活在当下。&lt;/p&gt;
&lt;p&gt;为了拯救 1002 人而牺牲 999 人，值得吗？值得吗？&lt;/p&gt;
&lt;p&gt;但在休比提出西洋棋决斗时，他笑了，光辉一瞬间重回了眼眸，在那时候，『心锁』打开了。&lt;/p&gt;
&lt;p&gt;他是想起了儿时与黑影下棋时的快乐？对滑稽现状的嘲笑？还是他的内心中一直燃着希望的火苗？&lt;/p&gt;
&lt;p&gt;我不知道。在那之后，他的眼神又死去了。&lt;/p&gt;
&lt;p&gt;与机凯种不知是长是短的同居生活开始了。&lt;/p&gt;
&lt;p&gt;关于机铠种，我认为和机械是不同的。它们就像不谙世事的孩子，用眼睛，用身体学习着一切。那么，关于“心”是什么的问题，迟早也会得到解答。利库对断开了链接的休比来说，像是兄长一般，也像恋人一般。在失去了和中枢的链接后，利库就是她的全部，除此之外，只剩下混乱的世界。&lt;/p&gt;
&lt;p&gt;那么，在懂得“心”之后，对利库的爱也就顺理成章了。&lt;/p&gt;
&lt;p&gt;而对利库来说，休比是打破无限重复的悲剧日常的楔子。他开始照顾休比，引导休比，以及依赖休比。&lt;/p&gt;
&lt;p&gt;不知不觉中，就爱上了吧。&lt;/p&gt;
&lt;p&gt;有爱就有希望。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;『第一 不能杀死任何人&lt;/p&gt;
&lt;p&gt;第二 不能让任何人牺牲&lt;/p&gt;
&lt;p&gt;第三 不能让任何人看穿&lt;/p&gt;
&lt;p&gt;第四 任何手段都不算作弊&lt;/p&gt;
&lt;p&gt;第五 不用管他们的规则&lt;/p&gt;
&lt;p&gt;第六 违反以上规则的均为败北』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;有了希望的利库开始向这个世界反抗，他所定下的游戏规则向发起这场殃及无数生命的神明们发出了最大声的嗤笑。&lt;/p&gt;
&lt;p&gt;他为此不惜消耗自己的身体，而休比默默地支撑着他，陪着他。&lt;/p&gt;
&lt;p&gt;利库终于倒下了，为了利库的计划，休比只身一人出发了。&lt;/p&gt;
&lt;p&gt;她再也没有回来。&lt;/p&gt;
&lt;p&gt;吉普莉尔那时的出现，毫无疑问是“天灾”。&lt;/p&gt;
&lt;p&gt;在绝对暴力的面前，这台分析机竭力反抗着，像这个世界的人类一样。&lt;/p&gt;
&lt;p&gt;她拼命地挣扎着，以至于我一度在潜意识里把这挣扎当做了“为了生存”的挣扎。&lt;/p&gt;
&lt;p&gt;以至于她连上中枢的时候，我松了一口气。&lt;/p&gt;
&lt;p&gt;然后我才知道，所谓的连接，并不能让她活下来。&lt;/p&gt;
&lt;p&gt;她不是为了生存，而是为了利库的“胜利”而那样挣扎着。&lt;/p&gt;
&lt;p&gt;她的命运在吉普莉尔登场的时候就已经注定，不，或许，当她爱上弱小的人类的时候，一切就注定了。&lt;/p&gt;
&lt;p&gt;利库还能怎么样呢？&lt;/p&gt;
&lt;p&gt;还能怎么样呢？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“一次就好，连唯一一次赢的机会都不给吗！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;偷偷加入这场游戏的玩家，唯一一个不是优哉游哉的坐在棋盘前的玩家，唯一一个一直在挣扎的玩家，发出了这样的哭喊。&lt;/p&gt;
&lt;p&gt;但她所送出的希望，经由中枢传达到了他身边。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“『规则2 不会让任何人死』，在利库的规则中，道具的损失不能成为败北的判定条件。&lt;/p&gt;
&lt;p&gt;休比的损失，不算做败北。&lt;/p&gt;
&lt;p&gt;将军了，利库。&lt;/p&gt;
&lt;p&gt;之后就拜托你了。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这即是“作弊”。&lt;/p&gt;
&lt;p&gt;休比难道不算做“人”吗？&lt;/p&gt;
&lt;p&gt;但“不被发现就不算做作弊”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我们机铠种是没有心灵的兵器&lt;/p&gt;
&lt;p&gt;只是个道具&lt;/p&gt;
&lt;p&gt;只会忠实地服从与执行命令。”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;利库咬紧了牙。&lt;/p&gt;
&lt;p&gt;难道他不知道这家伙在撒谎吗？&lt;/p&gt;
&lt;p&gt;骗人，你明明也是有心的。&lt;/p&gt;
&lt;p&gt;但，不比发现就不算作弊。&lt;/p&gt;
&lt;p&gt;一切为了胜利。&lt;/p&gt;
&lt;p&gt;为了利库的胜利。&lt;/p&gt;
&lt;p&gt;计划开始。&lt;/p&gt;
&lt;p&gt;三方开炮&lt;/p&gt;
&lt;p&gt;那毁灭世界的能量交织在一起而形成的火球，毫无疑问可以称之为“太阳”。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我们是机械&lt;/p&gt;
&lt;p&gt;无心的道具&lt;/p&gt;
&lt;p&gt;无命而去&lt;/p&gt;
&lt;p&gt;有命而逝&lt;/p&gt;
&lt;p&gt;以上”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;“承知”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;千余机铠种在此散入风中。那最后的眼泪，正是休比所传递的，“心”的证明。&lt;/p&gt;
&lt;p&gt;『星杯』浮现于前。&lt;/p&gt;
&lt;p&gt;利库的手却停在了空中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“为了这个瞬间，到底死去了多少人？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他像是在诘问星杯，也像是质问这世界，也像是在询问自己。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“我究竟命令了多少人去死？”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他带着哭腔问道。本以为挣脱出了那黑色的日常，结果到头来还是一样。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“甚至不惜欺骗自己&lt;/p&gt;
&lt;p&gt;不惜利用休比的思念”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他付出了一切。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“这算哪门子平局啊！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;他哭嚎着，吼叫着，咆哮着&lt;/p&gt;
&lt;p&gt;要去握住『星杯』&lt;/p&gt;
&lt;p&gt;将死的最后一步棋&lt;/p&gt;
&lt;p&gt;苦难的源头&lt;/p&gt;
&lt;p&gt;苦难的终点&lt;/p&gt;
&lt;p&gt;但&lt;/p&gt;
&lt;p&gt;棋子滑落了。&lt;/p&gt;
&lt;p&gt;原来如此&lt;/p&gt;
&lt;p&gt;还以为自己偷偷溜进了棋盘中，&lt;/p&gt;
&lt;p&gt;其实，自己连参赛资格都没拿到。&lt;/p&gt;
&lt;p&gt;那，至今为止&lt;/p&gt;
&lt;p&gt;失去的&lt;/p&gt;
&lt;p&gt;牺牲的&lt;/p&gt;
&lt;p&gt;付出的&lt;/p&gt;
&lt;p&gt;都算什么？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“休比！”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但她已经不在了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“对不起休比，我还是输了”&lt;/p&gt;
&lt;p&gt;你传递给我的希望，我没能守护住。&lt;/p&gt;
&lt;p&gt;“下次真的想赢一次啊，休比，在不会让任何人牺牲的游戏”&lt;/p&gt;
&lt;p&gt;在不会失去你的游戏。&lt;/p&gt;
&lt;p&gt;啊啊，游戏。&lt;/p&gt;
&lt;p&gt;游戏之神啊。&lt;/p&gt;
&lt;p&gt;“我再次将一切奉献给你换取此生唯一请求！&lt;/p&gt;
&lt;p&gt;拜托了！”&lt;/p&gt;
&lt;p&gt;我不承认！我不承认我连这该死的游戏都没有加入！&lt;/p&gt;
&lt;p&gt;我只是输了！&lt;/p&gt;
&lt;p&gt;“如果说区区『败者』妄要夺取星杯过于肮脏的话”&lt;/p&gt;
&lt;p&gt;我怎么能承认，那些死去的人，都是白白丧命！&lt;/p&gt;
&lt;p&gt;“如果说是这双手浸染了太多鲜血的话！”&lt;/p&gt;
&lt;p&gt;他们的血，由我带到这棋盘上&lt;/p&gt;
&lt;p&gt;“谁都好，只要是能结束这场战争的人&lt;/p&gt;
&lt;p&gt;请把这个『星杯』交给他，无论是谁！”&lt;/p&gt;
&lt;p&gt;请把我的同伴，我的休比，拥有心灵的那些家伙们所传递过来的『希望』交给他，无论是谁！&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;一双手握住了『星杯』&lt;/p&gt;
&lt;p&gt;那弱小到只有模糊影像的游戏之神握住了『希望』&lt;/p&gt;
&lt;p&gt;那一路传递过来的『希望』&lt;/p&gt;
&lt;p&gt;这样的景象，一定是利库最后的幸福了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“哈哈&lt;/p&gt;
&lt;p&gt;搞什么嘛&lt;/p&gt;
&lt;p&gt;你&lt;/p&gt;
&lt;p&gt;果然是存在的嘛”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;最后，把白方的车移到E6&lt;/p&gt;
&lt;p&gt;从当初那个小小的少年&lt;/p&gt;
&lt;p&gt;从那个小小的棋盘上开始的&lt;/p&gt;
&lt;p&gt;和神的游戏&lt;/p&gt;
&lt;p&gt;和神们的游戏&lt;/p&gt;
&lt;p&gt;结束了&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;『回头再 一起玩游戏吧&lt;/p&gt;
&lt;p&gt;这次我一定要赢你&lt;/p&gt;
&lt;p&gt;和休比一起』&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;啊啊，那样的世界确实被创造出来了，在等着你和休比呢。&lt;/p&gt;
&lt;p&gt;但是&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;引きよせ合う 二人はどこへ&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content:encoded><category>随笔</category><author>Mslxl</author></item><item><title>编译原理：绪论 —— 中间代码生成和编译器后端</title><link>https://blog.mslxl.com/posts/others/n5/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/n5/</guid><pubDate>Wed, 27 Jun 2018 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;中间代码生成&lt;/h2&gt;
&lt;p&gt;源程序的中间代码表现可以有多种形式，常见的是 &lt;em&gt;三地址码 (Three-address Code)&lt;/em&gt; 和 &lt;em&gt;语法结构树 (Syntax Trees)&lt;/em&gt;，语法结构树简称语法树。在这里我们只介绍一下三地址码。&lt;/p&gt;
&lt;p&gt;三地址码由类似于汇编语言的指令序列组成，每个指令最多有三个操作数 (operand)，因此叫三地址码。&lt;/p&gt;
&lt;h3&gt;常用的三地址指令&lt;/h3&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;序号&lt;/th&gt;
&lt;th&gt;指令类型&lt;/th&gt;
&lt;th&gt;指令形式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;赋值指令&lt;/td&gt;
&lt;td&gt;x = y &lt;code&gt;op&lt;/code&gt; z&amp;lt;br/&amp;gt;x = &lt;code&gt;op&lt;/code&gt; z&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;复制指令&lt;/td&gt;
&lt;td&gt;x &lt;code&gt;=&lt;/code&gt; y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;条件跳转&lt;/td&gt;
&lt;td&gt;if x &lt;code&gt;relop&lt;/code&gt; y goto n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;非条件跳转&lt;/td&gt;
&lt;td&gt;&lt;code&gt;goto&lt;/code&gt; n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;参数传递&lt;/td&gt;
&lt;td&gt;&lt;code&gt;param&lt;/code&gt; x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;过程调用&lt;/td&gt;
&lt;td&gt;&lt;code&gt;call&lt;/code&gt; p , n&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;过程返回&lt;/td&gt;
&lt;td&gt;&lt;code&gt;return&lt;/code&gt; x&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;数组引用&lt;/td&gt;
&lt;td&gt;x &lt;code&gt;=&lt;/code&gt; y&lt;code&gt;[&lt;/code&gt;i&lt;code&gt;]&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;数组赋值&lt;/td&gt;
&lt;td&gt;x&lt;code&gt;[&lt;/code&gt;i&lt;code&gt;]&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; y&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;地址&amp;lt;br/&amp;gt;及&amp;lt;br/&amp;gt;指针操作&amp;lt;br/&amp;gt;&lt;/td&gt;
&lt;td&gt;x &lt;code&gt;= &amp;amp;&lt;/code&gt;y&amp;lt;br/&amp;gt;x &lt;code&gt;= *&lt;/code&gt;y&amp;lt;br/&amp;gt;&lt;code&gt;*&lt;/code&gt;x &lt;code&gt;=&lt;/code&gt; y&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;不解释，自己体会。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;// x = op z 其实就是这一类一元运算符
x = ++z
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;在 &lt;code&gt;数组赋值&lt;/code&gt; 和 &lt;code&gt;数组引用&lt;/code&gt; 中，&lt;code&gt;i&lt;/code&gt; 表示的是数组的偏移地址而不是数组的下标，而 x[i] 和 y[i] 中的 x 和 y 是数组的基地址。&lt;/p&gt;
&lt;p&gt;为了方便起见，像 &lt;code&gt;x&lt;/code&gt; 、&lt;code&gt;y&lt;/code&gt;、&lt;code&gt;z&lt;/code&gt; 等之类的地址我们可以用源程序中的名字，也就是标识符，来作为三地址指令中的地址，因为标识符对应的地址都存放在符号表中，因此通过这些名字就可以找到对应的地址。另外，像是常量或者编译器生成的临时变量也可以作为三地址指令的地址。&lt;/p&gt;
&lt;h3&gt;三地址指令的表示&lt;/h3&gt;
&lt;p&gt;三地址指令的表现形式有一下几种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;四元式 (Quadruples)&lt;/li&gt;
&lt;li&gt;三元式 (Triples)&lt;/li&gt;
&lt;li&gt;间接三元式&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以四元式为例，它由四个分量构成，其中第一个分量表示三地址指令中的操作符，后边三个分量对应与三个操作数。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;(op,y,z,x)
&lt;/code&gt;&lt;/pre&gt;
&lt;h4&gt;三地址指令的四元式表示&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;三地址&lt;/th&gt;
&lt;th&gt;四元式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;x = y &lt;code&gt;op&lt;/code&gt; z&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;op&lt;/code&gt; , y , z , x )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x = &lt;code&gt;op&lt;/code&gt; y&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;op&lt;/code&gt; , y , _ , x )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x &lt;code&gt;=&lt;/code&gt; y&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;=&lt;/code&gt; , y , _ , x )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;if x &lt;code&gt;relop&lt;/code&gt; y goto n&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;relop&lt;/code&gt; , x , y , n )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;goto&lt;/code&gt; n&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;goto&lt;/code&gt; , n )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;param&lt;/code&gt; x&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;param&lt;/code&gt; , _ , _ , x )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;call&lt;/code&gt; p , n&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;call&lt;/code&gt; , p , n , _ )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;return&lt;/code&gt; x&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;return&lt;/code&gt; , _ , _ , x )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x &lt;code&gt;=&lt;/code&gt; y&lt;code&gt;[&lt;/code&gt;i&lt;code&gt;]&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;=[]&lt;/code&gt; , y , i ,x )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x &lt;code&gt;[&lt;/code&gt;i&lt;code&gt;]&lt;/code&gt; &lt;code&gt;=&lt;/code&gt; y&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;[]=&lt;/code&gt;,y , x , i )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x &lt;code&gt;= &amp;amp;&lt;/code&gt; y&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;&amp;amp;&lt;/code&gt; , y , _ , x )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;x &lt;code&gt;= *&lt;/code&gt; y&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;=*&lt;/code&gt; , y, _ , x )&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;*&lt;/code&gt;x &lt;code&gt;=&lt;/code&gt; y&lt;/td&gt;
&lt;td&gt;(&lt;code&gt;*=&lt;/code&gt; , y , _ , x )&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;在四元式中，第二个分量和第三个分量为源操作数，第四个分量为目标操作数，如果第二个源操作数为空，那么第三个分量也为空。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt;三地址指令序列唯一确定了运算完成的顺序&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;h3&gt;Example : 中间代码生成&lt;/h3&gt;
&lt;p&gt;假入输入这样一个程序片段:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while a &amp;lt; b do
    if c &amp;lt; 5 then
        while x &amp;gt; y do
            z = x + 1;
    else x = y;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么它对应的分析树就是这样的(敲这棵树累死我了):&lt;/p&gt;
&lt;p&gt;&amp;lt;pre class=&quot;mermaid&quot;&amp;gt;
graph TD
S --- Text7[while]
S --- B1[B]
S --- do
S --- S1[S]
B1 --- E1[E]
E1 --- Text1[&quot;id ( a )&quot;]
B1 --- Text2[&quot;relop ( &amp;lt; )&quot;]
B1 --- E2[E]
E2 --- Text3[&quot;id ( b )&quot;]
S1 --- if
S1 --- B2[B]
S1 --- then
S1 --- S2[S]
S1 --- else
S1 --- S3[S]
B2 --- E3[E]
E3 --- Text4[&quot;id ( e )&quot;]
B2 --- Text5[&quot;relop ( &amp;lt; )&quot;]
B2 --- E4[E]
E4 --- Text6[&quot;num ( 5 )&quot;]
S2 --- Text8[while]
S2 --- B3[B]
S2 --- Text9[do]
S2 --- S4[S]
B3 --- E5[E]
E5 --- Text10[&quot;id ( x )&quot;]
B3 --- Text11[&quot;relop ( &amp;gt; )&quot;]
B3 --- E6[E]
E6 --- Text12[&quot;id ( y )&quot;]
S4 --- Text13[&quot;id ( z )&quot;]
S4 --- Text14[=]
S4 --- E7[E]
S4 --- Text15[&quot;;&quot;]
E7 --- E8[E]
E7 --- Text16[&quot;+&quot;]
E7 --- E9[E]
E8 --- Text17[&quot;id ( x )&quot;]
E9 --- Text18[&quot;num ( 1 )&quot;]
S3 --- Text19[&quot;id ( x )&quot;]
S3 --- Text20[&quot;=&quot;]
S3 --- E10[E]
S3 --- Text21[&quot;;&quot;]
E10 --- Text22[&quot;id ( y )&quot;]
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;p&gt;他对应的中间代码应该是这样的:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;100: ( j&amp;lt; , a  , b , 102 )
101: ( j  , -  , - , 112 )
102: ( j&amp;lt; , c  , 5 , 104 )
103: ( j  , -  , - , 110 )
104: ( j&amp;gt; , x  , y , 106 )
105: ( j  , -  , - , 100 )
106: ( +  , x  , 1 , t1  )
107: ( =  , t1 , - , z   )
108: ( j  , -  , - , 104 )
109: ( j  , -  , - , 100 )
110: ( =  , y  , - , x   )
111: ( j  , -  , - , 100 )
112:
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里，冒号前面的数字表示代码的标号，这里我们从 100 取到 112。&lt;/p&gt;
&lt;p&gt;第 &lt;code&gt;100&lt;/code&gt; 条指令是条件跳转指令，这条指令表示如果 &lt;code&gt;a&lt;/code&gt; 小于 &lt;code&gt;b&lt;/code&gt; 就跳转到 &lt;code&gt;102&lt;/code&gt; 号指令，否则的话就继续执行 &lt;code&gt;101&lt;/code&gt; 行指令，&lt;code&gt;101&lt;/code&gt; 号指令是一条无条件跳转指令，也就是跳转到 &lt;code&gt;112&lt;/code&gt; 号指令，也就是跳出整个 while 循环。&lt;/p&gt;
&lt;p&gt;按照上面给出的伪代码，对照四元式，试着分析这段三地址指令的操作。&lt;/p&gt;
&lt;h2&gt;目标代码生成&lt;/h2&gt;
&lt;p&gt;目标代码生成以源程序的&lt;strong&gt;中间表示形式&lt;/strong&gt;作为输入，并把它映射到目标语言。&lt;/p&gt;
&lt;p&gt;目标代码生成的一个重要任务就是为程序中使用的变量&lt;strong&gt;合理分配寄存器&lt;/strong&gt;&lt;/p&gt;
&lt;h2&gt;代码优化&lt;/h2&gt;
&lt;p&gt;代码优化就是为改进代码所进行的&lt;strong&gt;等价的程序变换&lt;/strong&gt;，使其拥有更好的时空占用。&lt;/p&gt;
&lt;p&gt;代码优化分为&lt;strong&gt;机器无关代码优化&lt;/strong&gt;和&lt;strong&gt;机器相关代码优化&lt;/strong&gt;，前者是在中间代码中优化，后者是对目标语言进行优化，优化的内容包括很多方面，比如说自动识别代码中的重复运算，并将他们删除，再比如将代价较高的运算替换为代价较低的等价的运算等等。&lt;/p&gt;
&lt;p&gt;&amp;lt;pre class=&quot;mermaid&quot;&amp;gt;
graph TD
Start-- 字符流 --&amp;gt;词法分析器
词法分析器-- 词法字节流 --&amp;gt;语法分析器
语法分析器-- 语法树 --&amp;gt;语义分析器
语义分析器-- 语法树 --&amp;gt;中间代码生成器
中间代码生成器-- 中间表示形式 --&amp;gt;机器无关代码优化器
机器无关代码优化器-- 中间表示形式 --&amp;gt;目标代码生成器
目标代码生成器-- 目标机器语言 --&amp;gt;机器相关代码优化器
机器相关代码优化器-- 目标机器语言 --&amp;gt;Fin
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h1&gt;第一章 结束&lt;/h1&gt;
</content:encoded><category>Compiler</category><author>Mslxl</author></item><item><title>编译原理：绪论 —— 语义分析</title><link>https://blog.mslxl.com/posts/others/n4/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/n4/</guid><pubDate>Tue, 26 Jun 2018 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;语义分析&lt;/h2&gt;
&lt;h3&gt;语义分析的任务&lt;/h3&gt;
&lt;p&gt;语义分析是编译过程的第三个阶段，高级语言中的语句大多数分为两类，一类是声明语句，一类是可执行语句，在声明语句中会声明一些数据对象或过程，并且为他们分别起一个名字 &lt;code&gt;标识符 (id)&lt;/code&gt;，对于声明语句来说，语义分析的主要任务就是收集标识符的属性信息，一般有这些属性信息&lt;/p&gt;
&lt;h4&gt;对声明语句语义分析的任务&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;种属 （Kind） : 它说明了这个标识符对应的是简单变量，还是一个复合变量（数组、记录、...），还是过程、...&lt;/li&gt;
&lt;li&gt;类型 （Type） : 这个我相信都不用说了把&lt;/li&gt;
&lt;li&gt;储存位置、长度 : 比如说我们写了一个对象或过程，我们都要在内存中给他分配一段空间，这样存储位置和所占用的空间的大小（长度）就成为标识符重要的属性&lt;/li&gt;
&lt;li&gt;值&lt;/li&gt;
&lt;li&gt;作用域&lt;/li&gt;
&lt;/ol&gt;
&lt;h5&gt;关于 3 举个例子：&lt;/h5&gt;
&lt;pre&gt;&lt;code&gt;begin
    real x[8]
    integer i,j;
    ...
end
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;首先声明了一个实型数组&lt;code&gt;x&lt;/code&gt; ，因此 &lt;code&gt;x&lt;/code&gt; 的相对地址就是 &lt;code&gt;0&lt;/code&gt;。我们假设一个实型变量占用 8 个字节，因为这个实型数组包含 8 个元素，因此他就占用了 64 个字节，所以接下来声明的变量 &lt;code&gt;i&lt;/code&gt; 的相对地址就是 64,我们再假设一个整形变量占用 4 个字节，那么接下来声明的变量 &lt;code&gt;j&lt;/code&gt; 的相对地址就是 &lt;em&gt;64 + 4 = 68&lt;/em&gt; ，以此类推。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;名字&lt;/th&gt;
&lt;th&gt;相对地址&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;x&lt;/td&gt;
&lt;td&gt;0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;i&lt;/td&gt;
&lt;td&gt;64&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;j&lt;/td&gt;
&lt;td&gt;68&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;|:-:|:-:|
|0|x[0]|
|8|x[1]|
| | |
| |......|
|56|x[7]|
|64|i|
|68|j|&lt;/p&gt;
&lt;h4&gt;对过程语义分析的任务&lt;/h4&gt;
&lt;p&gt;对于过程来说，作用有 0. 参数和返回值信息 ： 包含了参数个数、参数类型、参数传递方式、返回值类型等等&lt;/p&gt;
&lt;h4&gt;符号表 (Symbol Table)&lt;/h4&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;NAME&lt;/th&gt;
&lt;th&gt;TYPE&lt;/th&gt;
&lt;th&gt;KIND&lt;/th&gt;
&lt;th&gt;VAL&lt;/th&gt;
&lt;th&gt;ADDR&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;SIMPLE&lt;/td&gt;
&lt;td&gt;整&lt;/td&gt;
&lt;td&gt;简变&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;SYMBLE&lt;/td&gt;
&lt;td&gt;实&lt;/td&gt;
&lt;td&gt;数组&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;TABLE&lt;/td&gt;
&lt;td&gt;字符&lt;/td&gt;
&lt;td&gt;常数&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;语义分析中收集的标识符的信息都会存放在符号表里，每一个标识符都对应着一条记录，每个字段对应着一个属性，比如说 &lt;code&gt;类型 (TYPE)&lt;/code&gt;、&lt;code&gt;种属 (KIND)&lt;/code&gt;、&lt;code&gt;值 (VALUE)&lt;/code&gt; 和 &lt;code&gt;地址 (ADDRESS)&lt;/code&gt;等等。&lt;/p&gt;
&lt;p&gt;符号表中通常带有一个字符串表，用来存放程序中标识符的名称和字符常数，这样的话 &lt;code&gt;NAME&lt;/code&gt; 字段就会被分割成两个部分，一个用来存放标识符在字符串表中的起始位置，另一个存放标识符的长度，这里由于 Markdown 的限制不能将其表现出来。符号表中设计字符串表的作用是节省内存空间。&lt;/p&gt;
&lt;h4&gt;语义分析的另一个任务：语义检查&lt;/h4&gt;
&lt;p&gt;常见的语义错误有：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;变量或过程&lt;strong&gt;未经声明就使用&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;变量或过程名&lt;strong&gt;重复声明&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;运算分量&lt;/strong&gt;类型不匹配:其中需要判断是否运算无意义（比如将一个数组与数字相加）和是否需要隐式转换&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;操作符&lt;/strong&gt;与&lt;strong&gt;操作数&lt;/strong&gt;之间类型不匹配
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;数组下标&lt;/strong&gt; 不是整数&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;非数组变量&lt;/strong&gt;使用数组访问操作符&lt;/li&gt;
&lt;li&gt;对&lt;strong&gt;非过程名&lt;/strong&gt;使用过程调用操作符&lt;/li&gt;
&lt;li&gt;过程调用的&lt;strong&gt;参数类型或数目&lt;/strong&gt;不匹配&lt;/li&gt;
&lt;li&gt;函数&lt;strong&gt;返回类型&lt;/strong&gt;有误&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;pre class=&quot;mermaid&quot;&amp;gt;
graph TD
Start-- 字符流 --&amp;gt;词法分析器
词法分析器-- 词法字节流 --&amp;gt;语法分析器
语法分析器-- 语法树 --&amp;gt;语义分析器
语义分析器-- 语法树 --&amp;gt;中间代码生成器
中间代码生成器-- 中间表示形式 --&amp;gt;机器无关代码优化器
机器无关代码优化器-- 中间表示形式 --&amp;gt;目标代码生成器
目标代码生成器-- 目标机器语言 --&amp;gt;机器相关代码优化器
机器相关代码优化器-- 目标机器语言 --&amp;gt;Fin
&amp;lt;/pre&amp;gt;&lt;/p&gt;
</content:encoded><category>Compiler</category><author>Mslxl</author></item><item><title>编译原理：绪论 —— 语法分析</title><link>https://blog.mslxl.com/posts/others/n3/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/n3/</guid><pubDate>Mon, 25 Jun 2018 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;语法分析 (Parsing)&lt;/h2&gt;
&lt;p&gt;语法分析是编译的第二个阶段，它的主要任务是从词法分析器输出的 &lt;code&gt;Token序列中&lt;/code&gt; &lt;strong&gt;识别出各类短语&lt;/strong&gt;，并&lt;strong&gt;构造语法分析树 （parse tree）&lt;/strong&gt;，语法分析树描述了句子的语法结构。&lt;/p&gt;
&lt;h3&gt;Example 1&lt;/h3&gt;
&lt;p&gt;先来看一个赋值语句的分析&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;position = initial + rate * 60;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;经过词法扫描后会得到这样的一个 Token 序列:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;id,position&amp;gt; &amp;lt;=&amp;gt; &amp;lt;id,initial&amp;gt; &amp;lt;+&amp;gt; &amp;lt;id,rate&amp;gt; &amp;lt;*&amp;gt; &amp;lt;num,60&amp;gt; &amp;lt;;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它对应的分析树应该就是这样的:&lt;/p&gt;
&lt;p&gt;&amp;lt;pre class=&quot;mermaid&quot;&amp;gt;
graph TD
赋值语句---A[&quot;标识符 (position)&quot;]
赋值语句---B[&quot;=&quot;]
赋值语句---C[&quot;表达式&quot;]
赋值语句---D[&quot;;&quot;]
C---E[&quot;表达式&quot;]
C---F[&quot;+&quot;]
C---G[&quot;表达式&quot;]
E---H[&quot;标识符 (rate)&quot;]
G---I[&quot;数字 (60) &quot;]
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;p&gt;从中我们可以看出，一个标识符，或者一个常数本身，都可以构成一个表达式，一个表达式加上另一个表达式，或者一个表达式乘上另一个表达式，都可以构成更大的表达式，一个标识符，连接上一个表达式，再连接一个表达式，最后跟上一个分号，可以构成一条赋值语句。&lt;/p&gt;
&lt;h3&gt;Example 2：变量声明语句的分析树&lt;/h3&gt;
&lt;p&gt;首先我们先来看变量声明语法分析树的文法：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;D&amp;gt; → &amp;lt;T&amp;gt; &amp;lt;IDS&amp;gt; ;
&amp;lt;T&amp;gt; → int | real | char | bool
&amp;lt;IDS&amp;gt; → id | &amp;lt;IDS&amp;gt; , id
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;这里的&lt;code&gt;&amp;lt;D&amp;gt;&lt;/code&gt;是英文单词 &lt;em&gt;declaration&lt;/em&gt; 的首字母，表示声明语句，&lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 是英文单词 &lt;em&gt;type&lt;/em&gt; 的首字母，表示类型，&lt;code&gt;&amp;lt;IDS&amp;gt;&lt;/code&gt;则是英文单词 &lt;em&gt;Identifier sequence&lt;/em&gt; 的首字母，表示标识符序列。&lt;/p&gt;
&lt;p&gt;从中我们可以看出，一个声明语句 &lt;code&gt;&amp;lt;D&amp;gt;&lt;/code&gt; 是由一个类型 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 连接上一个标识符序列 &lt;code&gt;&amp;lt;IDS&amp;gt;&lt;/code&gt; 和一个分号构成。&lt;/p&gt;
&lt;p&gt;第二行则表示这里的 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 可以是 &lt;code&gt;int&lt;/code&gt;，可以是 &lt;code&gt;real&lt;/code&gt;，或者 &lt;code&gt;char&lt;/code&gt;、&lt;code&gt;bool&lt;/code&gt;，这里的竖线 &lt;code&gt;|&lt;/code&gt; 表示的是&lt;strong&gt;或&lt;/strong&gt;关系。&lt;/p&gt;
&lt;p&gt;根据第三行规则可以看出，一个标识符 &lt;code&gt;id&lt;/code&gt; 本身可以构成一个标识符序列 &lt;code&gt;&amp;lt;IDS&amp;gt;&lt;/code&gt;，或者一个标识符序列 &lt;code&gt;&amp;lt;IDS&amp;gt;&lt;/code&gt; 连接上一个 &lt;code&gt;,&lt;/code&gt; 和一个标识符 &lt;code&gt;id&lt;/code&gt; 可以构成一个更大的标识符序列 &lt;code&gt;&amp;lt;IDS&amp;gt;&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;根据这个文法，假如说我们输入了这样的一个声明语句:&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;int a,b,c;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;那么它的语法分析树就是这样的&lt;/p&gt;
&lt;p&gt;&amp;lt;pre class=&quot;mermaid&quot;&amp;gt;
graph TD
A[&quot;&amp;lt; D &amp;gt;&quot;] ---  B[&quot;&amp;lt; T &amp;gt;&quot;]
B---int
A---C[&quot;&amp;lt; IDS &amp;gt;&quot;]
C---D[&quot;&amp;lt; IDS &amp;gt;&quot;]
C---E[&quot;,&quot;]
C---G[&quot;id (c)&quot;]
A---F[&quot;;&quot;]
D---H[&quot;&amp;lt; IDS &amp;gt;&quot;]
D---J[&quot;,&quot;]
D---K[&quot;id (b)&quot;]
H---L[&quot;id (a)&quot;]
&amp;lt;/pre&amp;gt;&lt;/p&gt;
&lt;p&gt;从中我们可以发现，一个 &lt;code&gt;id (a)&lt;/code&gt; 本身可以构成一个 &lt;code&gt;&amp;lt;IDS&amp;gt;&lt;/code&gt;，
一个 &lt;code&gt;&amp;lt;IDS&amp;gt;&lt;/code&gt; 连接上 &lt;code&gt;,&lt;/code&gt; 和 &lt;code&gt;id (b)&lt;/code&gt; 又可以构成一个更大的 &lt;code&gt;&amp;lt;IDS&amp;gt;&lt;/code&gt;,一个类型 &lt;code&gt;&amp;lt;T&amp;gt;&lt;/code&gt; 连接这个 &lt;code&gt;&amp;lt;IDS&amp;gt;&lt;/code&gt; 和 &lt;code&gt;;&lt;/code&gt; 就构成了声明语句 &lt;code&gt;&amp;lt;D&amp;gt;&lt;/code&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;pre class=&quot;mermaid&quot;&amp;gt;
graph TD
Start-- 字符流 --&amp;gt;词法分析器
词法分析器-- 词法字节流 --&amp;gt;语法分析器
语法分析器-- 语法树 --&amp;gt;语义分析器
语义分析器-- 语法树 --&amp;gt;中间代码生成器
中间代码生成器-- 中间表示形式 --&amp;gt;机器无关代码优化器
机器无关代码优化器-- 中间表示形式 --&amp;gt;目标代码生成器
目标代码生成器-- 目标机器语言 --&amp;gt;机器相关代码优化器
机器相关代码优化器-- 目标机器语言 --&amp;gt;Fin
&amp;lt;/pre&amp;gt;&lt;/p&gt;
</content:encoded><category>Compiler</category><author>Mslxl</author></item><item><title>编译原理：绪论</title><link>https://blog.mslxl.com/posts/others/n1/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/n1/</guid><pubDate>Sun, 24 Jun 2018 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;最近在学习编译原理，把笔记整理一下写在上面&lt;/p&gt;
&lt;hr /&gt;
&lt;h2&gt;什么是编译？&lt;/h2&gt;
&lt;p&gt;编译是将一种语言翻译为另外一种语言，将被翻译的语言叫做&lt;code&gt;源程序&lt;/code&gt;，而翻译之后的语言叫做目标语言一般来说，编译是将高级语言翻译为低级语言，例如 &lt;code&gt;GCC&lt;/code&gt; 等 C++ 编译器就是将 C++ 翻译为机器语言或中间语言。&lt;/p&gt;
&lt;p&gt;高级语言(High Level Language)符合人的表达习惯且易于学习和记忆，常见的就是 C++ 、Java。&lt;/p&gt;
&lt;p&gt;低级语言则相反，并且与运行的机器密切相关，比如汇编语言(Assembly Language)和机器语言(Machine Language)。&lt;/p&gt;
&lt;p&gt;下面分别是 C++ 、汇编语言和机器语言的画风：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x = 1
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;MOV X,2
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;C706 0000 0002
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;通过上面几个例子，我们就知道了什么是编译以及为什么要编译。&lt;/p&gt;
&lt;h2&gt;编译器在语言处理中的位置&lt;/h2&gt;
&lt;p&gt;在变异中，除了编译器，我们还需要其他的一些东西。&lt;/p&gt;
&lt;p&gt;首先，我们需要&lt;strong&gt;预处理器 (Preprocessor)&lt;/strong&gt;，源程序可能会被分割成模块，储存在不同的文件中，预处理器则会把他们 &lt;strong&gt;聚合&lt;/strong&gt; 在一起，并把其中称之为宏的缩写语句展开。&lt;/p&gt;
&lt;p&gt;之后，被处理过的源程序则会通过 &lt;strong&gt;编译器&lt;/strong&gt; 和 &lt;strong&gt;汇编器(Assembler)&lt;/strong&gt; 生成可重定位 (Relocatable) 的机器代码，可重定位代码在内存中存放的起始位置 &lt;em&gt;L&lt;/em&gt; 是不固定的，代码中的所有地址都是相对于这个 &lt;em&gt;L&lt;/em&gt; 的相对地址，$\text{起始地址} + \text{相对地址} = \text{绝对地址}$，因为代码中的内存地址都是相对的，所以，我们需要&lt;strong&gt;加载器 (Loader)&lt;/strong&gt; 来修改可重定位地址，将修改后的指令和数据放在内存中适当的位置，还有一种情况使用的是 &lt;strong&gt;链接器 (Linker)&lt;/strong&gt; 而不是加载器，因为大型程序会被分割成很多部分，在这种情况下，链接器会将生成可重定位的机器代码与库文件进行链接，从而生成可执行代码，同时链接器还会解决&lt;em&gt;外部内存地址&lt;/em&gt;问题，所谓外部内存地址，就是指一个文件中的代码，可能会引用另一个文件中的对象或者过程，这些被引用的对象或者过程的地址，相对于这个文件来说就是&lt;em&gt;外部地址&lt;/em&gt;。&lt;/p&gt;
&lt;p&gt;一个完整的系统大致就是这样&lt;/p&gt;
&lt;p&gt;&amp;lt;pre class=&quot;mermaid&quot;&amp;gt;
graph TD
Start-- 源程序 --&amp;gt;预处理器
预处理器-- 经过处理的源程序 --&amp;gt;编译器
编译器-- 汇编语言程序 --&amp;gt;汇编器
汇编器-- 可重定位的机器代码 --&amp;gt;链接器/加载器
链接器/加载器-- 目标机器代码 --&amp;gt;Fin
&amp;lt;/pre&amp;gt;&lt;/p&gt;
</content:encoded><category>Compiler</category><author>Mslxl</author></item><item><title>编译原理：绪论 —— 词法分析</title><link>https://blog.mslxl.com/posts/others/n2/</link><guid isPermaLink="true">https://blog.mslxl.com/posts/others/n2/</guid><pubDate>Sun, 24 Jun 2018 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;词法分析 (Scanning)&lt;/h2&gt;
&lt;p&gt;词法分析是编译的第一个阶段。词法分析器的主要任务是从左向右逐行扫描 (Scanning) 源程序的字符，识别出各个单词，确定单词的类型。将识别出的单词转换成统一的机内表示——词法单元 (token) 形式。&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;token: &amp;lt;种别码,属性值&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;token 是一个二元组，其中第一个分量种别码用来表示单词的种别，就比如人说的自然语言中都有词性,程序设计语言也有这些东西，他们大体可分为五类:&lt;/p&gt;
&lt;p&gt;|     | 单词类型 |                               种别                                |  种别码  |
| :-: | :------: | :---------------------------------------------------------------: | :------: | -------------------------------- |
|  1  |  关键字  |                   program、if、else、then、...                    | 一词一码 |
|  2  |  标识符  |                变量名、数组名、记录名、过程名、...                | 多词一码 |
|  3  |   常量   |                 整型、浮点型、字符型、布尔型、...                 | 一型一码 |
|  4  |  运算符  | 算术 (+ - * / ++ --）&amp;lt;/br&amp;gt;关系 ( &amp;gt; &amp;lt; == != &amp;gt;= &amp;lt;= ) &amp;lt;/br&amp;gt; 逻辑 (&amp;amp; |   ~ )    | 一词一码 &amp;lt;/br&amp;gt; 或 &amp;lt;/br&amp;gt; 一型一码 |
|  5  |  界限符  |                          ; ( ) = { } ...                          | 一词一码 |&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;1&lt;/em&gt; 中，因为我们每个关键字都是确定的，所以我们为每一个关键字分配一个种别码，也就是一词一码。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;2&lt;/em&gt; 是标识符，他是程序员在编程中为对象等起的名字，由于标识符是一个开放的集合，我们在事先并不能确认到底有那些标识符，因此我们将所有的标识符都作为一个单词并分配同一个种别码，也就是多词一码，为了区分每个标识符，我们使用 token 的第二个分量属性值来储存不同标识符具体的字面值&lt;/p&gt;
&lt;p&gt;&lt;em&gt;3&lt;/em&gt; 是常量，常量与标识符类似，也是一个开放型集合，但是不同类型的常量他们的构成类型是不同的，因此我们可以给每个不同类型的常量分配一个种别码，也就是也就是一型一码，为了区分不同的常量，我们也是使用 token 的第二个分量来存放每个常量具体的值&lt;/p&gt;
&lt;p&gt;&lt;em&gt;4&lt;/em&gt; 和 &lt;em&gt;5&lt;/em&gt; 与 &lt;em&gt;1&lt;/em&gt; 类似，他们都是可以事先可以确定的，所以我们可以为每一个运算符和界限符分配一个种别码，也就是一词一码，当然我们也可以为每一个运算符分配一个种别码，为了区分他们具体的区别，同样我们也要使用 token 的第二个分量&lt;/p&gt;
&lt;h3&gt;Example&lt;/h3&gt;
&lt;p&gt;根据以上的分配原则，我们可以看一个例子&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;while (value != 100){
    num++;
}
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;对以上代码进行分析，我们可以得到这样的一个 token 序列&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;th&gt;Code&lt;/th&gt;
&lt;th&gt;Token&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;1&lt;/td&gt;
&lt;td&gt;while&lt;/td&gt;
&lt;td&gt;WHILE,-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;2&lt;/td&gt;
&lt;td&gt;(&lt;/td&gt;
&lt;td&gt;SLP,-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;3&lt;/td&gt;
&lt;td&gt;value&lt;/td&gt;
&lt;td&gt;IDN,value&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;4&lt;/td&gt;
&lt;td&gt;!=&lt;/td&gt;
&lt;td&gt;NE,-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;5&lt;/td&gt;
&lt;td&gt;100&lt;/td&gt;
&lt;td&gt;CONST,100&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;6&lt;/td&gt;
&lt;td&gt;)&lt;/td&gt;
&lt;td&gt;SPR,-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;7&lt;/td&gt;
&lt;td&gt;{&lt;/td&gt;
&lt;td&gt;LP,-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;8&lt;/td&gt;
&lt;td&gt;num&lt;/td&gt;
&lt;td&gt;IDN,num&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;9&lt;/td&gt;
&lt;td&gt;++&lt;/td&gt;
&lt;td&gt;INC,-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;10&lt;/td&gt;
&lt;td&gt;;&lt;/td&gt;
&lt;td&gt;SEMI,-&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;11&lt;/td&gt;
&lt;td&gt;}&lt;/td&gt;
&lt;td&gt;RP,-&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;种别码本身应该是一个整数，在这里为了直观起见，我们采取了宏定义的形式。&lt;/p&gt;
&lt;p&gt;我们先来看 &lt;em&gt;1&lt;/em&gt; ，&lt;code&gt;while&lt;/code&gt; 是一个关键字，因此我们采取一词一码，我们可以直接将他区分开，因此他的第二个分量是空的&lt;/p&gt;
&lt;p&gt;与 &lt;em&gt;1&lt;/em&gt; 同样的道理 &lt;code&gt;(&lt;/code&gt;、&lt;code&gt;!=&lt;/code&gt;、&lt;code&gt;)&lt;/code&gt;、&lt;code&gt;{&lt;/code&gt;、&lt;code&gt;++&lt;/code&gt;、&lt;code&gt;}&lt;/code&gt;、&lt;code&gt;;&lt;/code&gt; 我们都可以直接将他们区分，因此他们的属性值都是空的&lt;/p&gt;
&lt;p&gt;在 &lt;em&gt;3&lt;/em&gt; 和 &lt;em&gt;8&lt;/em&gt; 中，&lt;code&gt;value&lt;/code&gt; 和 &lt;code&gt;num&lt;/code&gt; 都是标识符，因此他们的种别码都是 &lt;code&gt;IDN (IDentifier)&lt;/code&gt;,他们的第二个分量用来存放他们的字面值。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;5&lt;/em&gt; &lt;code&gt;100&lt;/code&gt; 是一个常量，那么属性值就是 100 本身。&lt;/p&gt;
&lt;p&gt;THE END&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;&amp;lt;pre class=&quot;mermaid&quot;&amp;gt;
graph TD
Start-- 字符流 --&amp;gt;词法分析器
词法分析器-- 词法字节流 --&amp;gt;语法分析器
语法分析器-- 语法树 --&amp;gt;语义分析器
语义分析器-- 语法树 --&amp;gt;中间代码生成器
中间代码生成器-- 中间表示形式 --&amp;gt;机器无关代码优化器
机器无关代码优化器-- 中间表示形式 --&amp;gt;目标代码生成器
目标代码生成器-- 目标机器语言 --&amp;gt;机器相关代码优化器
机器相关代码优化器-- 目标机器语言 --&amp;gt;Fin
&amp;lt;/pre&amp;gt;&lt;/p&gt;
</content:encoded><category>Compiler</category><author>Mslxl</author></item></channel></rss>